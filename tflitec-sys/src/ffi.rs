/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub type va_list = __builtin_va_list;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinAdd: TfLiteBuiltinOperator = 0;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinAveragePool2d: TfLiteBuiltinOperator = 1;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinConcatenation: TfLiteBuiltinOperator = 2;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinConv2d: TfLiteBuiltinOperator = 3;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinDepthwiseConv2d: TfLiteBuiltinOperator = 4;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinDepthToSpace: TfLiteBuiltinOperator = 5;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinDequantize: TfLiteBuiltinOperator = 6;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinEmbeddingLookup: TfLiteBuiltinOperator = 7;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinFloor: TfLiteBuiltinOperator = 8;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinFullyConnected: TfLiteBuiltinOperator = 9;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinHashtableLookup: TfLiteBuiltinOperator = 10;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinL2Normalization: TfLiteBuiltinOperator = 11;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinL2Pool2d: TfLiteBuiltinOperator = 12;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinLocalResponseNormalization: TfLiteBuiltinOperator =
    13;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinLogistic: TfLiteBuiltinOperator = 14;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinLshProjection: TfLiteBuiltinOperator = 15;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinLstm: TfLiteBuiltinOperator = 16;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinMaxPool2d: TfLiteBuiltinOperator = 17;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinMul: TfLiteBuiltinOperator = 18;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinRelu: TfLiteBuiltinOperator = 19;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinReluN1To1: TfLiteBuiltinOperator = 20;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinRelu6: TfLiteBuiltinOperator = 21;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinReshape: TfLiteBuiltinOperator = 22;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinResizeBilinear: TfLiteBuiltinOperator = 23;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinRnn: TfLiteBuiltinOperator = 24;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSoftmax: TfLiteBuiltinOperator = 25;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSpaceToDepth: TfLiteBuiltinOperator = 26;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSvdf: TfLiteBuiltinOperator = 27;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinTanh: TfLiteBuiltinOperator = 28;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinConcatEmbeddings: TfLiteBuiltinOperator = 29;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSkipGram: TfLiteBuiltinOperator = 30;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinCall: TfLiteBuiltinOperator = 31;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinCustom: TfLiteBuiltinOperator = 32;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinEmbeddingLookupSparse: TfLiteBuiltinOperator = 33;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinPad: TfLiteBuiltinOperator = 34;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinUnidirectionalSequenceRnn: TfLiteBuiltinOperator = 35;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinGather: TfLiteBuiltinOperator = 36;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinBatchToSpaceNd: TfLiteBuiltinOperator = 37;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSpaceToBatchNd: TfLiteBuiltinOperator = 38;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinTranspose: TfLiteBuiltinOperator = 39;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinMean: TfLiteBuiltinOperator = 40;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSub: TfLiteBuiltinOperator = 41;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinDiv: TfLiteBuiltinOperator = 42;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSqueeze: TfLiteBuiltinOperator = 43;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinUnidirectionalSequenceLstm: TfLiteBuiltinOperator =
    44;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStridedSlice: TfLiteBuiltinOperator = 45;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinBidirectionalSequenceRnn: TfLiteBuiltinOperator = 46;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinExp: TfLiteBuiltinOperator = 47;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinTopkV2: TfLiteBuiltinOperator = 48;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSplit: TfLiteBuiltinOperator = 49;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinLogSoftmax: TfLiteBuiltinOperator = 50;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinDelegate: TfLiteBuiltinOperator = 51;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinBidirectionalSequenceLstm: TfLiteBuiltinOperator = 52;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinCast: TfLiteBuiltinOperator = 53;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinPrelu: TfLiteBuiltinOperator = 54;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinMaximum: TfLiteBuiltinOperator = 55;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinArgMax: TfLiteBuiltinOperator = 56;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinMinimum: TfLiteBuiltinOperator = 57;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinLess: TfLiteBuiltinOperator = 58;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinNeg: TfLiteBuiltinOperator = 59;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinPadv2: TfLiteBuiltinOperator = 60;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinGreater: TfLiteBuiltinOperator = 61;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinGreaterEqual: TfLiteBuiltinOperator = 62;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinLessEqual: TfLiteBuiltinOperator = 63;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSelect: TfLiteBuiltinOperator = 64;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSlice: TfLiteBuiltinOperator = 65;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSin: TfLiteBuiltinOperator = 66;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinTransposeConv: TfLiteBuiltinOperator = 67;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSparseToDense: TfLiteBuiltinOperator = 68;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinTile: TfLiteBuiltinOperator = 69;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinExpandDims: TfLiteBuiltinOperator = 70;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinEqual: TfLiteBuiltinOperator = 71;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinNotEqual: TfLiteBuiltinOperator = 72;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinLog: TfLiteBuiltinOperator = 73;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSum: TfLiteBuiltinOperator = 74;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSqrt: TfLiteBuiltinOperator = 75;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinRsqrt: TfLiteBuiltinOperator = 76;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinShape: TfLiteBuiltinOperator = 77;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinPow: TfLiteBuiltinOperator = 78;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinArgMin: TfLiteBuiltinOperator = 79;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinFakeQuant: TfLiteBuiltinOperator = 80;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinReduceProd: TfLiteBuiltinOperator = 81;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinReduceMax: TfLiteBuiltinOperator = 82;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinPack: TfLiteBuiltinOperator = 83;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinLogicalOr: TfLiteBuiltinOperator = 84;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinOneHot: TfLiteBuiltinOperator = 85;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinLogicalAnd: TfLiteBuiltinOperator = 86;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinLogicalNot: TfLiteBuiltinOperator = 87;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinUnpack: TfLiteBuiltinOperator = 88;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinReduceMin: TfLiteBuiltinOperator = 89;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinFloorDiv: TfLiteBuiltinOperator = 90;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinReduceAny: TfLiteBuiltinOperator = 91;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSquare: TfLiteBuiltinOperator = 92;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinZerosLike: TfLiteBuiltinOperator = 93;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinFill: TfLiteBuiltinOperator = 94;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinFloorMod: TfLiteBuiltinOperator = 95;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinRange: TfLiteBuiltinOperator = 96;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinResizeNearestNeighbor: TfLiteBuiltinOperator = 97;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinLeakyRelu: TfLiteBuiltinOperator = 98;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSquaredDifference: TfLiteBuiltinOperator = 99;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinMirrorPad: TfLiteBuiltinOperator = 100;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinAbs: TfLiteBuiltinOperator = 101;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSplitV: TfLiteBuiltinOperator = 102;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinUnique: TfLiteBuiltinOperator = 103;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinCeil: TfLiteBuiltinOperator = 104;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinReverseV2: TfLiteBuiltinOperator = 105;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinAddN: TfLiteBuiltinOperator = 106;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinGatherNd: TfLiteBuiltinOperator = 107;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinCos: TfLiteBuiltinOperator = 108;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinWhere: TfLiteBuiltinOperator = 109;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinRank: TfLiteBuiltinOperator = 110;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinElu: TfLiteBuiltinOperator = 111;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinReverseSequence: TfLiteBuiltinOperator = 112;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinMatrixDiag: TfLiteBuiltinOperator = 113;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinQuantize: TfLiteBuiltinOperator = 114;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinMatrixSetDiag: TfLiteBuiltinOperator = 115;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinRound: TfLiteBuiltinOperator = 116;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinHardSwish: TfLiteBuiltinOperator = 117;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinIf: TfLiteBuiltinOperator = 118;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinWhile: TfLiteBuiltinOperator = 119;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinNonMaxSuppressionV4: TfLiteBuiltinOperator = 120;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinNonMaxSuppressionV5: TfLiteBuiltinOperator = 121;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinScatterNd: TfLiteBuiltinOperator = 122;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSelectV2: TfLiteBuiltinOperator = 123;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinDensify: TfLiteBuiltinOperator = 124;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSegmentSum: TfLiteBuiltinOperator = 125;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinBatchMatmul: TfLiteBuiltinOperator = 126;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinPlaceholderForGreaterOpCodes: TfLiteBuiltinOperator =
    127;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinCumsum: TfLiteBuiltinOperator = 128;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinCallOnce: TfLiteBuiltinOperator = 129;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinBroadcastTo: TfLiteBuiltinOperator = 130;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinRfft2d: TfLiteBuiltinOperator = 131;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinConv3d: TfLiteBuiltinOperator = 132;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinImag: TfLiteBuiltinOperator = 133;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinReal: TfLiteBuiltinOperator = 134;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinComplexAbs: TfLiteBuiltinOperator = 135;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinHashtable: TfLiteBuiltinOperator = 136;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinHashtableFind: TfLiteBuiltinOperator = 137;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinHashtableImport: TfLiteBuiltinOperator = 138;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinHashtableSize: TfLiteBuiltinOperator = 139;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinReduceAll: TfLiteBuiltinOperator = 140;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinConv3dTranspose: TfLiteBuiltinOperator = 141;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinVarHandle: TfLiteBuiltinOperator = 142;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinReadVariable: TfLiteBuiltinOperator = 143;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinAssignVariable: TfLiteBuiltinOperator = 144;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinBroadcastArgs: TfLiteBuiltinOperator = 145;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinRandomStandardNormal: TfLiteBuiltinOperator = 146;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinBucketize: TfLiteBuiltinOperator = 147;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinRandomUniform: TfLiteBuiltinOperator = 148;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinMultinomial: TfLiteBuiltinOperator = 149;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinGelu: TfLiteBuiltinOperator = 150;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinDynamicUpdateSlice: TfLiteBuiltinOperator = 151;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinRelu0To1: TfLiteBuiltinOperator = 152;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinUnsortedSegmentProd: TfLiteBuiltinOperator = 153;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinUnsortedSegmentMax: TfLiteBuiltinOperator = 154;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinUnsortedSegmentSum: TfLiteBuiltinOperator = 155;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinAtan2: TfLiteBuiltinOperator = 156;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinUnsortedSegmentMin: TfLiteBuiltinOperator = 157;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSign: TfLiteBuiltinOperator = 158;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinBitcast: TfLiteBuiltinOperator = 159;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinBitwiseXor: TfLiteBuiltinOperator = 160;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinRightShift: TfLiteBuiltinOperator = 161;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloLogistic: TfLiteBuiltinOperator = 162;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloAdd: TfLiteBuiltinOperator = 163;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloDivide: TfLiteBuiltinOperator = 164;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloMultiply: TfLiteBuiltinOperator = 165;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloMaximum: TfLiteBuiltinOperator = 166;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloReshape: TfLiteBuiltinOperator = 167;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloClamp: TfLiteBuiltinOperator = 168;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloConcatenate: TfLiteBuiltinOperator = 169;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloBroadcastInDim: TfLiteBuiltinOperator = 170;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloConvolution: TfLiteBuiltinOperator = 171;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloSlice: TfLiteBuiltinOperator = 172;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloCustomCall: TfLiteBuiltinOperator = 173;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloReduce: TfLiteBuiltinOperator = 174;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloAbs: TfLiteBuiltinOperator = 175;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloAnd: TfLiteBuiltinOperator = 176;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloCosine: TfLiteBuiltinOperator = 177;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloExponential: TfLiteBuiltinOperator = 178;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloFloor: TfLiteBuiltinOperator = 179;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloLog: TfLiteBuiltinOperator = 180;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloMinimum: TfLiteBuiltinOperator = 181;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloNegate: TfLiteBuiltinOperator = 182;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloOr: TfLiteBuiltinOperator = 183;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloPower: TfLiteBuiltinOperator = 184;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloRemainder: TfLiteBuiltinOperator = 185;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloRsqrt: TfLiteBuiltinOperator = 186;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloSelect: TfLiteBuiltinOperator = 187;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloSubtract: TfLiteBuiltinOperator = 188;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloTanh: TfLiteBuiltinOperator = 189;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloScatter: TfLiteBuiltinOperator = 190;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloCompare: TfLiteBuiltinOperator = 191;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloConvert: TfLiteBuiltinOperator = 192;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloDynamicSlice: TfLiteBuiltinOperator = 193;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloDynamicUpdateSlice: TfLiteBuiltinOperator =
    194;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloPad: TfLiteBuiltinOperator = 195;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloIota: TfLiteBuiltinOperator = 196;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloDotGeneral: TfLiteBuiltinOperator = 197;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloReduceWindow: TfLiteBuiltinOperator = 198;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloSort: TfLiteBuiltinOperator = 199;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloWhile: TfLiteBuiltinOperator = 200;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloGather: TfLiteBuiltinOperator = 201;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloTranspose: TfLiteBuiltinOperator = 202;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinDilate: TfLiteBuiltinOperator = 203;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloRngBitGenerator: TfLiteBuiltinOperator = 204;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinReduceWindow: TfLiteBuiltinOperator = 205;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloComposite: TfLiteBuiltinOperator = 206;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloShiftLeft: TfLiteBuiltinOperator = 207;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloCbrt: TfLiteBuiltinOperator = 208;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloCase: TfLiteBuiltinOperator = 209;
pub type TfLiteBuiltinOperator = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteAsyncKernel {
    _unused: [u8; 0],
}
pub const TfLiteType_kTfLiteNoType: TfLiteType = 0;
pub const TfLiteType_kTfLiteFloat32: TfLiteType = 1;
pub const TfLiteType_kTfLiteInt32: TfLiteType = 2;
pub const TfLiteType_kTfLiteUInt8: TfLiteType = 3;
pub const TfLiteType_kTfLiteInt64: TfLiteType = 4;
pub const TfLiteType_kTfLiteString: TfLiteType = 5;
pub const TfLiteType_kTfLiteBool: TfLiteType = 6;
pub const TfLiteType_kTfLiteInt16: TfLiteType = 7;
pub const TfLiteType_kTfLiteComplex64: TfLiteType = 8;
pub const TfLiteType_kTfLiteInt8: TfLiteType = 9;
pub const TfLiteType_kTfLiteFloat16: TfLiteType = 10;
pub const TfLiteType_kTfLiteFloat64: TfLiteType = 11;
pub const TfLiteType_kTfLiteComplex128: TfLiteType = 12;
pub const TfLiteType_kTfLiteUInt64: TfLiteType = 13;
pub const TfLiteType_kTfLiteResource: TfLiteType = 14;
pub const TfLiteType_kTfLiteVariant: TfLiteType = 15;
pub const TfLiteType_kTfLiteUInt32: TfLiteType = 16;
pub const TfLiteType_kTfLiteUInt16: TfLiteType = 17;
pub const TfLiteType_kTfLiteInt4: TfLiteType = 18;
pub const TfLiteType_kTfLiteBFloat16: TfLiteType = 19;
#[doc = " Types supported by tensor"]
pub type TfLiteType = ::std::os::raw::c_uint;
#[doc = " Legacy. Will be deprecated in favor of `TfLiteAffineQuantization`.\n If per-layer quantization is specified this field will still be populated in\n addition to `TfLiteAffineQuantization`.\n Parameters for asymmetric quantization. Quantized values can be converted\n back to float using: `real_value = scale * (quantized_value - zero_point)`"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteQuantizationParams {
    pub scale: f32,
    pub zero_point: i32,
}
#[test]
fn bindgen_test_layout_TfLiteQuantizationParams() {
    const UNINIT: ::std::mem::MaybeUninit<TfLiteQuantizationParams> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TfLiteQuantizationParams>(),
        8usize,
        concat!("Size of: ", stringify!(TfLiteQuantizationParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteQuantizationParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteQuantizationParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteQuantizationParams),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zero_point) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteQuantizationParams),
            "::",
            stringify!(zero_point)
        )
    );
}
pub const TfLiteDimensionType_kTfLiteDimDense: TfLiteDimensionType = 0;
pub const TfLiteDimensionType_kTfLiteDimSparseCSR: TfLiteDimensionType = 1;
#[doc = " Storage format of each dimension in a sparse tensor."]
pub type TfLiteDimensionType = ::std::os::raw::c_uint;
#[doc = " Success"]
pub const TfLiteStatus_kTfLiteOk: TfLiteStatus = 0;
#[doc = " Generally referring to an error in the runtime (i.e. interpreter)"]
pub const TfLiteStatus_kTfLiteError: TfLiteStatus = 1;
#[doc = " Generally referring to an error from a TfLiteDelegate itself."]
pub const TfLiteStatus_kTfLiteDelegateError: TfLiteStatus = 2;
#[doc = " Generally referring to an error in applying a delegate due to\n incompatibility between runtime and delegate, e.g., this error is returned\n when trying to apply a TF Lite delegate onto a model graph that's already\n immutable."]
pub const TfLiteStatus_kTfLiteApplicationError: TfLiteStatus = 3;
#[doc = " Generally referring to serialized delegate data not being found.\n See tflite::delegates::Serialization."]
pub const TfLiteStatus_kTfLiteDelegateDataNotFound: TfLiteStatus = 4;
#[doc = " Generally referring to data-writing issues in delegate serialization.\n See tflite::delegates::Serialization."]
pub const TfLiteStatus_kTfLiteDelegateDataWriteError: TfLiteStatus = 5;
#[doc = " Generally referring to data-reading issues in delegate serialization.\n See tflite::delegates::Serialization."]
pub const TfLiteStatus_kTfLiteDelegateDataReadError: TfLiteStatus = 6;
#[doc = " Generally referring to issues when the TF Lite model has ops that cannot\n be resolved at runtime. This could happen when the specific op is not\n registered or built with the TF Lite framework."]
pub const TfLiteStatus_kTfLiteUnresolvedOps: TfLiteStatus = 7;
#[doc = " Generally referring to invocation cancelled by the user.\n See `interpreter::Cancel`."]
pub const TfLiteStatus_kTfLiteCancelled: TfLiteStatus = 8;
#[doc = " Generally referring to invocation cancelled by the user.\n See `interpreter::Cancel`."]
pub const TfLiteStatus_kTfLiteOutputShapeNotKnown: TfLiteStatus = 9;
#[doc = " Note that new error status values may be added in future in order to\n indicate more fine-grained internal states, therefore, applications should\n not rely on status values being members of the enum."]
pub type TfLiteStatus = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteOpaqueContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteOpaqueNode {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteOpaqueTensor {
    _unused: [u8; 0],
}
#[doc = " WARNING: This is an experimental interface that is subject to change."]
pub type TfLiteOpaqueDelegate = TfLiteDelegate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteOperator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteModel {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteInterpreterOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteInterpreter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteSignatureRunner {
    _unused: [u8; 0],
}
pub const TfLiteExternalContextType_kTfLiteEigenContext: TfLiteExternalContextType = 0;
#[doc = " include eigen_support.h to use."]
pub const TfLiteExternalContextType_kTfLiteGemmLowpContext: TfLiteExternalContextType = 1;
#[doc = " include gemm_support.h to use."]
pub const TfLiteExternalContextType_kTfLiteEdgeTpuContext: TfLiteExternalContextType = 2;
#[doc = " Placeholder for Edge TPU support."]
pub const TfLiteExternalContextType_kTfLiteCpuBackendContext: TfLiteExternalContextType = 3;
#[doc = " include cpu_backend_context.h to use."]
pub const TfLiteExternalContextType_kTfLiteLiteRtBufferContext: TfLiteExternalContextType = 4;
#[doc = " include external_litert_buffer_context.h to use."]
pub const TfLiteExternalContextType_kTfLiteMaxExternalContexts: TfLiteExternalContextType = 5;
#[doc = " The list of external context types known to TF Lite. This list exists solely\n to avoid conflicts and to ensure ops can share the external contexts they\n need. Access to the external contexts is controlled by one of the\n corresponding support files."]
pub type TfLiteExternalContextType = ::std::os::raw::c_uint;
#[doc = " An external context is a collection of information unrelated to the TF Lite\n framework, but useful to a subset of the ops. TF Lite knows very little\n about the actual contexts, but it keeps a list of them, and is able to\n refresh them if configurations like the number of recommended threads\n change."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteExternalContext {
    pub type_: TfLiteExternalContextType,
    pub Refresh:
        ::std::option::Option<unsafe extern "C" fn(context: *mut TfLiteContext) -> TfLiteStatus>,
}
#[test]
fn bindgen_test_layout_TfLiteExternalContext() {
    const UNINIT: ::std::mem::MaybeUninit<TfLiteExternalContext> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TfLiteExternalContext>(),
        16usize,
        concat!("Size of: ", stringify!(TfLiteExternalContext))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteExternalContext>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteExternalContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteExternalContext),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Refresh) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteExternalContext),
            "::",
            stringify!(Refresh)
        )
    );
}
#[doc = " Fixed size list of integers. Used for dimensions and inputs/outputs tensor\n indices"]
#[repr(C)]
#[derive(Debug)]
pub struct TfLiteIntArray {
    pub size: ::std::os::raw::c_int,
    pub data: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_TfLiteIntArray() {
    const UNINIT: ::std::mem::MaybeUninit<TfLiteIntArray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TfLiteIntArray>(),
        4usize,
        concat!("Size of: ", stringify!(TfLiteIntArray))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteIntArray>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteIntArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteIntArray),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteIntArray),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Fixed size list of floats. Used for per-channel quantization."]
#[repr(C)]
#[derive(Debug)]
pub struct TfLiteFloatArray {
    pub size: ::std::os::raw::c_int,
    pub data: __IncompleteArrayField<f32>,
}
#[test]
fn bindgen_test_layout_TfLiteFloatArray() {
    const UNINIT: ::std::mem::MaybeUninit<TfLiteFloatArray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TfLiteFloatArray>(),
        4usize,
        concat!("Size of: ", stringify!(TfLiteFloatArray))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteFloatArray>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteFloatArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteFloatArray),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteFloatArray),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Single-precision complex data type compatible with the C99 definition."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteComplex64 {
    pub re: f32,
    pub im: f32,
}
#[test]
fn bindgen_test_layout_TfLiteComplex64() {
    const UNINIT: ::std::mem::MaybeUninit<TfLiteComplex64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TfLiteComplex64>(),
        8usize,
        concat!("Size of: ", stringify!(TfLiteComplex64))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteComplex64>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteComplex64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).re) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteComplex64),
            "::",
            stringify!(re)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).im) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteComplex64),
            "::",
            stringify!(im)
        )
    );
}
#[doc = " Double-precision complex data type compatible with the C99 definition."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteComplex128 {
    pub re: f64,
    pub im: f64,
}
#[test]
fn bindgen_test_layout_TfLiteComplex128() {
    const UNINIT: ::std::mem::MaybeUninit<TfLiteComplex128> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TfLiteComplex128>(),
        16usize,
        concat!("Size of: ", stringify!(TfLiteComplex128))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteComplex128>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteComplex128))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).re) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteComplex128),
            "::",
            stringify!(re)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).im) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteComplex128),
            "::",
            stringify!(im)
        )
    );
}
#[doc = " Half precision data type compatible with the C99 definition."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteFloat16 {
    pub data: u16,
}
#[test]
fn bindgen_test_layout_TfLiteFloat16() {
    const UNINIT: ::std::mem::MaybeUninit<TfLiteFloat16> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TfLiteFloat16>(),
        2usize,
        concat!("Size of: ", stringify!(TfLiteFloat16))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteFloat16>(),
        2usize,
        concat!("Alignment of ", stringify!(TfLiteFloat16))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteFloat16),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " bfloat16 data type compatible with the Google Brain definition.\n https://cloud.google.com/tpu/docs/bfloat16.\n This provides 1 bit of sign, 8 bits of exponent, and 7 bits of mantissa."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteBFloat16 {
    pub data: u16,
}
#[test]
fn bindgen_test_layout_TfLiteBFloat16() {
    const UNINIT: ::std::mem::MaybeUninit<TfLiteBFloat16> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TfLiteBFloat16>(),
        2usize,
        concat!("Size of: ", stringify!(TfLiteBFloat16))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteBFloat16>(),
        2usize,
        concat!("Alignment of ", stringify!(TfLiteBFloat16))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteBFloat16),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " No quantization."]
pub const TfLiteQuantizationType_kTfLiteNoQuantization: TfLiteQuantizationType = 0;
#[doc = " Affine quantization (with support for per-channel quantization).\n Corresponds to TfLiteAffineQuantization."]
pub const TfLiteQuantizationType_kTfLiteAffineQuantization: TfLiteQuantizationType = 1;
#[doc = " SupportedQuantizationTypes."]
pub type TfLiteQuantizationType = ::std::os::raw::c_int;
#[doc = " Structure specifying the quantization used by the tensor, if-any."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteQuantization {
    #[doc = " The type of quantization held by params."]
    pub type_: TfLiteQuantizationType,
    #[doc = " Holds an optional reference to a quantization param structure. The actual\n type depends on the value of the `type` field (see the comment there for\n the values and corresponding types)."]
    pub params: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_TfLiteQuantization() {
    const UNINIT: ::std::mem::MaybeUninit<TfLiteQuantization> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TfLiteQuantization>(),
        16usize,
        concat!("Size of: ", stringify!(TfLiteQuantization))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteQuantization>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteQuantization))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteQuantization),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteQuantization),
            "::",
            stringify!(params)
        )
    );
}
#[doc = " A union of pointers that points to memory for a given tensor.\n\n Do not access these members directly, if possible, use\n `GetTensorData<TYPE>(tensor)` instead, otherwise only access `.data`, as\n other members are deprecated."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union TfLitePtrUnion {
    pub i32_: *mut i32,
    pub u32_: *mut u32,
    pub i64_: *mut i64,
    pub u64_: *mut u64,
    pub f: *mut f32,
    pub f16: *mut TfLiteFloat16,
    pub bf16: *mut TfLiteBFloat16,
    pub f64_: *mut f64,
    pub raw: *mut ::std::os::raw::c_char,
    pub raw_const: *const ::std::os::raw::c_char,
    pub uint8: *mut u8,
    pub b: *mut bool,
    pub i16_: *mut i16,
    pub ui16: *mut u16,
    pub c64: *mut TfLiteComplex64,
    pub c128: *mut TfLiteComplex128,
    pub int8: *mut i8,
    #[doc = " Only use this member."]
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_TfLitePtrUnion() {
    const UNINIT: ::std::mem::MaybeUninit<TfLitePtrUnion> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TfLitePtrUnion>(),
        8usize,
        concat!("Size of: ", stringify!(TfLitePtrUnion))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLitePtrUnion>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLitePtrUnion))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(i32_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(u32_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(i64_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(u64_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(f16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bf16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(bf16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(f64_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_const) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(raw_const)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uint8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(uint8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i16_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(i16_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ui16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(ui16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(c64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c128) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(c128)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(int8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(data)
        )
    );
}
pub const TfLiteAllocationType_kTfLiteMemNone: TfLiteAllocationType = 0;
pub const TfLiteAllocationType_kTfLiteMmapRo: TfLiteAllocationType = 1;
pub const TfLiteAllocationType_kTfLiteArenaRw: TfLiteAllocationType = 2;
pub const TfLiteAllocationType_kTfLiteArenaRwPersistent: TfLiteAllocationType = 3;
pub const TfLiteAllocationType_kTfLiteDynamic: TfLiteAllocationType = 4;
pub const TfLiteAllocationType_kTfLitePersistentRo: TfLiteAllocationType = 5;
pub const TfLiteAllocationType_kTfLiteCustom: TfLiteAllocationType = 6;
pub const TfLiteAllocationType_kTfLiteVariantObject: TfLiteAllocationType = 7;
#[doc = " Memory allocation strategies.\n  * `kTfLiteMmapRo`: Read-only memory-mapped data, or data externally\n        allocated.\n  * `kTfLiteArenaRw`: Arena allocated with no guarantees about persistence,\n        and available during eval.\n  * `kTfLiteArenaRwPersistent`: Arena allocated but persistent across eval,\n  and only available during eval.\n  * `kTfLiteDynamic`: Allocated during eval, or for string tensors.\n  * `kTfLitePersistentRo`: Allocated and populated during prepare. This is\n        useful for tensors that can be computed during prepare and treated\n        as constant inputs for downstream ops (also in prepare).\n  * `kTfLiteCustom`: Custom memory allocation provided by the user. See\n        TfLiteCustomAllocation below.\n  * `kTfLiteVariantObject`: Allocation is an arbitrary type-erased C++\n  object.\n        Allocation and deallocation are done through `new` and `delete`."]
pub type TfLiteAllocationType = ::std::os::raw::c_uint;
pub const TfLiteAllocationStrategy_kTfLiteAllocationStrategyUnknown: TfLiteAllocationStrategy = 0;
pub const TfLiteAllocationStrategy_kTfLiteAllocationStrategyNone: TfLiteAllocationStrategy = 1;
#[doc = " No data is allocated."]
pub const TfLiteAllocationStrategy_kTfLiteAllocationStrategyMMap: TfLiteAllocationStrategy = 2;
#[doc = " Data is mmaped."]
pub const TfLiteAllocationStrategy_kTfLiteAllocationStrategyArena: TfLiteAllocationStrategy = 3;
#[doc = " Handled by the arena."]
pub const TfLiteAllocationStrategy_kTfLiteAllocationStrategyMalloc: TfLiteAllocationStrategy = 4;
#[doc = " Uses `malloc`/`free`."]
pub const TfLiteAllocationStrategy_kTfLiteAllocationStrategyNew: TfLiteAllocationStrategy = 5;
#[doc = " Memory allocation strategies.\n\n TfLiteAllocationType values have been overloaded to mean more than their\n original intent. This enum should only be used to document the allocation\n strategy used by a tensor for it data."]
pub type TfLiteAllocationStrategy = ::std::os::raw::c_uint;
pub const TfLiteRunStability_kTfLiteRunStabilityUnknown: TfLiteRunStability = 0;
pub const TfLiteRunStability_kTfLiteRunStabilityUnstable: TfLiteRunStability = 1;
#[doc = " May change at any time."]
pub const TfLiteRunStability_kTfLiteRunStabilitySingleRun: TfLiteRunStability = 2;
#[doc = " Will stay the same for one run."]
pub const TfLiteRunStability_kTfLiteRunStabilityAcrossRuns: TfLiteRunStability = 3;
#[doc = " Describes how stable a tensor attribute is with regards to an interpreter\n runs."]
pub type TfLiteRunStability = ::std::os::raw::c_uint;
pub const TfLiteRunStep_kTfLiteRunStepUnknown: TfLiteRunStep = 0;
pub const TfLiteRunStep_kTfLiteRunStepInit: TfLiteRunStep = 1;
pub const TfLiteRunStep_kTfLiteRunStepPrepare: TfLiteRunStep = 2;
pub const TfLiteRunStep_kTfLiteRunStepEval: TfLiteRunStep = 3;
#[doc = " Describes the steps of a TFLite operation life cycle."]
pub type TfLiteRunStep = ::std::os::raw::c_uint;
#[doc = " The delegates should use zero or positive integers to represent handles.\n -1 is reserved from unallocated status."]
pub type TfLiteBufferHandle = ::std::os::raw::c_int;
#[doc = " Metadata to encode each dimension in a sparse tensor."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteDimensionMetadata {
    pub format: TfLiteDimensionType,
    pub dense_size: ::std::os::raw::c_int,
    pub array_segments: *mut TfLiteIntArray,
    pub array_indices: *mut TfLiteIntArray,
}
#[test]
fn bindgen_test_layout_TfLiteDimensionMetadata() {
    const UNINIT: ::std::mem::MaybeUninit<TfLiteDimensionMetadata> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TfLiteDimensionMetadata>(),
        24usize,
        concat!("Size of: ", stringify!(TfLiteDimensionMetadata))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteDimensionMetadata>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteDimensionMetadata))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDimensionMetadata),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dense_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDimensionMetadata),
            "::",
            stringify!(dense_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array_segments) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDimensionMetadata),
            "::",
            stringify!(array_segments)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array_indices) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDimensionMetadata),
            "::",
            stringify!(array_indices)
        )
    );
}
#[doc = " Parameters used to encode a sparse tensor. For detailed explanation of each\n field please refer to lite/schema/schema.fbs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteSparsity {
    pub traversal_order: *mut TfLiteIntArray,
    pub block_map: *mut TfLiteIntArray,
    pub dim_metadata: *mut TfLiteDimensionMetadata,
    pub dim_metadata_size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TfLiteSparsity() {
    const UNINIT: ::std::mem::MaybeUninit<TfLiteSparsity> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TfLiteSparsity>(),
        32usize,
        concat!("Size of: ", stringify!(TfLiteSparsity))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteSparsity>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteSparsity))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).traversal_order) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSparsity),
            "::",
            stringify!(traversal_order)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_map) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSparsity),
            "::",
            stringify!(block_map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dim_metadata) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSparsity),
            "::",
            stringify!(dim_metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dim_metadata_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSparsity),
            "::",
            stringify!(dim_metadata_size)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TfLiteTensor {
    #[doc = " The data type specification for data stored in `data`. This affects\n what member of `data` union should be used."]
    pub type_: TfLiteType,
    #[doc = " A union of data pointers. The appropriate type should be used for a typed\n tensor based on `type`."]
    pub data: TfLitePtrUnion,
    #[doc = " A pointer to a structure representing the dimensionality interpretation\n that the buffer should have. NOTE: the product of elements of `dims`\n and the element datatype size should be equal to `bytes` below."]
    pub dims: *mut TfLiteIntArray,
    #[doc = " Quantization information."]
    pub params: TfLiteQuantizationParams,
    #[doc = " How memory is mapped\n  kTfLiteMmapRo: Memory mapped read only.\n  i.e. weights\n  kTfLiteArenaRw: Arena allocated read write memory\n  (i.e. temporaries, outputs)."]
    pub allocation_type: TfLiteAllocationType,
    #[doc = " The number of bytes required to store the data of this Tensor. I.e.\n (bytes of each element) * dims[0] * ... * dims[n-1].  For example, if\n type is kTfLiteFloat32 and dims = {3, 2} then\n bytes = sizeof(float) * 3 * 2 = 4 * 3 * 2 = 24."]
    pub bytes: usize,
    #[doc = " An opaque pointer to a tflite::MMapAllocation"]
    pub allocation: *const ::std::os::raw::c_void,
    #[doc = " Null-terminated name of this tensor."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " The delegate which knows how to handle `buffer_handle`.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub delegate: *mut TfLiteDelegate,
    #[doc = " An integer buffer handle that can be handled by `delegate`.\n The value is valid only when delegate is not null.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub buffer_handle: TfLiteBufferHandle,
    #[doc = " If the delegate uses its own buffer (e.g. GPU memory), the delegate is\n responsible to set data_is_stale to true.\n `delegate->CopyFromBufferHandle` can be called to copy the data from\n delegate buffer.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub data_is_stale: bool,
    #[doc = " True if the tensor is a variable."]
    pub is_variable: bool,
    #[doc = " Quantization information. Replaces params field above."]
    pub quantization: TfLiteQuantization,
    #[doc = " Parameters used to encode a sparse tensor.\n This is optional. The field is NULL if a tensor is dense.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub sparsity: *mut TfLiteSparsity,
    #[doc = " Optional. Encodes shapes with unknown dimensions with -1. This field is\n only populated when unknown dimensions exist in a read-write tensor (i.e.\n an input or output tensor). (e.g.  `dims` contains [1, 1, 1, 3] and\n `dims_signature` contains [1, -1, -1, 3]).  If no unknown dimensions exist\n then `dims_signature` is either null, or set to an empty array.  Note that\n this field only exists when TF_LITE_STATIC_MEMORY is not defined."]
    pub dims_signature: *const TfLiteIntArray,
}
#[test]
fn bindgen_test_layout_TfLiteTensor() {
    const UNINIT: ::std::mem::MaybeUninit<TfLiteTensor> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TfLiteTensor>(),
        112usize,
        concat!("Size of: ", stringify!(TfLiteTensor))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteTensor>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteTensor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dims) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(dims)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocation_type) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(allocation_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocation) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(allocation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delegate) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(delegate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_handle) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(buffer_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_is_stale) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(data_is_stale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_variable) as usize - ptr as usize },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(is_variable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quantization) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(quantization)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sparsity) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(sparsity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dims_signature) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(dims_signature)
        )
    );
}
#[doc = " A structure representing an instance of a node.\n This structure only exhibits the inputs, outputs, user defined data and some\n node properties (like statefulness), not other features like the type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteNode {
    #[doc = " Inputs to this node expressed as indices into the simulator's tensors."]
    pub inputs: *mut TfLiteIntArray,
    #[doc = " Outputs to this node expressed as indices into the simulator's tensors."]
    pub outputs: *mut TfLiteIntArray,
    #[doc = " intermediate tensors to this node expressed as indices into the\n simulator's tensors."]
    pub intermediates: *mut TfLiteIntArray,
    #[doc = " Temporary tensors uses during the computations. This usually contains no\n tensors, but ops are allowed to change that if they need scratch space of\n any sort."]
    pub temporaries: *mut TfLiteIntArray,
    #[doc = " Opaque data provided by the node implementer through `Registration.init`."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " Opaque data provided to the node if the node is a builtin. This is usually\n a structure defined in builtin_op_data.h"]
    pub builtin_data: *mut ::std::os::raw::c_void,
    #[doc = " Custom initial data. This is the opaque data provided in the flatbuffer.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub custom_initial_data: *const ::std::os::raw::c_void,
    pub custom_initial_data_size: ::std::os::raw::c_int,
    #[doc = " The pointer to the delegate. This is non-null only when the node is\n created by calling `interpreter.ModifyGraphWithDelegate`.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub delegate: *mut TfLiteDelegate,
    #[doc = " Whether this op might have side effect (e.g. stateful op)."]
    pub might_have_side_effect: bool,
}
#[test]
fn bindgen_test_layout_TfLiteNode() {
    const UNINIT: ::std::mem::MaybeUninit<TfLiteNode> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TfLiteNode>(),
        80usize,
        concat!("Size of: ", stringify!(TfLiteNode))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteNode>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteNode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(inputs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(outputs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intermediates) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(intermediates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temporaries) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(temporaries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).builtin_data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(builtin_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_initial_data) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(custom_initial_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_initial_data_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(custom_initial_data_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delegate) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(delegate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).might_have_side_effect) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(might_have_side_effect)
        )
    );
}
#[doc = " Light-weight tensor struct for TF Micro runtime. Provides the minimal amount\n of information required for a kernel to run during TfLiteRegistration::Eval."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TfLiteEvalTensor {
    #[doc = " A union of data pointers. The appropriate type should be used for a typed\n tensor based on `type`."]
    pub data: TfLitePtrUnion,
    #[doc = " A pointer to a structure representing the dimensionality interpretation\n that the buffer should have."]
    pub dims: *mut TfLiteIntArray,
    #[doc = " The data type specification for data stored in `data`. This affects\n what member of `data` union should be used."]
    pub type_: TfLiteType,
}
#[test]
fn bindgen_test_layout_TfLiteEvalTensor() {
    const UNINIT: ::std::mem::MaybeUninit<TfLiteEvalTensor> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TfLiteEvalTensor>(),
        24usize,
        concat!("Size of: ", stringify!(TfLiteEvalTensor))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteEvalTensor>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteEvalTensor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteEvalTensor),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dims) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteEvalTensor),
            "::",
            stringify!(dims)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteEvalTensor),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = " WARNING: This is an experimental interface that is subject to change.\n\n Currently, TfLiteDelegateParams has to be allocated in a way that it's\n trivially destructable. It will be stored as `builtin_data` field in\n `TfLiteNode` of the delegate node.\n\n See also the `CreateDelegateParams` function in `interpreter.cc` details."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteDelegateParams {
    pub delegate: *mut TfLiteDelegate,
    pub nodes_to_replace: *mut TfLiteIntArray,
    pub input_tensors: *mut TfLiteIntArray,
    pub output_tensors: *mut TfLiteIntArray,
}
#[test]
fn bindgen_test_layout_TfLiteDelegateParams() {
    const UNINIT: ::std::mem::MaybeUninit<TfLiteDelegateParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TfLiteDelegateParams>(),
        32usize,
        concat!("Size of: ", stringify!(TfLiteDelegateParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteDelegateParams>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteDelegateParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delegate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegateParams),
            "::",
            stringify!(delegate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nodes_to_replace) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegateParams),
            "::",
            stringify!(nodes_to_replace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_tensors) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegateParams),
            "::",
            stringify!(input_tensors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_tensors) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegateParams),
            "::",
            stringify!(output_tensors)
        )
    );
}
#[doc = " `TfLiteContext` allows an op to access the tensors.\n\n `TfLiteContext` is a struct that is created by the TF Lite runtime\n and passed to the \"methods\" (C function pointers) in the\n `TfLiteRegistration` struct that are used to define custom ops and custom\n delegate kernels. It contains information and methods (C function pointers)\n that can be called by the code implementing a custom op or a custom delegate\n kernel. These methods provide access to the context in which that custom op\n or custom delegate kernel occurs, such as access to the input and output\n tensors for that op, as well as methods for allocating memory buffers\n and intermediate tensors, etc.\n\n See also `TfLiteOpaqueContext`, which is an more ABI-stable equivalent."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteContext {
    #[doc = " Number of tensors in the context."]
    pub tensors_size: usize,
    #[doc = " The execution plan contains a list of the node indices in execution\n order. execution_plan->size is the current number of nodes. And,\n execution_plan->data[0] is the first node that needs to be run.\n TfLiteDelegates can traverse the current execution plan by iterating\n through each member of this array and using GetNodeAndRegistration() to\n access details about a node. i.e.\n\n\n     TfLiteIntArray* execution_plan;\n     TF_LITE_ENSURE_STATUS(context->GetExecutionPlan(context,\n                                                     &execution_plan));\n     for (int exec_index = 0; exec_index < execution_plan->size;\n           exec_index++) {\n        int node_index = execution_plan->data[exec_index];\n        TfLiteNode* node;\n        TfLiteRegistration* reg;\n        context->GetNodeAndRegistration(context, node_index, &node, &reg);\n     }\n\n Note: the memory pointed by '`*execution_plan` is OWNED by TfLite runtime.\n Future calls to GetExecutionPlan invalidates earlier outputs. The\n following code snippet shows the issue of such an invocation pattern.\n After calling CheckNode, subsequent access to `plan_1st` is undefined.\n\n     void CheckNode(const TfLiteNode* node) {\n       ...\n       TfLiteIntArray* plan_2nd;\n       TF_LITE_ENSURE_STATUS(\n           context->GetExecutionPlan(context, &plan_2nd)\n       );\n       ...\n     }\n\n     TfLiteIntArray* plan_1st;\n     TF_LITE_ENSURE_STATUS(context->GetExecutionPlan(context, &plan_1st));\n     for (int exec_index = 0; exec_index < plan_1st->size; exec_index++) {\n        int node_index = plan_1st->data[exec_index];\n        TfLiteNode* node;\n        TfLiteRegistration* reg;\n        context->GetNodeAndRegistration(context, node_index, &node, &reg);\n        CheckNode(node);\n     }\n\n WARNING: This is an experimental interface that is subject to change."]
    pub GetExecutionPlan: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            execution_plan: *mut *mut TfLiteIntArray,
        ) -> TfLiteStatus,
    >,
    #[doc = " An array of tensors in the interpreter context (of length `tensors_size`)"]
    pub tensors: *mut TfLiteTensor,
    #[doc = " opaque full context ptr (an opaque c++ data structure)"]
    pub impl_: *mut ::std::os::raw::c_void,
    #[doc = " Request memory pointer be resized. Updates dimensions on the tensor.\n NOTE: ResizeTensor takes ownership of newSize."]
    pub ResizeTensor: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut TfLiteContext,
            tensor: *mut TfLiteTensor,
            new_size: *mut TfLiteIntArray,
        ) -> TfLiteStatus,
    >,
    #[doc = " Request that an error be reported with format string msg."]
    pub ReportError: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut TfLiteContext, msg: *const ::std::os::raw::c_char, ...),
    >,
    #[doc = " Add `tensors_to_add` tensors, preserving pre-existing Tensor entries.  If\n non-null, the value pointed to by `first_new_tensor_index` will be set to\n the index of the first new tensor."]
    pub AddTensors: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut TfLiteContext,
            tensors_to_add: ::std::os::raw::c_int,
            first_new_tensor_index: *mut ::std::os::raw::c_int,
        ) -> TfLiteStatus,
    >,
    #[doc = " Get a Tensor node by node_index.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub GetNodeAndRegistration: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut TfLiteContext,
            node_index: ::std::os::raw::c_int,
            node: *mut *mut TfLiteNode,
            registration: *mut *mut TfLiteRegistration,
        ) -> TfLiteStatus,
    >,
    #[doc = " Replace ops with one or more stub delegate operations. This function\n does not take ownership of `nodes_to_replace`."]
    pub ReplaceNodeSubsetsWithDelegateKernels: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut TfLiteContext,
            registration: TfLiteRegistration,
            nodes_to_replace: *const TfLiteIntArray,
            delegate: *mut TfLiteDelegate,
        ) -> TfLiteStatus,
    >,
    #[doc = " Number of threads that are recommended to subsystems like gemmlowp and\n eigen."]
    pub recommended_num_threads: ::std::os::raw::c_int,
    #[doc = " Access external contexts by type.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub GetExternalContext: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut TfLiteContext,
            arg2: TfLiteExternalContextType,
        ) -> *mut TfLiteExternalContext,
    >,
    #[doc = " Set the value of a external context. Does not take ownership of the\n pointer.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub SetExternalContext: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut TfLiteContext,
            arg2: TfLiteExternalContextType,
            arg3: *mut TfLiteExternalContext,
        ),
    >,
    #[doc = " Flag for allowing float16 precision for FP32 calculation.\n default: false.\n\n WARNING: This is an experimental API and subject to change."]
    pub allow_fp32_relax_to_fp16: bool,
    #[doc = " Pointer to the op-level profiler, if set; nullptr otherwise."]
    pub profiler: *mut ::std::os::raw::c_void,
    #[doc = " Allocate persistent buffer which has the same life time as the\n interpreter. Returns `nullptr` on failure. The memory is allocated from\n heap for TFL, and from tail in TFLM. This method is only available in\n `Init` or `Prepare` stage.\n\n WARNING: This is an experimental interface that is subject\n to change."]
    pub AllocatePersistentBuffer: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut TfLiteContext, bytes: usize) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Allocate a buffer which will be deallocated right after invoke phase.\n The memory is allocated from heap in TFL, and from volatile arena in TFLM.\n This method is only available in invoke stage.\n\n NOTE: If possible use `RequestScratchBufferInArena` method to avoid memory\n allocation during inference time.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub AllocateBufferForEval: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut TfLiteContext,
            bytes: usize,
            ptr: *mut *mut ::std::os::raw::c_void,
        ) -> TfLiteStatus,
    >,
    #[doc = " Request a scratch buffer in the arena through static memory planning.\n This method is only available in `Prepare` stage and the buffer is\n allocated by the interpreter between Prepare and Eval stage. In `Eval`\n stage, `GetScratchBuffer` API can be used to fetch the address.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub RequestScratchBufferInArena: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut TfLiteContext,
            bytes: usize,
            buffer_idx: *mut ::std::os::raw::c_int,
        ) -> TfLiteStatus,
    >,
    #[doc = " Get the scratch buffer pointer.\n This method is only available in Eval stage.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub GetScratchBuffer: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut TfLiteContext,
            buffer_idx: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Resize the memory pointer of the `tensor`. This method behaves the same as\n `ResizeTensor`, except that it makes a copy of the shape array internally\n so the shape array could be deallocated right afterwards.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub ResizeTensorExplicit: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut TfLiteContext,
            tensor: *mut TfLiteTensor,
            dims: ::std::os::raw::c_int,
            shape: *const ::std::os::raw::c_int,
        ) -> TfLiteStatus,
    >,
    #[doc = " This method provides a preview of post-delegation partitioning. Each\n TfLiteDelegateParams in the referenced array corresponds to one instance\n of the delegate kernel. Example usage:\n\n     TfLiteIntArray* nodes_to_replace = ...;\n     TfLiteDelegateParams* params_array;\n     int num_partitions = 0;\n     TF_LITE_ENSURE_STATUS(context->PreviewDelegatePartitioning(\n        context, delegate, nodes_to_replace, &params_array,\n        &num_partitions));\n     for (int idx = 0; idx < num_partitions; idx++) {\n        const auto& partition_params = params_array[idx];\n        ...\n     }\n\n NOTE: The context owns the memory referenced by partition_params_array. It\n will be cleared with another call to PreviewDelegatePartitioning, or after\n TfLiteDelegateParams::Prepare returns.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub PreviewDelegatePartitioning: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            nodes_to_replace: *const TfLiteIntArray,
            partition_params_array: *mut *mut TfLiteDelegateParams,
            num_partitions: *mut ::std::os::raw::c_int,
        ) -> TfLiteStatus,
    >,
    #[doc = " Returns a TfLiteTensor struct for a given index.\n\n WARNING: This is an experimental interface that is subject to change.\n\n WARNING: This method may not be available on all platforms."]
    pub GetTensor: ::std::option::Option<
        unsafe extern "C" fn(
            context: *const TfLiteContext,
            tensor_idx: ::std::os::raw::c_int,
        ) -> *mut TfLiteTensor,
    >,
    #[doc = " Returns a TfLiteEvalTensor struct for a given index.\n\n WARNING: This is an experimental interface that is subject to change.\n\n WARNING: This method may not be available on all platforms."]
    pub GetEvalTensor: ::std::option::Option<
        unsafe extern "C" fn(
            context: *const TfLiteContext,
            tensor_idx: ::std::os::raw::c_int,
        ) -> *mut TfLiteEvalTensor,
    >,
    #[doc = " Retrieves named metadata buffer from the TFLite model.\n Returns kTfLiteOk if metadata is successfully obtained from the flatbuffer\n Model: that is, there exists a `metadata` entry with given `name` string.\n (see TFLite's schema.fbs).\n The corresponding `buffer` information is populated in `ptr` & `bytes`.\n The data from `ptr` is valid for the lifetime of the Interpreter.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub GetModelMetadata: ::std::option::Option<
        unsafe extern "C" fn(
            context: *const TfLiteContext,
            name: *const ::std::os::raw::c_char,
            ptr: *mut *const ::std::os::raw::c_char,
            bytes: *mut usize,
        ) -> TfLiteStatus,
    >,
    #[doc = " Retrieves the corresponding TfLiteContext of a subgraph that the given\n subgraph_index points to and switches to the delegate context for that\n subgraph. If an invalid subgraph index is given, returns kTfLiteError.\n\n NOTE: This function is expected to be paired with ReleaseSubgraphContext()\n once the delegate preparation is done and/or the delegate context\n functions are no longer needed.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub AcquireSubgraphContext: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            subgraph_index: ::std::os::raw::c_int,
            acquired_context: *mut *mut TfLiteContext,
        ) -> TfLiteStatus,
    >,
    #[doc = " Releases the subgraph context by switching back to the TFLite kernel\n context for the subgraph that the given subgraph_index points to.\n\n NOTE: This function is expected to be used after AcquireSubgraphContext()\n once the delegate preparation is done and/or the delegate context\n functions are no longer needed.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub ReleaseSubgraphContext: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            subgraph_index: ::std::os::raw::c_int,
        ) -> TfLiteStatus,
    >,
}
#[test]
fn bindgen_test_layout_TfLiteContext() {
    const UNINIT: ::std::mem::MaybeUninit<TfLiteContext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TfLiteContext>(),
        200usize,
        concat!("Size of: ", stringify!(TfLiteContext))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteContext>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tensors_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(tensors_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetExecutionPlan) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(GetExecutionPlan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tensors) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(tensors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResizeTensor) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(ResizeTensor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReportError) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(ReportError)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AddTensors) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(AddTensors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetNodeAndRegistration) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(GetNodeAndRegistration)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ReplaceNodeSubsetsWithDelegateKernels) as usize
                - ptr as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(ReplaceNodeSubsetsWithDelegateKernels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recommended_num_threads) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(recommended_num_threads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetExternalContext) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(GetExternalContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetExternalContext) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(SetExternalContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allow_fp32_relax_to_fp16) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(allow_fp32_relax_to_fp16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profiler) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(profiler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocatePersistentBuffer) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(AllocatePersistentBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocateBufferForEval) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(AllocateBufferForEval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RequestScratchBufferInArena) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(RequestScratchBufferInArena)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetScratchBuffer) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(GetScratchBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResizeTensorExplicit) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(ResizeTensorExplicit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PreviewDelegatePartitioning) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(PreviewDelegatePartitioning)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetTensor) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(GetTensor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetEvalTensor) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(GetEvalTensor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetModelMetadata) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(GetModelMetadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AcquireSubgraphContext) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(AcquireSubgraphContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseSubgraphContext) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(ReleaseSubgraphContext)
        )
    );
}
#[doc = " `TfLiteRegistration` defines the implementation of an operation\n (a built-in op, custom op, or custom delegate kernel).\n\n It is a struct containing \"methods\" (C function pointers) that will be\n invoked by the TF Lite runtime to evaluate instances of the operation.\n\n See also `TfLiteOperator` which is a more ABI-stable equivalent."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteRegistration {
    #[doc = " Initializes the op from serialized data.\n Called only *once* for the lifetime of the op, so any one-time allocations\n should be made here (unless they depend on tensor sizes).\n\n * If a built-in op:\n       * `buffer` is the op's params data (TfLiteLSTMParams*).\n       * `length` is zero.\n * If custom op:\n       * `buffer` is the op's `custom_options`.\n       * `length` is the size of the buffer.\n\n Returns a type-punned (i.e. void*) opaque data (e.g. a primitive pointer\n or an instance of a struct).\n\n The returned pointer will be stored with the node in the `user_data`\n field, accessible within prepare and invoke functions below.\n\n NOTE: if the data is already in the desired format, simply implement this\n function to return `nullptr` and implement the free function to be a\n no-op."]
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            buffer: *const ::std::os::raw::c_char,
            length: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " The pointer `buffer` is the data previously returned by an init\n invocation."]
    pub free: ::std::option::Option<
        unsafe extern "C" fn(context: *mut TfLiteContext, buffer: *mut ::std::os::raw::c_void),
    >,
    #[doc = " prepare is called when the inputs this node depends on have been resized.\n `context->ResizeTensor()` can be called to request output tensors to be\n resized.\n Can be called multiple times for the lifetime of the op.\n\n Returns `kTfLiteOk` on success."]
    pub prepare: ::std::option::Option<
        unsafe extern "C" fn(context: *mut TfLiteContext, node: *mut TfLiteNode) -> TfLiteStatus,
    >,
    #[doc = " Execute the node (should read `node->inputs` and output to\n `node->outputs`).\n\n Returns `kTfLiteOk` on success."]
    pub invoke: ::std::option::Option<
        unsafe extern "C" fn(context: *mut TfLiteContext, node: *mut TfLiteNode) -> TfLiteStatus,
    >,
    #[doc = " `profiling_string` is called during summarization of profiling information\n in order to group executions together. Providing a value here will cause a\n given op to appear multiple times is the profiling report. This is\n particularly useful for custom ops that can perform significantly\n different calculations depending on their `user-data`."]
    pub profiling_string: ::std::option::Option<
        unsafe extern "C" fn(
            context: *const TfLiteContext,
            node: *const TfLiteNode,
        ) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " Builtin codes. If this kernel refers to a builtin this is the code\n of the builtin. This is so we can do marshaling to other frameworks like\n NN API.\n\n Note: It is the responsibility of the registration binder to set this\n properly."]
    pub builtin_code: i32,
    #[doc = " Custom op name. If the op is a builtin, this will be `null`.\n\n Note: It is the responsibility of the registration binder to set this\n properly.\n\n WARNING: This is an experimental interface that is subject to change."]
    pub custom_name: *const ::std::os::raw::c_char,
    #[doc = " The version of the op.\n Note: It is the responsibility of the registration binder to set this\n properly."]
    pub version: ::std::os::raw::c_int,
    #[doc = " The external (i.e. ABI-stable) version of `TfLiteRegistration`.\n Since we can't use internal types (such as `TfLiteContext`) for C API to\n maintain ABI stability.  C API user will provide `TfLiteOperator` to\n implement custom ops.  We keep it inside of `TfLiteRegistration` and use\n it to route callbacks properly."]
    pub registration_external: *mut TfLiteOperator,
    #[doc = " Retrieves asynchronous kernel.\n\n If the `async_kernel` field is nullptr, it means the operation described\n by this TfLiteRegistration object does not support asynchronous execution.\n Otherwise, the function that the field points to should only be called for\n delegate kernel nodes, i.e. `node` should be a delegate kernel node\n created by applying a delegate. If the function returns nullptr, that\n means that the underlying delegate does not support asynchronous execution\n for this `node`."]
    pub async_kernel: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            node: *mut TfLiteNode,
        ) -> *mut TfLiteAsyncKernel,
    >,
    #[doc = " Indicates if an operator's output may safely overwrite its inputs.\n See the comments in `TfLiteInPlaceOp`."]
    pub inplace_operator: u64,
}
#[test]
fn bindgen_test_layout_TfLiteRegistration() {
    const UNINIT: ::std::mem::MaybeUninit<TfLiteRegistration> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TfLiteRegistration>(),
        88usize,
        concat!("Size of: ", stringify!(TfLiteRegistration))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteRegistration>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteRegistration))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prepare) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(prepare)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).invoke) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(invoke)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profiling_string) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(profiling_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).builtin_code) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(builtin_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_name) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(custom_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).registration_external) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(registration_external)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).async_kernel) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(async_kernel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inplace_operator) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(inplace_operator)
        )
    );
}
#[doc = " WARNING: This is an experimental interface that is subject to change."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteDelegate {
    #[doc = " Data that delegate needs to identify itself. This data is owned by the\n delegate. The delegate is owned in the user code, so the delegate is\n responsible for deallocating this when it is destroyed."]
    pub data_: *mut ::std::os::raw::c_void,
    #[doc = " Invoked by `ModifyGraphWithDelegate`. This prepare is called, giving the\n delegate a view of the current graph through `TfLiteContext*`. It\n typically will look at the nodes and call\n `ReplaceNodeSubsetsWithDelegateKernels()` to ask the TensorFlow lite\n runtime to create macro-nodes to represent delegated subgraphs of the\n original graph."]
    pub Prepare: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            delegate: *mut TfLiteDelegate,
        ) -> TfLiteStatus,
    >,
    #[doc = " Copy the data from delegate buffer handle into raw memory of the given\n `tensor`. Note that the delegate is allowed to allocate the raw bytes as\n long as it follows the rules for `kTfLiteDynamic` tensors, in which case\n this cannot be null."]
    pub CopyFromBufferHandle: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            delegate: *mut TfLiteDelegate,
            buffer_handle: TfLiteBufferHandle,
            tensor: *mut TfLiteTensor,
        ) -> TfLiteStatus,
    >,
    #[doc = " Copy the data from raw memory of the given `tensor` to delegate buffer\n handle. This can be null if the delegate doesn't use its own buffer."]
    pub CopyToBufferHandle: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            delegate: *mut TfLiteDelegate,
            buffer_handle: TfLiteBufferHandle,
            tensor: *mut TfLiteTensor,
        ) -> TfLiteStatus,
    >,
    #[doc = " Free the Delegate Buffer Handle. Note: This only frees the handle, but\n this doesn't release the underlying resource (e.g. textures). The\n resources are either owned by application layer or the delegate.\n This can be null if the delegate doesn't use its own buffer."]
    pub FreeBufferHandle: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            delegate: *mut TfLiteDelegate,
            handle: *mut TfLiteBufferHandle,
        ),
    >,
    #[doc = " Bitmask flags. See the comments in `TfLiteDelegateFlags`."]
    pub flags: i64,
    #[doc = " The opaque delegate builder associated with this object.  If set then the\n TF Lite runtime will give precedence to this field.  E.g. instead of\n invoking `Prepare` via the function pointer inside the `TfLiteDelegate`\n object, the runtime will first check if the corresponding function\n pointer inside `opaque_delegate_builder` is set and if so invoke that.\n\n If this field is non-null, then the `Prepare` field (of the\n `TfLiteDelegate`) should be null."]
    pub opaque_delegate_builder: *mut TfLiteOpaqueDelegateBuilder,
}
#[test]
fn bindgen_test_layout_TfLiteDelegate() {
    const UNINIT: ::std::mem::MaybeUninit<TfLiteDelegate> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TfLiteDelegate>(),
        56usize,
        concat!("Size of: ", stringify!(TfLiteDelegate))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteDelegate>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteDelegate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegate),
            "::",
            stringify!(data_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Prepare) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegate),
            "::",
            stringify!(Prepare)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CopyFromBufferHandle) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegate),
            "::",
            stringify!(CopyFromBufferHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CopyToBufferHandle) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegate),
            "::",
            stringify!(CopyToBufferHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FreeBufferHandle) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegate),
            "::",
            stringify!(FreeBufferHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegate),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque_delegate_builder) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegate),
            "::",
            stringify!(opaque_delegate_builder)
        )
    );
}
#[doc = " `TfLiteOpaqueDelegateBuilder` is used for constructing\n `TfLiteOpaqueDelegate`, see `TfLiteOpaqueDelegateCreate` in c_api_opaque.h.\n NOTE: This struct is not ABI stable.\n\n For forward source compatibility `TfLiteOpaqueDelegateBuilder` objects\n should be brace-initialized, so that all fields (including any that might be\n added in the future) get zero-initialized.  The purpose of each field is\n exactly the same as with `TfLiteDelegate`.\n\n NOTE: This type is part of the TensorFlow Lite Extension APIs.\n We reserve the right to make changes to this API in future releases,\n potentially including non-backwards-compatible changes, on a different\n schedule than for the other TensorFlow Lite APIs. See\n https://www.tensorflow.org/guide/versions#separate_version_number_for_tensorflow_lite_extension_apis."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteOpaqueDelegateBuilder {
    #[doc = " Data that delegate needs to identify itself. This data is owned by the\n delegate. The delegate is owned in the user code, so the delegate is\n responsible for deallocating this when it is destroyed."]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " Invoked by ModifyGraphWithDelegate. This prepare is called, giving the\n delegate a view of the current graph through `TfLiteContext*`. It\n typically will look at the nodes and call\n `ReplaceNodeSubsetsWithDelegateKernels()` to ask the TensorFlow lite\n runtime to create macro-nodes to represent delegated subgraphs of the\n original graph."]
    pub Prepare: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteOpaqueContext,
            delegate: *mut TfLiteOpaqueDelegate,
            data: *mut ::std::os::raw::c_void,
        ) -> TfLiteStatus,
    >,
    #[doc = " Copies the data from delegate buffer handle into raw memory of the given\n `tensor`. Note that the delegate is allowed to allocate the raw bytes as\n long as it follows the rules for kTfLiteDynamic tensors, in which case\n this cannot be null."]
    pub CopyFromBufferHandle: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteOpaqueContext,
            delegate: *mut TfLiteOpaqueDelegate,
            data: *mut ::std::os::raw::c_void,
            buffer_handle: TfLiteBufferHandle,
            tensor: *mut TfLiteOpaqueTensor,
        ) -> TfLiteStatus,
    >,
    #[doc = " Copies the data from raw memory of the given `tensor` to delegate buffer\n handle. This can be null if the delegate doesn't use its own buffer."]
    pub CopyToBufferHandle: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteOpaqueContext,
            delegate: *mut TfLiteOpaqueDelegate,
            data: *mut ::std::os::raw::c_void,
            buffer_handle: TfLiteBufferHandle,
            tensor: *mut TfLiteOpaqueTensor,
        ) -> TfLiteStatus,
    >,
    #[doc = " Frees the Delegate Buffer Handle. Note: This only frees the handle, but\n this doesn't release the underlying resource (e.g. textures). The\n resources are either owned by application layer or the delegate.\n This can be null if the delegate doesn't use its own buffer."]
    pub FreeBufferHandle: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteOpaqueContext,
            delegate: *mut TfLiteOpaqueDelegate,
            data: *mut ::std::os::raw::c_void,
            handle: *mut TfLiteBufferHandle,
        ),
    >,
    #[doc = " Bitmask flags. See the comments in `TfLiteDelegateFlags`."]
    pub flags: i64,
}
#[test]
fn bindgen_test_layout_TfLiteOpaqueDelegateBuilder() {
    const UNINIT: ::std::mem::MaybeUninit<TfLiteOpaqueDelegateBuilder> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TfLiteOpaqueDelegateBuilder>(),
        48usize,
        concat!("Size of: ", stringify!(TfLiteOpaqueDelegateBuilder))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteOpaqueDelegateBuilder>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteOpaqueDelegateBuilder))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteOpaqueDelegateBuilder),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Prepare) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteOpaqueDelegateBuilder),
            "::",
            stringify!(Prepare)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CopyFromBufferHandle) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteOpaqueDelegateBuilder),
            "::",
            stringify!(CopyFromBufferHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CopyToBufferHandle) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteOpaqueDelegateBuilder),
            "::",
            stringify!(CopyToBufferHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FreeBufferHandle) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteOpaqueDelegateBuilder),
            "::",
            stringify!(FreeBufferHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteOpaqueDelegateBuilder),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteOpaqueTensorBuilder {
    _unused: [u8; 0],
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
extern crate libloading;
pub struct tensorflowlite_c {
    __library: ::libloading::Library,
    pub TfLiteOperatorCreate: Result<
        unsafe extern "C" fn(
            builtin_code: TfLiteBuiltinOperator,
            custom_name: *const ::std::os::raw::c_char,
            version: ::std::os::raw::c_int,
            user_data: *mut ::std::os::raw::c_void,
        ) -> *mut TfLiteOperator,
        ::libloading::Error,
    >,
    pub TfLiteOperatorDelete:
        Result<unsafe extern "C" fn(registration: *mut TfLiteOperator), ::libloading::Error>,
    pub TfLiteOperatorGetBuiltInCode: Result<
        unsafe extern "C" fn(registration: *const TfLiteOperator) -> TfLiteBuiltinOperator,
        ::libloading::Error,
    >,
    pub TfLiteOperatorGetCustomName: Result<
        unsafe extern "C" fn(registration: *const TfLiteOperator) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub TfLiteOperatorGetVersion: Result<
        unsafe extern "C" fn(registration: *const TfLiteOperator) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub TfLiteOperatorGetUserData: Result<
        unsafe extern "C" fn(registration: *const TfLiteOperator) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub TfLiteOperatorSetInit: Result<
        unsafe extern "C" fn(
            registration: *mut TfLiteOperator,
            init: ::std::option::Option<
                unsafe extern "C" fn(
                    context: *mut TfLiteOpaqueContext,
                    buffer: *const ::std::os::raw::c_char,
                    length: usize,
                ) -> *mut ::std::os::raw::c_void,
            >,
        ),
        ::libloading::Error,
    >,
    pub TfLiteOperatorSetInitWithData: Result<
        unsafe extern "C" fn(
            registration: *mut TfLiteOperator,
            init: ::std::option::Option<
                unsafe extern "C" fn(
                    user_data: *mut ::std::os::raw::c_void,
                    context: *mut TfLiteOpaqueContext,
                    buffer: *const ::std::os::raw::c_char,
                    length: usize,
                ) -> *mut ::std::os::raw::c_void,
            >,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOperatorSetFree: Result<
        unsafe extern "C" fn(
            registration: *mut TfLiteOperator,
            free: ::std::option::Option<
                unsafe extern "C" fn(
                    context: *mut TfLiteOpaqueContext,
                    data: *mut ::std::os::raw::c_void,
                ),
            >,
        ),
        ::libloading::Error,
    >,
    pub TfLiteOperatorSetFreeWithData: Result<
        unsafe extern "C" fn(
            registration: *mut TfLiteOperator,
            free: ::std::option::Option<
                unsafe extern "C" fn(
                    user_data: *mut ::std::os::raw::c_void,
                    context: *mut TfLiteOpaqueContext,
                    data: *mut ::std::os::raw::c_void,
                ),
            >,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOperatorSetPrepare: Result<
        unsafe extern "C" fn(
            registration: *mut TfLiteOperator,
            prepare: ::std::option::Option<
                unsafe extern "C" fn(
                    context: *mut TfLiteOpaqueContext,
                    node: *mut TfLiteOpaqueNode,
                ) -> TfLiteStatus,
            >,
        ),
        ::libloading::Error,
    >,
    pub TfLiteOperatorSetPrepareWithData: Result<
        unsafe extern "C" fn(
            registration: *mut TfLiteOperator,
            prepare: ::std::option::Option<
                unsafe extern "C" fn(
                    user_data: *mut ::std::os::raw::c_void,
                    context: *mut TfLiteOpaqueContext,
                    node: *mut TfLiteOpaqueNode,
                ) -> TfLiteStatus,
            >,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOperatorSetInvoke: Result<
        unsafe extern "C" fn(
            registration: *mut TfLiteOperator,
            invoke: ::std::option::Option<
                unsafe extern "C" fn(
                    context: *mut TfLiteOpaqueContext,
                    node: *mut TfLiteOpaqueNode,
                ) -> TfLiteStatus,
            >,
        ),
        ::libloading::Error,
    >,
    pub TfLiteOperatorSetInvokeWithData: Result<
        unsafe extern "C" fn(
            registration: *mut TfLiteOperator,
            invoke: ::std::option::Option<
                unsafe extern "C" fn(
                    user_data: *mut ::std::os::raw::c_void,
                    context: *mut TfLiteOpaqueContext,
                    node: *mut TfLiteOpaqueNode,
                ) -> TfLiteStatus,
            >,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOperatorSetAsyncKernel: Result<
        unsafe extern "C" fn(
            registration: *mut TfLiteOperator,
            async_kernel: ::std::option::Option<
                unsafe extern "C" fn(
                    context: *mut TfLiteOpaqueContext,
                    node: *mut TfLiteOpaqueNode,
                ) -> *mut TfLiteAsyncKernel,
            >,
        ),
        ::libloading::Error,
    >,
    pub TfLiteOperatorSetAsyncKernelWithData: Result<
        unsafe extern "C" fn(
            registration: *mut TfLiteOperator,
            async_kernel: ::std::option::Option<
                unsafe extern "C" fn(
                    user_data: *mut ::std::os::raw::c_void,
                    context: *mut TfLiteOpaqueContext,
                    node: *mut TfLiteOpaqueNode,
                ) -> *mut TfLiteAsyncKernel,
            >,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOperatorSetInplaceOperator: Result<
        unsafe extern "C" fn(registration: *mut TfLiteOperator, inplace_operator: u64),
        ::libloading::Error,
    >,
    pub TfLiteVersion:
        Result<unsafe extern "C" fn() -> *const ::std::os::raw::c_char, ::libloading::Error>,
    pub TfLiteExtensionApisVersion:
        Result<unsafe extern "C" fn() -> *const ::std::os::raw::c_char, ::libloading::Error>,
    pub TfLiteSchemaVersion:
        Result<unsafe extern "C" fn() -> ::std::os::raw::c_int, ::libloading::Error>,
    pub TfLiteModelCreate: Result<
        unsafe extern "C" fn(
            model_data: *const ::std::os::raw::c_void,
            model_size: usize,
        ) -> *mut TfLiteModel,
        ::libloading::Error,
    >,
    pub TfLiteModelCreateWithErrorReporter: Result<
        unsafe extern "C" fn(
            model_data: *const ::std::os::raw::c_void,
            model_size: usize,
            reporter: ::std::option::Option<
                unsafe extern "C" fn(
                    user_data: *mut ::std::os::raw::c_void,
                    format: *const ::std::os::raw::c_char,
                    args: *mut __va_list_tag,
                ),
            >,
            user_data: *mut ::std::os::raw::c_void,
        ) -> *mut TfLiteModel,
        ::libloading::Error,
    >,
    pub TfLiteModelCreateFromFile: Result<
        unsafe extern "C" fn(model_path: *const ::std::os::raw::c_char) -> *mut TfLiteModel,
        ::libloading::Error,
    >,
    pub TfLiteModelCreateFromFileWithErrorReporter: Result<
        unsafe extern "C" fn(
            model_path: *const ::std::os::raw::c_char,
            reporter: ::std::option::Option<
                unsafe extern "C" fn(
                    user_data: *mut ::std::os::raw::c_void,
                    format: *const ::std::os::raw::c_char,
                    args: *mut __va_list_tag,
                ),
            >,
            user_data: *mut ::std::os::raw::c_void,
        ) -> *mut TfLiteModel,
        ::libloading::Error,
    >,
    pub TfLiteModelDelete:
        Result<unsafe extern "C" fn(model: *mut TfLiteModel), ::libloading::Error>,
    pub TfLiteInterpreterOptionsCreate:
        Result<unsafe extern "C" fn() -> *mut TfLiteInterpreterOptions, ::libloading::Error>,
    pub TfLiteInterpreterOptionsCopy: Result<
        unsafe extern "C" fn(
            from: *const TfLiteInterpreterOptions,
        ) -> *mut TfLiteInterpreterOptions,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterOptionsDelete:
        Result<unsafe extern "C" fn(options: *mut TfLiteInterpreterOptions), ::libloading::Error>,
    pub TfLiteInterpreterOptionsSetNumThreads: Result<
        unsafe extern "C" fn(options: *mut TfLiteInterpreterOptions, num_threads: i32),
        ::libloading::Error,
    >,
    pub TfLiteInterpreterOptionsAddDelegate: Result<
        unsafe extern "C" fn(
            options: *mut TfLiteInterpreterOptions,
            delegate: *mut TfLiteOpaqueDelegate,
        ),
        ::libloading::Error,
    >,
    pub TfLiteInterpreterOptionsSetErrorReporter: Result<
        unsafe extern "C" fn(
            options: *mut TfLiteInterpreterOptions,
            reporter: ::std::option::Option<
                unsafe extern "C" fn(
                    user_data: *mut ::std::os::raw::c_void,
                    format: *const ::std::os::raw::c_char,
                    args: *mut __va_list_tag,
                ),
            >,
            user_data: *mut ::std::os::raw::c_void,
        ),
        ::libloading::Error,
    >,
    pub TfLiteInterpreterOptionsAddOperator: Result<
        unsafe extern "C" fn(
            options: *mut TfLiteInterpreterOptions,
            registration: *mut TfLiteOperator,
        ),
        ::libloading::Error,
    >,
    pub TfLiteInterpreterOptionsEnableCancellation: Result<
        unsafe extern "C" fn(options: *mut TfLiteInterpreterOptions, enable: bool) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterCreate: Result<
        unsafe extern "C" fn(
            model: *const TfLiteModel,
            optional_options: *const TfLiteInterpreterOptions,
        ) -> *mut TfLiteInterpreter,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterDelete:
        Result<unsafe extern "C" fn(interpreter: *mut TfLiteInterpreter), ::libloading::Error>,
    pub TfLiteInterpreterGetInputTensorCount: Result<
        unsafe extern "C" fn(interpreter: *const TfLiteInterpreter) -> i32,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterInputTensorIndices: Result<
        unsafe extern "C" fn(interpreter: *const TfLiteInterpreter) -> *const ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterGetInputTensor: Result<
        unsafe extern "C" fn(
            interpreter: *const TfLiteInterpreter,
            input_index: i32,
        ) -> *mut TfLiteTensor,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterResizeInputTensor: Result<
        unsafe extern "C" fn(
            interpreter: *mut TfLiteInterpreter,
            input_index: i32,
            input_dims: *const ::std::os::raw::c_int,
            input_dims_size: i32,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterAllocateTensors: Result<
        unsafe extern "C" fn(interpreter: *mut TfLiteInterpreter) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterInvoke: Result<
        unsafe extern "C" fn(interpreter: *mut TfLiteInterpreter) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterGetOutputTensorCount: Result<
        unsafe extern "C" fn(interpreter: *const TfLiteInterpreter) -> i32,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterOutputTensorIndices: Result<
        unsafe extern "C" fn(interpreter: *const TfLiteInterpreter) -> *const ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterGetOutputTensor: Result<
        unsafe extern "C" fn(
            interpreter: *const TfLiteInterpreter,
            output_index: i32,
        ) -> *const TfLiteTensor,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterGetTensor: Result<
        unsafe extern "C" fn(
            interpreter: *const TfLiteInterpreter,
            index: ::std::os::raw::c_int,
        ) -> *mut TfLiteTensor,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterCancel: Result<
        unsafe extern "C" fn(interpreter: *const TfLiteInterpreter) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterGetSignatureCount: Result<
        unsafe extern "C" fn(interpreter: *const TfLiteInterpreter) -> i32,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterGetSignatureKey: Result<
        unsafe extern "C" fn(
            interpreter: *const TfLiteInterpreter,
            signature_index: i32,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterGetSignatureRunner: Result<
        unsafe extern "C" fn(
            interpreter: *const TfLiteInterpreter,
            signature_key: *const ::std::os::raw::c_char,
        ) -> *mut TfLiteSignatureRunner,
        ::libloading::Error,
    >,
    pub TfLiteSignatureRunnerGetInputCount: Result<
        unsafe extern "C" fn(signature_runner: *const TfLiteSignatureRunner) -> usize,
        ::libloading::Error,
    >,
    pub TfLiteSignatureRunnerGetInputName: Result<
        unsafe extern "C" fn(
            signature_runner: *const TfLiteSignatureRunner,
            input_index: i32,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub TfLiteSignatureRunnerResizeInputTensor: Result<
        unsafe extern "C" fn(
            signature_runner: *mut TfLiteSignatureRunner,
            input_name: *const ::std::os::raw::c_char,
            input_dims: *const ::std::os::raw::c_int,
            input_dims_size: i32,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteSignatureRunnerAllocateTensors: Result<
        unsafe extern "C" fn(signature_runner: *mut TfLiteSignatureRunner) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteSignatureRunnerGetInputTensor: Result<
        unsafe extern "C" fn(
            signature_runner: *mut TfLiteSignatureRunner,
            input_name: *const ::std::os::raw::c_char,
        ) -> *mut TfLiteTensor,
        ::libloading::Error,
    >,
    pub TfLiteSignatureRunnerInvoke: Result<
        unsafe extern "C" fn(signature_runner: *mut TfLiteSignatureRunner) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteSignatureRunnerGetOutputCount: Result<
        unsafe extern "C" fn(signature_runner: *const TfLiteSignatureRunner) -> usize,
        ::libloading::Error,
    >,
    pub TfLiteSignatureRunnerGetOutputName: Result<
        unsafe extern "C" fn(
            signature_runner: *const TfLiteSignatureRunner,
            output_index: i32,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub TfLiteSignatureRunnerGetOutputTensor: Result<
        unsafe extern "C" fn(
            signature_runner: *const TfLiteSignatureRunner,
            output_name: *const ::std::os::raw::c_char,
        ) -> *const TfLiteTensor,
        ::libloading::Error,
    >,
    pub TfLiteTensorType: Result<
        unsafe extern "C" fn(tensor: *const TfLiteTensor) -> TfLiteType,
        ::libloading::Error,
    >,
    pub TfLiteTensorNumDims:
        Result<unsafe extern "C" fn(tensor: *const TfLiteTensor) -> i32, ::libloading::Error>,
    pub TfLiteTensorDim: Result<
        unsafe extern "C" fn(tensor: *const TfLiteTensor, dim_index: i32) -> i32,
        ::libloading::Error,
    >,
    pub TfLiteTensorByteSize:
        Result<unsafe extern "C" fn(tensor: *const TfLiteTensor) -> usize, ::libloading::Error>,
    pub TfLiteTensorData: Result<
        unsafe extern "C" fn(tensor: *const TfLiteTensor) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub TfLiteTensorName: Result<
        unsafe extern "C" fn(tensor: *const TfLiteTensor) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub TfLiteTensorQuantizationParams: Result<
        unsafe extern "C" fn(tensor: *const TfLiteTensor) -> TfLiteQuantizationParams,
        ::libloading::Error,
    >,
    pub TfLiteTensorCopyFromBuffer: Result<
        unsafe extern "C" fn(
            tensor: *mut TfLiteTensor,
            input_data: *const ::std::os::raw::c_void,
            input_data_size: usize,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteTensorCopyToBuffer: Result<
        unsafe extern "C" fn(
            output_tensor: *const TfLiteTensor,
            output_data: *mut ::std::os::raw::c_void,
            output_data_size: usize,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteSignatureRunnerDelete: Result<
        unsafe extern "C" fn(signature_runner: *mut TfLiteSignatureRunner),
        ::libloading::Error,
    >,
    pub TfLiteIntArrayGetSizeInBytes:
        Result<unsafe extern "C" fn(size: ::std::os::raw::c_int) -> usize, ::libloading::Error>,
    pub TfLiteIntArrayCreate: Result<
        unsafe extern "C" fn(size: ::std::os::raw::c_int) -> *mut TfLiteIntArray,
        ::libloading::Error,
    >,
    pub TfLiteIntArrayEqual: Result<
        unsafe extern "C" fn(
            a: *const TfLiteIntArray,
            b: *const TfLiteIntArray,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub TfLiteIntArrayEqualsArray: Result<
        unsafe extern "C" fn(
            a: *const TfLiteIntArray,
            b_size: ::std::os::raw::c_int,
            b_data: *const ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub TfLiteIntArrayCopy: Result<
        unsafe extern "C" fn(src: *const TfLiteIntArray) -> *mut TfLiteIntArray,
        ::libloading::Error,
    >,
    pub TfLiteIntArrayFree:
        Result<unsafe extern "C" fn(a: *mut TfLiteIntArray), ::libloading::Error>,
    pub TfLiteFloatArrayGetSizeInBytes: Result<
        unsafe extern "C" fn(size: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub TfLiteFloatArrayCreate: Result<
        unsafe extern "C" fn(size: ::std::os::raw::c_int) -> *mut TfLiteFloatArray,
        ::libloading::Error,
    >,
    pub TfLiteFloatArrayCopy: Result<
        unsafe extern "C" fn(src: *const TfLiteFloatArray) -> *mut TfLiteFloatArray,
        ::libloading::Error,
    >,
    pub TfLiteFloatArrayFree:
        Result<unsafe extern "C" fn(a: *mut TfLiteFloatArray), ::libloading::Error>,
    pub TfLiteTypeGetName: Result<
        unsafe extern "C" fn(type_: TfLiteType) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub TfLiteTensorDataFree:
        Result<unsafe extern "C" fn(t: *mut TfLiteTensor), ::libloading::Error>,
    pub TfLiteQuantizationFree:
        Result<unsafe extern "C" fn(quantization: *mut TfLiteQuantization), ::libloading::Error>,
    pub TfLiteSparsityFree:
        Result<unsafe extern "C" fn(sparsity: *mut TfLiteSparsity), ::libloading::Error>,
    pub TfLiteTensorFree: Result<unsafe extern "C" fn(t: *mut TfLiteTensor), ::libloading::Error>,
    pub TfLiteTensorReset: Result<
        unsafe extern "C" fn(
            type_: TfLiteType,
            name: *const ::std::os::raw::c_char,
            dims: *mut TfLiteIntArray,
            quantization: TfLiteQuantizationParams,
            buffer: *mut ::std::os::raw::c_char,
            size: usize,
            allocation_type: TfLiteAllocationType,
            allocation: *const ::std::os::raw::c_void,
            is_variable: bool,
            tensor: *mut TfLiteTensor,
        ),
        ::libloading::Error,
    >,
    pub TfLiteTensorCopy: Result<
        unsafe extern "C" fn(src: *const TfLiteTensor, dst: *mut TfLiteTensor) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteTensorResizeMaybeCopy: Result<
        unsafe extern "C" fn(
            num_bytes: usize,
            tensor: *mut TfLiteTensor,
            preserve_data: bool,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteTensorRealloc: Result<
        unsafe extern "C" fn(num_bytes: usize, tensor: *mut TfLiteTensor) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteDelegateCreate: Result<unsafe extern "C" fn() -> TfLiteDelegate, ::libloading::Error>,
    pub TfLiteOpaqueDelegateCreate: Result<
        unsafe extern "C" fn(
            opaque_delegate_builder: *const TfLiteOpaqueDelegateBuilder,
        ) -> *mut TfLiteOpaqueDelegate,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueDelegateDelete:
        Result<unsafe extern "C" fn(delegate: *mut TfLiteOpaqueDelegate), ::libloading::Error>,
    pub TfLiteOpaqueDelegateGetData: Result<
        unsafe extern "C" fn(delegate: *const TfLiteOpaqueDelegate) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub TfLiteTensorGetAllocationStrategy: Result<
        unsafe extern "C" fn(t: *const TfLiteTensor) -> TfLiteAllocationStrategy,
        ::libloading::Error,
    >,
    pub TfLiteTensorGetBufferAddressStability: Result<
        unsafe extern "C" fn(t: *const TfLiteTensor) -> TfLiteRunStability,
        ::libloading::Error,
    >,
    pub TfLiteTensorGetDataStability: Result<
        unsafe extern "C" fn(t: *const TfLiteTensor) -> TfLiteRunStability,
        ::libloading::Error,
    >,
    pub TfLiteTensorGetDataKnownStep:
        Result<unsafe extern "C" fn(t: *const TfLiteTensor) -> TfLiteRunStep, ::libloading::Error>,
    pub TfLiteTensorGetShapeKnownStep:
        Result<unsafe extern "C" fn(t: *const TfLiteTensor) -> TfLiteRunStep, ::libloading::Error>,
    pub TfLiteOpaqueTensorType: Result<
        unsafe extern "C" fn(opaque_tensor: *const TfLiteOpaqueTensor) -> TfLiteType,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueTensorNumDims: Result<
        unsafe extern "C" fn(opaque_tensor: *const TfLiteOpaqueTensor) -> i32,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueTensorDim: Result<
        unsafe extern "C" fn(opaque_tensor: *const TfLiteOpaqueTensor, dim_index: i32) -> i32,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueTensorGetNumDimsSignature: Result<
        unsafe extern "C" fn(
            opaque_tensor: *const TfLiteOpaqueTensor,
            num_dims: *mut i32,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueTensorGetDimSignature: Result<
        unsafe extern "C" fn(
            opaque_tensor: *const TfLiteOpaqueTensor,
            dim_index: i32,
            dim_length: *mut i32,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueTensorIsVariable: Result<
        unsafe extern "C" fn(opaque_tensor: *const TfLiteOpaqueTensor) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueTensorByteSize: Result<
        unsafe extern "C" fn(opaque_tensor: *const TfLiteOpaqueTensor) -> usize,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueTensorData: Result<
        unsafe extern "C" fn(
            opaque_tensor: *const TfLiteOpaqueTensor,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueTensorGetAllocationType: Result<
        unsafe extern "C" fn(opaque_tensor: *const TfLiteOpaqueTensor) -> TfLiteAllocationType,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueTensorGetAllocationStrategy: Result<
        unsafe extern "C" fn(t: *const TfLiteOpaqueTensor) -> TfLiteAllocationStrategy,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueTensorGetBufferAddressStability: Result<
        unsafe extern "C" fn(t: *const TfLiteOpaqueTensor) -> TfLiteRunStability,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueTensorGetDataStability: Result<
        unsafe extern "C" fn(t: *const TfLiteOpaqueTensor) -> TfLiteRunStability,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueTensorGetDataKnownStep: Result<
        unsafe extern "C" fn(t: *const TfLiteOpaqueTensor) -> TfLiteRunStep,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueTensorGetShapeKnownStep: Result<
        unsafe extern "C" fn(t: *const TfLiteOpaqueTensor) -> TfLiteRunStep,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueTensorName: Result<
        unsafe extern "C" fn(
            opaque_tensor: *const TfLiteOpaqueTensor,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueTensorGetQuantization: Result<
        unsafe extern "C" fn(opaque_tensor: *const TfLiteOpaqueTensor) -> TfLiteQuantization,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueTensorGetQuantizationParams: Result<
        unsafe extern "C" fn(opaque_tensor: *const TfLiteOpaqueTensor) -> TfLiteQuantizationParams,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueTensorCopyFromBuffer: Result<
        unsafe extern "C" fn(
            opaque_tensor: *mut TfLiteOpaqueTensor,
            input_data: *const ::std::os::raw::c_void,
            input_data_size: usize,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueTensorCopyToBuffer: Result<
        unsafe extern "C" fn(
            opaque_tensor: *const TfLiteOpaqueTensor,
            output_data: *mut ::std::os::raw::c_void,
            output_data_size: usize,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueTensorGetStringCount: Result<
        unsafe extern "C" fn(tensor: *const TfLiteOpaqueTensor) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueTensorGetString: Result<
        unsafe extern "C" fn(
            tensor: *const TfLiteOpaqueTensor,
            index: ::std::os::raw::c_int,
            str_: *mut *const ::std::os::raw::c_char,
            len: *mut ::std::os::raw::c_int,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueTensorWriteStrings: Result<
        unsafe extern "C" fn(
            tensor: *mut TfLiteOpaqueTensor,
            str_array: *const *const ::std::os::raw::c_char,
            str_array_len: ::std::os::raw::c_int,
            str_n_len: *const ::std::os::raw::c_int,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueTensorWriteString: Result<
        unsafe extern "C" fn(
            tensor: *mut TfLiteOpaqueTensor,
            str_: *const ::std::os::raw::c_char,
            len: ::std::os::raw::c_int,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueTensorBuilderCreate:
        Result<unsafe extern "C" fn() -> *mut TfLiteOpaqueTensorBuilder, ::libloading::Error>,
    pub TfLiteOpaqueTensorBuilderDelete:
        Result<unsafe extern "C" fn(builder: *mut TfLiteOpaqueTensorBuilder), ::libloading::Error>,
    pub TfLiteOpaqueTensorBuilderSetType: Result<
        unsafe extern "C" fn(
            builder: *mut TfLiteOpaqueTensorBuilder,
            type_: TfLiteType,
        ) -> *mut TfLiteOpaqueTensorBuilder,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueTensorBuilderSetData: Result<
        unsafe extern "C" fn(
            builder: *mut TfLiteOpaqueTensorBuilder,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut TfLiteOpaqueTensorBuilder,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueTensorBuilderSetAllocationType: Result<
        unsafe extern "C" fn(
            builder: *mut TfLiteOpaqueTensorBuilder,
            allocation_type: TfLiteAllocationType,
        ) -> *mut TfLiteOpaqueTensorBuilder,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueTensorBuilderSetQuantizationParams: Result<
        unsafe extern "C" fn(
            builder: *mut TfLiteOpaqueTensorBuilder,
            params: TfLiteQuantizationParams,
        ) -> *mut TfLiteOpaqueTensorBuilder,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueTensorBuilderSetQuantization: Result<
        unsafe extern "C" fn(
            builder: *mut TfLiteOpaqueTensorBuilder,
            quantization: TfLiteQuantization,
        ) -> *mut TfLiteOpaqueTensorBuilder,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueTensorSetAllocationTypeToDynamic:
        Result<unsafe extern "C" fn(tensor: *mut TfLiteOpaqueTensor), ::libloading::Error>,
    pub TfLiteOpaqueNodeGetInput: Result<
        unsafe extern "C" fn(
            opaque_context: *const TfLiteOpaqueContext,
            opaque_node: *const TfLiteOpaqueNode,
            index: ::std::os::raw::c_int,
        ) -> *const TfLiteOpaqueTensor,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueNodeGetOutput: Result<
        unsafe extern "C" fn(
            opaque_context: *mut TfLiteOpaqueContext,
            opaque_node: *const TfLiteOpaqueNode,
            index: ::std::os::raw::c_int,
        ) -> *mut TfLiteOpaqueTensor,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueNodeNumberOfInputs: Result<
        unsafe extern "C" fn(opaque_node: *const TfLiteOpaqueNode) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueNodeNumberOfOutputs: Result<
        unsafe extern "C" fn(opaque_node: *const TfLiteOpaqueNode) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueNodeGetUserData: Result<
        unsafe extern "C" fn(opaque_node: *const TfLiteOpaqueNode) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueNodeGetBuiltinData: Result<
        unsafe extern "C" fn(opaque_node: *const TfLiteOpaqueNode) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueNodeGetCustomInitialData: Result<
        unsafe extern "C" fn(
            opaque_node: *const TfLiteOpaqueNode,
            init_data: *mut *const ::std::os::raw::c_void,
            size: *mut ::std::os::raw::c_int,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueNodeInputs: Result<
        unsafe extern "C" fn(
            opaque_node: *const TfLiteOpaqueNode,
            inputs: *mut *const ::std::os::raw::c_int,
            num_inputs: *mut ::std::os::raw::c_int,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueNodeOutputs: Result<
        unsafe extern "C" fn(
            opaque_node: *const TfLiteOpaqueNode,
            outputs: *mut *const ::std::os::raw::c_int,
            num_outputs: *mut ::std::os::raw::c_int,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueNodeSetTemporaries: Result<
        unsafe extern "C" fn(
            opaque_node: *mut TfLiteOpaqueNode,
            temporaries: *const ::std::os::raw::c_int,
            num_temporaries: ::std::os::raw::c_int,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueNodeTemporaries: Result<
        unsafe extern "C" fn(
            opaque_node: *const TfLiteOpaqueNode,
            temporaries: *mut *const ::std::os::raw::c_int,
            num_temporaries: *mut ::std::os::raw::c_int,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueNodeGetInputTensorIndex: Result<
        unsafe extern "C" fn(
            opaque_node: *const TfLiteOpaqueNode,
            index_of_input: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueNodeGetOutputTensorIndex: Result<
        unsafe extern "C" fn(
            opaque_node: *const TfLiteOpaqueNode,
            index_of_output: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueContextGetExecutionPlan: Result<
        unsafe extern "C" fn(
            opaque_context: *mut TfLiteOpaqueContext,
            execution_plan: *mut *mut TfLiteIntArray,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueContextGetExternalContext: Result<
        unsafe extern "C" fn(
            opaque_context: *mut TfLiteOpaqueContext,
            external_context: *mut *mut ::std::os::raw::c_void,
            type_: TfLiteExternalContextType,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueContextGetNodeAndRegistration: Result<
        unsafe extern "C" fn(
            opaque_context: *mut TfLiteOpaqueContext,
            node_index: ::std::os::raw::c_int,
            node: *mut *mut TfLiteOpaqueNode,
            registration_external: *mut *mut TfLiteOperator,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueContextReplaceNodeSubsetsWithDelegateKernels: Result<
        unsafe extern "C" fn(
            opaque_context: *mut TfLiteOpaqueContext,
            registration_external: *mut TfLiteOperator,
            nodes_to_replace: *const TfLiteIntArray,
            opaque_delegate: *mut TfLiteOpaqueDelegate,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueContextGetOpaqueTensor: Result<
        unsafe extern "C" fn(
            opaque_context: *const TfLiteOpaqueContext,
            index: ::std::os::raw::c_int,
        ) -> *mut TfLiteOpaqueTensor,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueContextGetInputs: Result<
        unsafe extern "C" fn(
            opaque_context: *const TfLiteOpaqueContext,
            inputs: *mut *const ::std::os::raw::c_int,
            num_inputs: *mut ::std::os::raw::c_int,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueContextGetOutputs: Result<
        unsafe extern "C" fn(
            opaque_context: *const TfLiteOpaqueContext,
            outputs: *mut *const ::std::os::raw::c_int,
            num_outputs: *mut ::std::os::raw::c_int,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueContextGetVariables: Result<
        unsafe extern "C" fn(
            opaque_context: *const TfLiteOpaqueContext,
            variables: *mut *const ::std::os::raw::c_int,
            num_variables: *mut ::std::os::raw::c_int,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueContextGetNumNodes: Result<
        unsafe extern "C" fn(opaque_context: *const TfLiteOpaqueContext) -> usize,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueContextGetNumTensors: Result<
        unsafe extern "C" fn(opaque_context: *const TfLiteOpaqueContext) -> usize,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueContextGetName: Result<
        unsafe extern "C" fn(
            opaque_context: *const TfLiteOpaqueContext,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueContextResizeTensor: Result<
        unsafe extern "C" fn(
            context: *mut TfLiteOpaqueContext,
            tensor: *mut TfLiteOpaqueTensor,
            new_size: *mut TfLiteIntArray,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueContextAcquireSubgraphContext: Result<
        unsafe extern "C" fn(
            opaque_context: *mut TfLiteOpaqueContext,
            subgraph_index: ::std::os::raw::c_int,
            acquired_opaque_context: *mut *mut TfLiteOpaqueContext,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueContextReleaseSubgraphContext: Result<
        unsafe extern "C" fn(
            opaque_context: *mut TfLiteOpaqueContext,
            subgraph_index: ::std::os::raw::c_int,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueContextMarkSubgraphAsDelegationSkippable: Result<
        unsafe extern "C" fn(
            opaque_context: *mut TfLiteOpaqueContext,
            subgraph_index: ::std::os::raw::c_int,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueContextGetNodeInitDataMmapInfo: Result<
        unsafe extern "C" fn(
            context: *const TfLiteOpaqueContext,
            node: *const TfLiteOpaqueNode,
            fd: *mut ::std::os::raw::c_int,
            custom_initial_data_offset_in_file: *mut i64,
            custom_initial_data_size: *mut i64,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueContextAddTensor: Result<
        unsafe extern "C" fn(
            context: *mut TfLiteOpaqueContext,
            builder: *mut TfLiteOpaqueTensorBuilder,
            new_tensor_index: *mut ::std::os::raw::c_int,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueContextGetSizeOfType: Result<
        unsafe extern "C" fn(
            context: *mut TfLiteOpaqueContext,
            type_: TfLiteType,
            bytes: *mut usize,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueContextGetMetadata: Result<
        unsafe extern "C" fn(
            context: *mut TfLiteOpaqueContext,
            name: *const ::std::os::raw::c_char,
            ptr: *mut *const ::std::os::raw::c_char,
            bytes: *mut usize,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOpaqueContextReportError: Result<
        unsafe extern "C" fn(
            opaque_context: *mut TfLiteOpaqueContext,
            format: *const ::std::os::raw::c_char,
            ...
        ),
        ::libloading::Error,
    >,
    pub TfLiteOpaqueContextReportErrorVa: Result<
        unsafe extern "C" fn(
            opaque_context: *mut TfLiteOpaqueContext,
            format: *const ::std::os::raw::c_char,
            vlist: *mut __va_list_tag,
        ),
        ::libloading::Error,
    >,
}
impl tensorflowlite_c {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let TfLiteOperatorCreate = __library.get(b"TfLiteOperatorCreate\0").map(|sym| *sym);
        let TfLiteOperatorDelete = __library.get(b"TfLiteOperatorDelete\0").map(|sym| *sym);
        let TfLiteOperatorGetBuiltInCode = __library
            .get(b"TfLiteOperatorGetBuiltInCode\0")
            .map(|sym| *sym);
        let TfLiteOperatorGetCustomName = __library
            .get(b"TfLiteOperatorGetCustomName\0")
            .map(|sym| *sym);
        let TfLiteOperatorGetVersion = __library.get(b"TfLiteOperatorGetVersion\0").map(|sym| *sym);
        let TfLiteOperatorGetUserData = __library
            .get(b"TfLiteOperatorGetUserData\0")
            .map(|sym| *sym);
        let TfLiteOperatorSetInit = __library.get(b"TfLiteOperatorSetInit\0").map(|sym| *sym);
        let TfLiteOperatorSetInitWithData = __library
            .get(b"TfLiteOperatorSetInitWithData\0")
            .map(|sym| *sym);
        let TfLiteOperatorSetFree = __library.get(b"TfLiteOperatorSetFree\0").map(|sym| *sym);
        let TfLiteOperatorSetFreeWithData = __library
            .get(b"TfLiteOperatorSetFreeWithData\0")
            .map(|sym| *sym);
        let TfLiteOperatorSetPrepare = __library.get(b"TfLiteOperatorSetPrepare\0").map(|sym| *sym);
        let TfLiteOperatorSetPrepareWithData = __library
            .get(b"TfLiteOperatorSetPrepareWithData\0")
            .map(|sym| *sym);
        let TfLiteOperatorSetInvoke = __library.get(b"TfLiteOperatorSetInvoke\0").map(|sym| *sym);
        let TfLiteOperatorSetInvokeWithData = __library
            .get(b"TfLiteOperatorSetInvokeWithData\0")
            .map(|sym| *sym);
        let TfLiteOperatorSetAsyncKernel = __library
            .get(b"TfLiteOperatorSetAsyncKernel\0")
            .map(|sym| *sym);
        let TfLiteOperatorSetAsyncKernelWithData = __library
            .get(b"TfLiteOperatorSetAsyncKernelWithData\0")
            .map(|sym| *sym);
        let TfLiteOperatorSetInplaceOperator = __library
            .get(b"TfLiteOperatorSetInplaceOperator\0")
            .map(|sym| *sym);
        let TfLiteVersion = __library.get(b"TfLiteVersion\0").map(|sym| *sym);
        let TfLiteExtensionApisVersion = __library
            .get(b"TfLiteExtensionApisVersion\0")
            .map(|sym| *sym);
        let TfLiteSchemaVersion = __library.get(b"TfLiteSchemaVersion\0").map(|sym| *sym);
        let TfLiteModelCreate = __library.get(b"TfLiteModelCreate\0").map(|sym| *sym);
        let TfLiteModelCreateWithErrorReporter = __library
            .get(b"TfLiteModelCreateWithErrorReporter\0")
            .map(|sym| *sym);
        let TfLiteModelCreateFromFile = __library
            .get(b"TfLiteModelCreateFromFile\0")
            .map(|sym| *sym);
        let TfLiteModelCreateFromFileWithErrorReporter = __library
            .get(b"TfLiteModelCreateFromFileWithErrorReporter\0")
            .map(|sym| *sym);
        let TfLiteModelDelete = __library.get(b"TfLiteModelDelete\0").map(|sym| *sym);
        let TfLiteInterpreterOptionsCreate = __library
            .get(b"TfLiteInterpreterOptionsCreate\0")
            .map(|sym| *sym);
        let TfLiteInterpreterOptionsCopy = __library
            .get(b"TfLiteInterpreterOptionsCopy\0")
            .map(|sym| *sym);
        let TfLiteInterpreterOptionsDelete = __library
            .get(b"TfLiteInterpreterOptionsDelete\0")
            .map(|sym| *sym);
        let TfLiteInterpreterOptionsSetNumThreads = __library
            .get(b"TfLiteInterpreterOptionsSetNumThreads\0")
            .map(|sym| *sym);
        let TfLiteInterpreterOptionsAddDelegate = __library
            .get(b"TfLiteInterpreterOptionsAddDelegate\0")
            .map(|sym| *sym);
        let TfLiteInterpreterOptionsSetErrorReporter = __library
            .get(b"TfLiteInterpreterOptionsSetErrorReporter\0")
            .map(|sym| *sym);
        let TfLiteInterpreterOptionsAddOperator = __library
            .get(b"TfLiteInterpreterOptionsAddOperator\0")
            .map(|sym| *sym);
        let TfLiteInterpreterOptionsEnableCancellation = __library
            .get(b"TfLiteInterpreterOptionsEnableCancellation\0")
            .map(|sym| *sym);
        let TfLiteInterpreterCreate = __library.get(b"TfLiteInterpreterCreate\0").map(|sym| *sym);
        let TfLiteInterpreterDelete = __library.get(b"TfLiteInterpreterDelete\0").map(|sym| *sym);
        let TfLiteInterpreterGetInputTensorCount = __library
            .get(b"TfLiteInterpreterGetInputTensorCount\0")
            .map(|sym| *sym);
        let TfLiteInterpreterInputTensorIndices = __library
            .get(b"TfLiteInterpreterInputTensorIndices\0")
            .map(|sym| *sym);
        let TfLiteInterpreterGetInputTensor = __library
            .get(b"TfLiteInterpreterGetInputTensor\0")
            .map(|sym| *sym);
        let TfLiteInterpreterResizeInputTensor = __library
            .get(b"TfLiteInterpreterResizeInputTensor\0")
            .map(|sym| *sym);
        let TfLiteInterpreterAllocateTensors = __library
            .get(b"TfLiteInterpreterAllocateTensors\0")
            .map(|sym| *sym);
        let TfLiteInterpreterInvoke = __library.get(b"TfLiteInterpreterInvoke\0").map(|sym| *sym);
        let TfLiteInterpreterGetOutputTensorCount = __library
            .get(b"TfLiteInterpreterGetOutputTensorCount\0")
            .map(|sym| *sym);
        let TfLiteInterpreterOutputTensorIndices = __library
            .get(b"TfLiteInterpreterOutputTensorIndices\0")
            .map(|sym| *sym);
        let TfLiteInterpreterGetOutputTensor = __library
            .get(b"TfLiteInterpreterGetOutputTensor\0")
            .map(|sym| *sym);
        let TfLiteInterpreterGetTensor = __library
            .get(b"TfLiteInterpreterGetTensor\0")
            .map(|sym| *sym);
        let TfLiteInterpreterCancel = __library.get(b"TfLiteInterpreterCancel\0").map(|sym| *sym);
        let TfLiteInterpreterGetSignatureCount = __library
            .get(b"TfLiteInterpreterGetSignatureCount\0")
            .map(|sym| *sym);
        let TfLiteInterpreterGetSignatureKey = __library
            .get(b"TfLiteInterpreterGetSignatureKey\0")
            .map(|sym| *sym);
        let TfLiteInterpreterGetSignatureRunner = __library
            .get(b"TfLiteInterpreterGetSignatureRunner\0")
            .map(|sym| *sym);
        let TfLiteSignatureRunnerGetInputCount = __library
            .get(b"TfLiteSignatureRunnerGetInputCount\0")
            .map(|sym| *sym);
        let TfLiteSignatureRunnerGetInputName = __library
            .get(b"TfLiteSignatureRunnerGetInputName\0")
            .map(|sym| *sym);
        let TfLiteSignatureRunnerResizeInputTensor = __library
            .get(b"TfLiteSignatureRunnerResizeInputTensor\0")
            .map(|sym| *sym);
        let TfLiteSignatureRunnerAllocateTensors = __library
            .get(b"TfLiteSignatureRunnerAllocateTensors\0")
            .map(|sym| *sym);
        let TfLiteSignatureRunnerGetInputTensor = __library
            .get(b"TfLiteSignatureRunnerGetInputTensor\0")
            .map(|sym| *sym);
        let TfLiteSignatureRunnerInvoke = __library
            .get(b"TfLiteSignatureRunnerInvoke\0")
            .map(|sym| *sym);
        let TfLiteSignatureRunnerGetOutputCount = __library
            .get(b"TfLiteSignatureRunnerGetOutputCount\0")
            .map(|sym| *sym);
        let TfLiteSignatureRunnerGetOutputName = __library
            .get(b"TfLiteSignatureRunnerGetOutputName\0")
            .map(|sym| *sym);
        let TfLiteSignatureRunnerGetOutputTensor = __library
            .get(b"TfLiteSignatureRunnerGetOutputTensor\0")
            .map(|sym| *sym);
        let TfLiteTensorType = __library.get(b"TfLiteTensorType\0").map(|sym| *sym);
        let TfLiteTensorNumDims = __library.get(b"TfLiteTensorNumDims\0").map(|sym| *sym);
        let TfLiteTensorDim = __library.get(b"TfLiteTensorDim\0").map(|sym| *sym);
        let TfLiteTensorByteSize = __library.get(b"TfLiteTensorByteSize\0").map(|sym| *sym);
        let TfLiteTensorData = __library.get(b"TfLiteTensorData\0").map(|sym| *sym);
        let TfLiteTensorName = __library.get(b"TfLiteTensorName\0").map(|sym| *sym);
        let TfLiteTensorQuantizationParams = __library
            .get(b"TfLiteTensorQuantizationParams\0")
            .map(|sym| *sym);
        let TfLiteTensorCopyFromBuffer = __library
            .get(b"TfLiteTensorCopyFromBuffer\0")
            .map(|sym| *sym);
        let TfLiteTensorCopyToBuffer = __library.get(b"TfLiteTensorCopyToBuffer\0").map(|sym| *sym);
        let TfLiteSignatureRunnerDelete = __library
            .get(b"TfLiteSignatureRunnerDelete\0")
            .map(|sym| *sym);
        let TfLiteIntArrayGetSizeInBytes = __library
            .get(b"TfLiteIntArrayGetSizeInBytes\0")
            .map(|sym| *sym);
        let TfLiteIntArrayCreate = __library.get(b"TfLiteIntArrayCreate\0").map(|sym| *sym);
        let TfLiteIntArrayEqual = __library.get(b"TfLiteIntArrayEqual\0").map(|sym| *sym);
        let TfLiteIntArrayEqualsArray = __library
            .get(b"TfLiteIntArrayEqualsArray\0")
            .map(|sym| *sym);
        let TfLiteIntArrayCopy = __library.get(b"TfLiteIntArrayCopy\0").map(|sym| *sym);
        let TfLiteIntArrayFree = __library.get(b"TfLiteIntArrayFree\0").map(|sym| *sym);
        let TfLiteFloatArrayGetSizeInBytes = __library
            .get(b"TfLiteFloatArrayGetSizeInBytes\0")
            .map(|sym| *sym);
        let TfLiteFloatArrayCreate = __library.get(b"TfLiteFloatArrayCreate\0").map(|sym| *sym);
        let TfLiteFloatArrayCopy = __library.get(b"TfLiteFloatArrayCopy\0").map(|sym| *sym);
        let TfLiteFloatArrayFree = __library.get(b"TfLiteFloatArrayFree\0").map(|sym| *sym);
        let TfLiteTypeGetName = __library.get(b"TfLiteTypeGetName\0").map(|sym| *sym);
        let TfLiteTensorDataFree = __library.get(b"TfLiteTensorDataFree\0").map(|sym| *sym);
        let TfLiteQuantizationFree = __library.get(b"TfLiteQuantizationFree\0").map(|sym| *sym);
        let TfLiteSparsityFree = __library.get(b"TfLiteSparsityFree\0").map(|sym| *sym);
        let TfLiteTensorFree = __library.get(b"TfLiteTensorFree\0").map(|sym| *sym);
        let TfLiteTensorReset = __library.get(b"TfLiteTensorReset\0").map(|sym| *sym);
        let TfLiteTensorCopy = __library.get(b"TfLiteTensorCopy\0").map(|sym| *sym);
        let TfLiteTensorResizeMaybeCopy = __library
            .get(b"TfLiteTensorResizeMaybeCopy\0")
            .map(|sym| *sym);
        let TfLiteTensorRealloc = __library.get(b"TfLiteTensorRealloc\0").map(|sym| *sym);
        let TfLiteDelegateCreate = __library.get(b"TfLiteDelegateCreate\0").map(|sym| *sym);
        let TfLiteOpaqueDelegateCreate = __library
            .get(b"TfLiteOpaqueDelegateCreate\0")
            .map(|sym| *sym);
        let TfLiteOpaqueDelegateDelete = __library
            .get(b"TfLiteOpaqueDelegateDelete\0")
            .map(|sym| *sym);
        let TfLiteOpaqueDelegateGetData = __library
            .get(b"TfLiteOpaqueDelegateGetData\0")
            .map(|sym| *sym);
        let TfLiteTensorGetAllocationStrategy = __library
            .get(b"TfLiteTensorGetAllocationStrategy\0")
            .map(|sym| *sym);
        let TfLiteTensorGetBufferAddressStability = __library
            .get(b"TfLiteTensorGetBufferAddressStability\0")
            .map(|sym| *sym);
        let TfLiteTensorGetDataStability = __library
            .get(b"TfLiteTensorGetDataStability\0")
            .map(|sym| *sym);
        let TfLiteTensorGetDataKnownStep = __library
            .get(b"TfLiteTensorGetDataKnownStep\0")
            .map(|sym| *sym);
        let TfLiteTensorGetShapeKnownStep = __library
            .get(b"TfLiteTensorGetShapeKnownStep\0")
            .map(|sym| *sym);
        let TfLiteOpaqueTensorType = __library.get(b"TfLiteOpaqueTensorType\0").map(|sym| *sym);
        let TfLiteOpaqueTensorNumDims = __library
            .get(b"TfLiteOpaqueTensorNumDims\0")
            .map(|sym| *sym);
        let TfLiteOpaqueTensorDim = __library.get(b"TfLiteOpaqueTensorDim\0").map(|sym| *sym);
        let TfLiteOpaqueTensorGetNumDimsSignature = __library
            .get(b"TfLiteOpaqueTensorGetNumDimsSignature\0")
            .map(|sym| *sym);
        let TfLiteOpaqueTensorGetDimSignature = __library
            .get(b"TfLiteOpaqueTensorGetDimSignature\0")
            .map(|sym| *sym);
        let TfLiteOpaqueTensorIsVariable = __library
            .get(b"TfLiteOpaqueTensorIsVariable\0")
            .map(|sym| *sym);
        let TfLiteOpaqueTensorByteSize = __library
            .get(b"TfLiteOpaqueTensorByteSize\0")
            .map(|sym| *sym);
        let TfLiteOpaqueTensorData = __library.get(b"TfLiteOpaqueTensorData\0").map(|sym| *sym);
        let TfLiteOpaqueTensorGetAllocationType = __library
            .get(b"TfLiteOpaqueTensorGetAllocationType\0")
            .map(|sym| *sym);
        let TfLiteOpaqueTensorGetAllocationStrategy = __library
            .get(b"TfLiteOpaqueTensorGetAllocationStrategy\0")
            .map(|sym| *sym);
        let TfLiteOpaqueTensorGetBufferAddressStability = __library
            .get(b"TfLiteOpaqueTensorGetBufferAddressStability\0")
            .map(|sym| *sym);
        let TfLiteOpaqueTensorGetDataStability = __library
            .get(b"TfLiteOpaqueTensorGetDataStability\0")
            .map(|sym| *sym);
        let TfLiteOpaqueTensorGetDataKnownStep = __library
            .get(b"TfLiteOpaqueTensorGetDataKnownStep\0")
            .map(|sym| *sym);
        let TfLiteOpaqueTensorGetShapeKnownStep = __library
            .get(b"TfLiteOpaqueTensorGetShapeKnownStep\0")
            .map(|sym| *sym);
        let TfLiteOpaqueTensorName = __library.get(b"TfLiteOpaqueTensorName\0").map(|sym| *sym);
        let TfLiteOpaqueTensorGetQuantization = __library
            .get(b"TfLiteOpaqueTensorGetQuantization\0")
            .map(|sym| *sym);
        let TfLiteOpaqueTensorGetQuantizationParams = __library
            .get(b"TfLiteOpaqueTensorGetQuantizationParams\0")
            .map(|sym| *sym);
        let TfLiteOpaqueTensorCopyFromBuffer = __library
            .get(b"TfLiteOpaqueTensorCopyFromBuffer\0")
            .map(|sym| *sym);
        let TfLiteOpaqueTensorCopyToBuffer = __library
            .get(b"TfLiteOpaqueTensorCopyToBuffer\0")
            .map(|sym| *sym);
        let TfLiteOpaqueTensorGetStringCount = __library
            .get(b"TfLiteOpaqueTensorGetStringCount\0")
            .map(|sym| *sym);
        let TfLiteOpaqueTensorGetString = __library
            .get(b"TfLiteOpaqueTensorGetString\0")
            .map(|sym| *sym);
        let TfLiteOpaqueTensorWriteStrings = __library
            .get(b"TfLiteOpaqueTensorWriteStrings\0")
            .map(|sym| *sym);
        let TfLiteOpaqueTensorWriteString = __library
            .get(b"TfLiteOpaqueTensorWriteString\0")
            .map(|sym| *sym);
        let TfLiteOpaqueTensorBuilderCreate = __library
            .get(b"TfLiteOpaqueTensorBuilderCreate\0")
            .map(|sym| *sym);
        let TfLiteOpaqueTensorBuilderDelete = __library
            .get(b"TfLiteOpaqueTensorBuilderDelete\0")
            .map(|sym| *sym);
        let TfLiteOpaqueTensorBuilderSetType = __library
            .get(b"TfLiteOpaqueTensorBuilderSetType\0")
            .map(|sym| *sym);
        let TfLiteOpaqueTensorBuilderSetData = __library
            .get(b"TfLiteOpaqueTensorBuilderSetData\0")
            .map(|sym| *sym);
        let TfLiteOpaqueTensorBuilderSetAllocationType = __library
            .get(b"TfLiteOpaqueTensorBuilderSetAllocationType\0")
            .map(|sym| *sym);
        let TfLiteOpaqueTensorBuilderSetQuantizationParams = __library
            .get(b"TfLiteOpaqueTensorBuilderSetQuantizationParams\0")
            .map(|sym| *sym);
        let TfLiteOpaqueTensorBuilderSetQuantization = __library
            .get(b"TfLiteOpaqueTensorBuilderSetQuantization\0")
            .map(|sym| *sym);
        let TfLiteOpaqueTensorSetAllocationTypeToDynamic = __library
            .get(b"TfLiteOpaqueTensorSetAllocationTypeToDynamic\0")
            .map(|sym| *sym);
        let TfLiteOpaqueNodeGetInput = __library.get(b"TfLiteOpaqueNodeGetInput\0").map(|sym| *sym);
        let TfLiteOpaqueNodeGetOutput = __library
            .get(b"TfLiteOpaqueNodeGetOutput\0")
            .map(|sym| *sym);
        let TfLiteOpaqueNodeNumberOfInputs = __library
            .get(b"TfLiteOpaqueNodeNumberOfInputs\0")
            .map(|sym| *sym);
        let TfLiteOpaqueNodeNumberOfOutputs = __library
            .get(b"TfLiteOpaqueNodeNumberOfOutputs\0")
            .map(|sym| *sym);
        let TfLiteOpaqueNodeGetUserData = __library
            .get(b"TfLiteOpaqueNodeGetUserData\0")
            .map(|sym| *sym);
        let TfLiteOpaqueNodeGetBuiltinData = __library
            .get(b"TfLiteOpaqueNodeGetBuiltinData\0")
            .map(|sym| *sym);
        let TfLiteOpaqueNodeGetCustomInitialData = __library
            .get(b"TfLiteOpaqueNodeGetCustomInitialData\0")
            .map(|sym| *sym);
        let TfLiteOpaqueNodeInputs = __library.get(b"TfLiteOpaqueNodeInputs\0").map(|sym| *sym);
        let TfLiteOpaqueNodeOutputs = __library.get(b"TfLiteOpaqueNodeOutputs\0").map(|sym| *sym);
        let TfLiteOpaqueNodeSetTemporaries = __library
            .get(b"TfLiteOpaqueNodeSetTemporaries\0")
            .map(|sym| *sym);
        let TfLiteOpaqueNodeTemporaries = __library
            .get(b"TfLiteOpaqueNodeTemporaries\0")
            .map(|sym| *sym);
        let TfLiteOpaqueNodeGetInputTensorIndex = __library
            .get(b"TfLiteOpaqueNodeGetInputTensorIndex\0")
            .map(|sym| *sym);
        let TfLiteOpaqueNodeGetOutputTensorIndex = __library
            .get(b"TfLiteOpaqueNodeGetOutputTensorIndex\0")
            .map(|sym| *sym);
        let TfLiteOpaqueContextGetExecutionPlan = __library
            .get(b"TfLiteOpaqueContextGetExecutionPlan\0")
            .map(|sym| *sym);
        let TfLiteOpaqueContextGetExternalContext = __library
            .get(b"TfLiteOpaqueContextGetExternalContext\0")
            .map(|sym| *sym);
        let TfLiteOpaqueContextGetNodeAndRegistration = __library
            .get(b"TfLiteOpaqueContextGetNodeAndRegistration\0")
            .map(|sym| *sym);
        let TfLiteOpaqueContextReplaceNodeSubsetsWithDelegateKernels = __library
            .get(b"TfLiteOpaqueContextReplaceNodeSubsetsWithDelegateKernels\0")
            .map(|sym| *sym);
        let TfLiteOpaqueContextGetOpaqueTensor = __library
            .get(b"TfLiteOpaqueContextGetOpaqueTensor\0")
            .map(|sym| *sym);
        let TfLiteOpaqueContextGetInputs = __library
            .get(b"TfLiteOpaqueContextGetInputs\0")
            .map(|sym| *sym);
        let TfLiteOpaqueContextGetOutputs = __library
            .get(b"TfLiteOpaqueContextGetOutputs\0")
            .map(|sym| *sym);
        let TfLiteOpaqueContextGetVariables = __library
            .get(b"TfLiteOpaqueContextGetVariables\0")
            .map(|sym| *sym);
        let TfLiteOpaqueContextGetNumNodes = __library
            .get(b"TfLiteOpaqueContextGetNumNodes\0")
            .map(|sym| *sym);
        let TfLiteOpaqueContextGetNumTensors = __library
            .get(b"TfLiteOpaqueContextGetNumTensors\0")
            .map(|sym| *sym);
        let TfLiteOpaqueContextGetName = __library
            .get(b"TfLiteOpaqueContextGetName\0")
            .map(|sym| *sym);
        let TfLiteOpaqueContextResizeTensor = __library
            .get(b"TfLiteOpaqueContextResizeTensor\0")
            .map(|sym| *sym);
        let TfLiteOpaqueContextAcquireSubgraphContext = __library
            .get(b"TfLiteOpaqueContextAcquireSubgraphContext\0")
            .map(|sym| *sym);
        let TfLiteOpaqueContextReleaseSubgraphContext = __library
            .get(b"TfLiteOpaqueContextReleaseSubgraphContext\0")
            .map(|sym| *sym);
        let TfLiteOpaqueContextMarkSubgraphAsDelegationSkippable = __library
            .get(b"TfLiteOpaqueContextMarkSubgraphAsDelegationSkippable\0")
            .map(|sym| *sym);
        let TfLiteOpaqueContextGetNodeInitDataMmapInfo = __library
            .get(b"TfLiteOpaqueContextGetNodeInitDataMmapInfo\0")
            .map(|sym| *sym);
        let TfLiteOpaqueContextAddTensor = __library
            .get(b"TfLiteOpaqueContextAddTensor\0")
            .map(|sym| *sym);
        let TfLiteOpaqueContextGetSizeOfType = __library
            .get(b"TfLiteOpaqueContextGetSizeOfType\0")
            .map(|sym| *sym);
        let TfLiteOpaqueContextGetMetadata = __library
            .get(b"TfLiteOpaqueContextGetMetadata\0")
            .map(|sym| *sym);
        let TfLiteOpaqueContextReportError = __library
            .get(b"TfLiteOpaqueContextReportError\0")
            .map(|sym| *sym);
        let TfLiteOpaqueContextReportErrorVa = __library
            .get(b"TfLiteOpaqueContextReportErrorVa\0")
            .map(|sym| *sym);
        Ok(tensorflowlite_c {
            __library,
            TfLiteOperatorCreate,
            TfLiteOperatorDelete,
            TfLiteOperatorGetBuiltInCode,
            TfLiteOperatorGetCustomName,
            TfLiteOperatorGetVersion,
            TfLiteOperatorGetUserData,
            TfLiteOperatorSetInit,
            TfLiteOperatorSetInitWithData,
            TfLiteOperatorSetFree,
            TfLiteOperatorSetFreeWithData,
            TfLiteOperatorSetPrepare,
            TfLiteOperatorSetPrepareWithData,
            TfLiteOperatorSetInvoke,
            TfLiteOperatorSetInvokeWithData,
            TfLiteOperatorSetAsyncKernel,
            TfLiteOperatorSetAsyncKernelWithData,
            TfLiteOperatorSetInplaceOperator,
            TfLiteVersion,
            TfLiteExtensionApisVersion,
            TfLiteSchemaVersion,
            TfLiteModelCreate,
            TfLiteModelCreateWithErrorReporter,
            TfLiteModelCreateFromFile,
            TfLiteModelCreateFromFileWithErrorReporter,
            TfLiteModelDelete,
            TfLiteInterpreterOptionsCreate,
            TfLiteInterpreterOptionsCopy,
            TfLiteInterpreterOptionsDelete,
            TfLiteInterpreterOptionsSetNumThreads,
            TfLiteInterpreterOptionsAddDelegate,
            TfLiteInterpreterOptionsSetErrorReporter,
            TfLiteInterpreterOptionsAddOperator,
            TfLiteInterpreterOptionsEnableCancellation,
            TfLiteInterpreterCreate,
            TfLiteInterpreterDelete,
            TfLiteInterpreterGetInputTensorCount,
            TfLiteInterpreterInputTensorIndices,
            TfLiteInterpreterGetInputTensor,
            TfLiteInterpreterResizeInputTensor,
            TfLiteInterpreterAllocateTensors,
            TfLiteInterpreterInvoke,
            TfLiteInterpreterGetOutputTensorCount,
            TfLiteInterpreterOutputTensorIndices,
            TfLiteInterpreterGetOutputTensor,
            TfLiteInterpreterGetTensor,
            TfLiteInterpreterCancel,
            TfLiteInterpreterGetSignatureCount,
            TfLiteInterpreterGetSignatureKey,
            TfLiteInterpreterGetSignatureRunner,
            TfLiteSignatureRunnerGetInputCount,
            TfLiteSignatureRunnerGetInputName,
            TfLiteSignatureRunnerResizeInputTensor,
            TfLiteSignatureRunnerAllocateTensors,
            TfLiteSignatureRunnerGetInputTensor,
            TfLiteSignatureRunnerInvoke,
            TfLiteSignatureRunnerGetOutputCount,
            TfLiteSignatureRunnerGetOutputName,
            TfLiteSignatureRunnerGetOutputTensor,
            TfLiteTensorType,
            TfLiteTensorNumDims,
            TfLiteTensorDim,
            TfLiteTensorByteSize,
            TfLiteTensorData,
            TfLiteTensorName,
            TfLiteTensorQuantizationParams,
            TfLiteTensorCopyFromBuffer,
            TfLiteTensorCopyToBuffer,
            TfLiteSignatureRunnerDelete,
            TfLiteIntArrayGetSizeInBytes,
            TfLiteIntArrayCreate,
            TfLiteIntArrayEqual,
            TfLiteIntArrayEqualsArray,
            TfLiteIntArrayCopy,
            TfLiteIntArrayFree,
            TfLiteFloatArrayGetSizeInBytes,
            TfLiteFloatArrayCreate,
            TfLiteFloatArrayCopy,
            TfLiteFloatArrayFree,
            TfLiteTypeGetName,
            TfLiteTensorDataFree,
            TfLiteQuantizationFree,
            TfLiteSparsityFree,
            TfLiteTensorFree,
            TfLiteTensorReset,
            TfLiteTensorCopy,
            TfLiteTensorResizeMaybeCopy,
            TfLiteTensorRealloc,
            TfLiteDelegateCreate,
            TfLiteOpaqueDelegateCreate,
            TfLiteOpaqueDelegateDelete,
            TfLiteOpaqueDelegateGetData,
            TfLiteTensorGetAllocationStrategy,
            TfLiteTensorGetBufferAddressStability,
            TfLiteTensorGetDataStability,
            TfLiteTensorGetDataKnownStep,
            TfLiteTensorGetShapeKnownStep,
            TfLiteOpaqueTensorType,
            TfLiteOpaqueTensorNumDims,
            TfLiteOpaqueTensorDim,
            TfLiteOpaqueTensorGetNumDimsSignature,
            TfLiteOpaqueTensorGetDimSignature,
            TfLiteOpaqueTensorIsVariable,
            TfLiteOpaqueTensorByteSize,
            TfLiteOpaqueTensorData,
            TfLiteOpaqueTensorGetAllocationType,
            TfLiteOpaqueTensorGetAllocationStrategy,
            TfLiteOpaqueTensorGetBufferAddressStability,
            TfLiteOpaqueTensorGetDataStability,
            TfLiteOpaqueTensorGetDataKnownStep,
            TfLiteOpaqueTensorGetShapeKnownStep,
            TfLiteOpaqueTensorName,
            TfLiteOpaqueTensorGetQuantization,
            TfLiteOpaqueTensorGetQuantizationParams,
            TfLiteOpaqueTensorCopyFromBuffer,
            TfLiteOpaqueTensorCopyToBuffer,
            TfLiteOpaqueTensorGetStringCount,
            TfLiteOpaqueTensorGetString,
            TfLiteOpaqueTensorWriteStrings,
            TfLiteOpaqueTensorWriteString,
            TfLiteOpaqueTensorBuilderCreate,
            TfLiteOpaqueTensorBuilderDelete,
            TfLiteOpaqueTensorBuilderSetType,
            TfLiteOpaqueTensorBuilderSetData,
            TfLiteOpaqueTensorBuilderSetAllocationType,
            TfLiteOpaqueTensorBuilderSetQuantizationParams,
            TfLiteOpaqueTensorBuilderSetQuantization,
            TfLiteOpaqueTensorSetAllocationTypeToDynamic,
            TfLiteOpaqueNodeGetInput,
            TfLiteOpaqueNodeGetOutput,
            TfLiteOpaqueNodeNumberOfInputs,
            TfLiteOpaqueNodeNumberOfOutputs,
            TfLiteOpaqueNodeGetUserData,
            TfLiteOpaqueNodeGetBuiltinData,
            TfLiteOpaqueNodeGetCustomInitialData,
            TfLiteOpaqueNodeInputs,
            TfLiteOpaqueNodeOutputs,
            TfLiteOpaqueNodeSetTemporaries,
            TfLiteOpaqueNodeTemporaries,
            TfLiteOpaqueNodeGetInputTensorIndex,
            TfLiteOpaqueNodeGetOutputTensorIndex,
            TfLiteOpaqueContextGetExecutionPlan,
            TfLiteOpaqueContextGetExternalContext,
            TfLiteOpaqueContextGetNodeAndRegistration,
            TfLiteOpaqueContextReplaceNodeSubsetsWithDelegateKernels,
            TfLiteOpaqueContextGetOpaqueTensor,
            TfLiteOpaqueContextGetInputs,
            TfLiteOpaqueContextGetOutputs,
            TfLiteOpaqueContextGetVariables,
            TfLiteOpaqueContextGetNumNodes,
            TfLiteOpaqueContextGetNumTensors,
            TfLiteOpaqueContextGetName,
            TfLiteOpaqueContextResizeTensor,
            TfLiteOpaqueContextAcquireSubgraphContext,
            TfLiteOpaqueContextReleaseSubgraphContext,
            TfLiteOpaqueContextMarkSubgraphAsDelegationSkippable,
            TfLiteOpaqueContextGetNodeInitDataMmapInfo,
            TfLiteOpaqueContextAddTensor,
            TfLiteOpaqueContextGetSizeOfType,
            TfLiteOpaqueContextGetMetadata,
            TfLiteOpaqueContextReportError,
            TfLiteOpaqueContextReportErrorVa,
        })
    }
    #[doc = " Returns a new TfLiteOperator instance.\n\n The returned TfLiteOperator instance represents a definition\n of an operator with the identity (builtin_code/custom_name and\n version) specified by the parameters, but with all callbacks initially\n unset.\n\n Evaluation of any operation using this operator will be done using\n the \"prepare\" and \"invoke\" callbacks, which can be set using\n `TfLiteOperatorSetPrepare` and\n `TfLiteOperatorSetInvoke`, or for async execution\n the \"prepare\", \"eval\", and \"wait\" callbacks of the `TfLiteAsyncKernel`,\n which can be set using `TfLiteOperatorSetAsyncKernel`.\n If the relevant callbacks are not set, then such evaluation will result\n in an error status.  So normally any use of this function should be followed\n by appropriate calls to set those callbacks.\n\n \\note The caller retains ownership and should ensure that\n the lifetime of the `TfLiteOperator` must be at least as long as\n the lifetime of any `TfLiteInterpreter` or `tflite::Interpreter` that it is\n used in.\n\n \\param builtin_code Enumeration code specifying which builtin operator this\n                     defines, or `TfLiteBuiltinCustom` to define a custom op.\n \\param custom_name  Name of the custom op, or `nullptr` for a builtin op.\n                     If `custom_name` is non-null, then `builtin_code` should\n                     be `TfLiteBuiltinCustom`.\n \\param version      Version of the op.  See\n                     https://www.tensorflow.org/lite/guide/ops_version\n \\param user_data    Opaque pointer passed to the operator's callbacks set\n                     with functions such as `TfLiteOperatorSetXXXWithData`.\n                     The user is expected to manage the memory pointed by\n                     this field and the lifetime of that memory should extend\n                     at least from the call to `TfLiteOperatorCreate`\n                     to the invocation of the callback set with\n                     `TfLiteOperatorSetFreeWithData`.\n\n \\return a newly created TfLiteOperator on success, or a nullptr on failure"]
    pub unsafe fn TfLiteOperatorCreate(
        &self,
        builtin_code: TfLiteBuiltinOperator,
        custom_name: *const ::std::os::raw::c_char,
        version: ::std::os::raw::c_int,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut TfLiteOperator {
        (self
            .TfLiteOperatorCreate
            .as_ref()
            .expect("Expected function, got error."))(
            builtin_code, custom_name, version, user_data
        )
    }
    #[doc = " Destroys the TfLiteOperator instance.\n"]
    pub unsafe fn TfLiteOperatorDelete(&self, registration: *mut TfLiteOperator) {
        (self
            .TfLiteOperatorDelete
            .as_ref()
            .expect("Expected function, got error."))(registration)
    }
    #[doc = " Return the builtin op code of the provided external 'registration'.\n"]
    pub unsafe fn TfLiteOperatorGetBuiltInCode(
        &self,
        registration: *const TfLiteOperator,
    ) -> TfLiteBuiltinOperator {
        (self
            .TfLiteOperatorGetBuiltInCode
            .as_ref()
            .expect("Expected function, got error."))(registration)
    }
    #[doc = " Returns the custom name of the provided 'registration'. The returned pointer\n will be non-null iff the op is a custom op.\n"]
    pub unsafe fn TfLiteOperatorGetCustomName(
        &self,
        registration: *const TfLiteOperator,
    ) -> *const ::std::os::raw::c_char {
        (self
            .TfLiteOperatorGetCustomName
            .as_ref()
            .expect("Expected function, got error."))(registration)
    }
    #[doc = " Return the OP version of the provided external 'registration'.  Return -1\n in case of error, or if the provided address is null.\n"]
    pub unsafe fn TfLiteOperatorGetVersion(
        &self,
        registration: *const TfLiteOperator,
    ) -> ::std::os::raw::c_int {
        (self
            .TfLiteOperatorGetVersion
            .as_ref()
            .expect("Expected function, got error."))(registration)
    }
    #[doc = " Return the user data field of the provided external 'registration', or\n nullptr if none was set.\n"]
    pub unsafe fn TfLiteOperatorGetUserData(
        &self,
        registration: *const TfLiteOperator,
    ) -> *mut ::std::os::raw::c_void {
        (self
            .TfLiteOperatorGetUserData
            .as_ref()
            .expect("Expected function, got error."))(registration)
    }
    #[doc = " Sets the initialization callback for the registration.\n\n The callback is called to initialize the op from serialized data.\n Please refer `init` of `TfLiteRegistration` for the detail.\n\n Deprecated: Use `TfLiteOperatorSetInitWithData`"]
    pub unsafe fn TfLiteOperatorSetInit(
        &self,
        registration: *mut TfLiteOperator,
        init: ::std::option::Option<
            unsafe extern "C" fn(
                context: *mut TfLiteOpaqueContext,
                buffer: *const ::std::os::raw::c_char,
                length: usize,
            ) -> *mut ::std::os::raw::c_void,
        >,
    ) {
        (self
            .TfLiteOperatorSetInit
            .as_ref()
            .expect("Expected function, got error."))(registration, init)
    }
    #[doc = " Sets the initialization callback for the registration. The function returns\n an error upon failure.\n\n The callback is called to initialize the op from serialized data. The value\n passed in the `user_data` parameter is the value that was passed to\n `TfLiteOperatorCreate`.  Please refer `init` of `TfLiteRegistration`\n for the detail.\n"]
    pub unsafe fn TfLiteOperatorSetInitWithData(
        &self,
        registration: *mut TfLiteOperator,
        init: ::std::option::Option<
            unsafe extern "C" fn(
                user_data: *mut ::std::os::raw::c_void,
                context: *mut TfLiteOpaqueContext,
                buffer: *const ::std::os::raw::c_char,
                length: usize,
            ) -> *mut ::std::os::raw::c_void,
        >,
    ) -> TfLiteStatus {
        (self
            .TfLiteOperatorSetInitWithData
            .as_ref()
            .expect("Expected function, got error."))(registration, init)
    }
    #[doc = " Sets the deallocation callback for the registration.\n\n This callback is called to deallocate the data returned by the init\n callback. The value passed in the `data` parameter is the value that was\n returned by the `init` callback. Please refer `free` of `TfLiteRegistration`\n for the detail.\n\n Deprecated: Use `TfLiteOperatorSetFreeWithData`"]
    pub unsafe fn TfLiteOperatorSetFree(
        &self,
        registration: *mut TfLiteOperator,
        free: ::std::option::Option<
            unsafe extern "C" fn(
                context: *mut TfLiteOpaqueContext,
                data: *mut ::std::os::raw::c_void,
            ),
        >,
    ) {
        (self
            .TfLiteOperatorSetFree
            .as_ref()
            .expect("Expected function, got error."))(registration, free)
    }
    #[doc = " Sets the deallocation callback for the registration, similarly to\n `TfLiteOperatorSetFree`. The function returns an error upon failure.\n\n This callback is called to deallocate the data returned by the init\n callback. The value passed in the `data` parameter is the value that was\n returned by the `init` callback. The value passed in the `user_data`\n parameter is the value that was passed to `TfLiteOperatorCreate`.\n Please refer `free` of `TfLiteRegistration` for the detail.\n"]
    pub unsafe fn TfLiteOperatorSetFreeWithData(
        &self,
        registration: *mut TfLiteOperator,
        free: ::std::option::Option<
            unsafe extern "C" fn(
                user_data: *mut ::std::os::raw::c_void,
                context: *mut TfLiteOpaqueContext,
                data: *mut ::std::os::raw::c_void,
            ),
        >,
    ) -> TfLiteStatus {
        (self
            .TfLiteOperatorSetFreeWithData
            .as_ref()
            .expect("Expected function, got error."))(registration, free)
    }
    #[doc = " Sets the preparation callback for the registration.\n\n The callback is called when the inputs of operator have been resized.\n Please refer `prepare` of `TfLiteRegistration` for the detail.\n\n Deprecated: Use `TfLiteOperatorSetPrepareWithData`"]
    pub unsafe fn TfLiteOperatorSetPrepare(
        &self,
        registration: *mut TfLiteOperator,
        prepare: ::std::option::Option<
            unsafe extern "C" fn(
                context: *mut TfLiteOpaqueContext,
                node: *mut TfLiteOpaqueNode,
            ) -> TfLiteStatus,
        >,
    ) {
        (self
            .TfLiteOperatorSetPrepare
            .as_ref()
            .expect("Expected function, got error."))(registration, prepare)
    }
    #[doc = " Sets the preparation callback for the registration. The function returns an\n error upon failure.\n\n The callback is called when the inputs of operator have been resized.  The\n value passed in the `user_data` parameter is the value that was passed to\n `TfLiteOperatorCreate`.  Please refer `prepare` of\n `TfLiteRegistration` for the detail.\n"]
    pub unsafe fn TfLiteOperatorSetPrepareWithData(
        &self,
        registration: *mut TfLiteOperator,
        prepare: ::std::option::Option<
            unsafe extern "C" fn(
                user_data: *mut ::std::os::raw::c_void,
                context: *mut TfLiteOpaqueContext,
                node: *mut TfLiteOpaqueNode,
            ) -> TfLiteStatus,
        >,
    ) -> TfLiteStatus {
        (self
            .TfLiteOperatorSetPrepareWithData
            .as_ref()
            .expect("Expected function, got error."))(registration, prepare)
    }
    #[doc = " Sets the invocation callback for the registration.\n\n The callback is called when the operator is executed.\n Please refer `invoke` of `TfLiteRegistration` for the detail.\n\n Deprecated: Use `TfLiteOperatorSetInvokeWithData`"]
    pub unsafe fn TfLiteOperatorSetInvoke(
        &self,
        registration: *mut TfLiteOperator,
        invoke: ::std::option::Option<
            unsafe extern "C" fn(
                context: *mut TfLiteOpaqueContext,
                node: *mut TfLiteOpaqueNode,
            ) -> TfLiteStatus,
        >,
    ) {
        (self
            .TfLiteOperatorSetInvoke
            .as_ref()
            .expect("Expected function, got error."))(registration, invoke)
    }
    #[doc = " Sets the invocation callback for the registration. The function returns an\n error upon failure.\n\n The callback is called when the operator is executed.  The value passed in\n the `user_data` parameter is the value that was passed to\n `TfLiteOperatorCreate`.  Please refer `invoke` of `TfLiteRegistration` for\n the detail.\n"]
    pub unsafe fn TfLiteOperatorSetInvokeWithData(
        &self,
        registration: *mut TfLiteOperator,
        invoke: ::std::option::Option<
            unsafe extern "C" fn(
                user_data: *mut ::std::os::raw::c_void,
                context: *mut TfLiteOpaqueContext,
                node: *mut TfLiteOpaqueNode,
            ) -> TfLiteStatus,
        >,
    ) -> TfLiteStatus {
        (self
            .TfLiteOperatorSetInvokeWithData
            .as_ref()
            .expect("Expected function, got error."))(registration, invoke)
    }
    #[doc = " Sets the async kernel accessor callback for the registration.\n\n The callback is called to retrieve the async kernel if the delegate supports\n it. If the delegate does not support async execution, either this function\n should not be called, or `async_kernel` needs to be nullptr.\n `node` is the delegate TfLiteNode created by `ModifyGraphWithDelegate`.\n Please refer `async_kernel` of `TfLiteRegistration` for the detail.\n\n \\warning This is an experimental API and subject to change.\n Deprecated: Use `TfLiteOperatorSetAsyncKernelWithData`"]
    pub unsafe fn TfLiteOperatorSetAsyncKernel(
        &self,
        registration: *mut TfLiteOperator,
        async_kernel: ::std::option::Option<
            unsafe extern "C" fn(
                context: *mut TfLiteOpaqueContext,
                node: *mut TfLiteOpaqueNode,
            ) -> *mut TfLiteAsyncKernel,
        >,
    ) {
        (self
            .TfLiteOperatorSetAsyncKernel
            .as_ref()
            .expect("Expected function, got error."))(registration, async_kernel)
    }
    #[doc = " Sets the async kernel accessor callback for the registration. The function\n returns an error upon failure.\n\n The callback is called to retrieve the async kernel if the delegate supports\n it. If the delegate does not support async execution, either this function\n should not be called, or `async_kernel` needs to be nullptr.  `node` is the\n delegate TfLiteNode created by `ModifyGraphWithDelegate`.  The value passed\n in the `user_data` parameter is the value that was passed to\n `TfLiteOperatorCreate`.  Please refer `async_kernel` of `TfLiteRegistration`\n for the detail.\n\n \\warning This is an experimental API and subject to change."]
    pub unsafe fn TfLiteOperatorSetAsyncKernelWithData(
        &self,
        registration: *mut TfLiteOperator,
        async_kernel: ::std::option::Option<
            unsafe extern "C" fn(
                user_data: *mut ::std::os::raw::c_void,
                context: *mut TfLiteOpaqueContext,
                node: *mut TfLiteOpaqueNode,
            ) -> *mut TfLiteAsyncKernel,
        >,
    ) -> TfLiteStatus {
        (self
            .TfLiteOperatorSetAsyncKernelWithData
            .as_ref()
            .expect("Expected function, got error."))(registration, async_kernel)
    }
    #[doc = " Sets the inplace_operator field of the external registration.\n\n This is a bitmask. Please refer to `inplace_operator` field of\n `TfLiteRegistration` for details.\n"]
    pub unsafe fn TfLiteOperatorSetInplaceOperator(
        &self,
        registration: *mut TfLiteOperator,
        inplace_operator: u64,
    ) {
        (self
            .TfLiteOperatorSetInplaceOperator
            .as_ref()
            .expect("Expected function, got error."))(registration, inplace_operator)
    }
    #[doc = " The TensorFlow Lite Runtime version.\n\n Returns a pointer to a statically allocated string that is the version\n number of the (potentially dynamically loaded) TF Lite Runtime library.\n TensorFlow Lite uses semantic versioning, and the return value should be\n in semver 2 format <http://semver.org>, starting with MAJOR.MINOR.PATCH,\n e.g. \"2.12.0\" or \"2.13.0-rc2\"."]
    pub unsafe fn TfLiteVersion(&self) -> *const ::std::os::raw::c_char {
        (self
            .TfLiteVersion
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " The TensorFlow Lite Extension APIs version.\n\n Returns a pointer to a statically allocated string that is the version\n number of the TF Lite Extension APIs supported by the (potentially\n dynamically loaded) TF Lite Runtime library.  The TF Lite \"Extension APIs\"\n are the APIs for extending TF Lite with custom ops and delegates.\n More specifically, this version number covers the (non-experimental)\n functionality documented in the following header files:\n\n   * lite/c/c_api_opaque.h\n   * lite/c/common.h\n   * lite/c/builtin_op_data.h\n   * lite/builtin_ops.h\n\n This version number uses semantic versioning, and the return value should\n be in semver 2 format <http://semver.org>, starting with MAJOR.MINOR.PATCH,\n e.g. \"2.14.0\" or \"2.15.0-rc2\"."]
    pub unsafe fn TfLiteExtensionApisVersion(&self) -> *const ::std::os::raw::c_char {
        (self
            .TfLiteExtensionApisVersion
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " The supported TensorFlow Lite model file Schema version.\n\n Returns the (major) version number of the Schema used for model\n files that is supported by the (potentially dynamically loaded)\n TensorFlow Lite Runtime.\n\n Model files using schema versions different to this may not be supported by\n the current version of the TF Lite Runtime."]
    pub unsafe fn TfLiteSchemaVersion(&self) -> ::std::os::raw::c_int {
        (self
            .TfLiteSchemaVersion
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Returns a model from the provided buffer, or null on failure.\n\n \\note The caller retains ownership of the `model_data` buffer and should\n ensure that the lifetime of the `model_data` buffer must be at least as long\n as the lifetime of the `TfLiteModel` and of any `TfLiteInterpreter` objects\n created from that `TfLiteModel`, and furthermore the contents of the\n `model_data` buffer must not be modified during that time.\""]
    pub unsafe fn TfLiteModelCreate(
        &self,
        model_data: *const ::std::os::raw::c_void,
        model_size: usize,
    ) -> *mut TfLiteModel {
        (self
            .TfLiteModelCreate
            .as_ref()
            .expect("Expected function, got error."))(model_data, model_size)
    }
    #[doc = " Same as `TfLiteModelCreate` with customizble error reporter.\n * `reporter` takes the provided `user_data` object, as well as a C-style\n   format string and arg list (see also vprintf).\n * `user_data` is optional. If non-null, it is owned by the client and must\n   remain valid for the duration of the interpreter lifetime."]
    pub unsafe fn TfLiteModelCreateWithErrorReporter(
        &self,
        model_data: *const ::std::os::raw::c_void,
        model_size: usize,
        reporter: ::std::option::Option<
            unsafe extern "C" fn(
                user_data: *mut ::std::os::raw::c_void,
                format: *const ::std::os::raw::c_char,
                args: *mut __va_list_tag,
            ),
        >,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut TfLiteModel {
        (self
            .TfLiteModelCreateWithErrorReporter
            .as_ref()
            .expect("Expected function, got error."))(
            model_data, model_size, reporter, user_data
        )
    }
    #[doc = " Returns a model from the provided file, or null on failure.\n\n \\note The file's contents must not be modified during the lifetime of the\n `TfLiteModel` or of any `TfLiteInterpreter` objects created from that\n `TfLiteModel`."]
    pub unsafe fn TfLiteModelCreateFromFile(
        &self,
        model_path: *const ::std::os::raw::c_char,
    ) -> *mut TfLiteModel {
        (self
            .TfLiteModelCreateFromFile
            .as_ref()
            .expect("Expected function, got error."))(model_path)
    }
    #[doc = " Same as `TfLiteModelCreateFromFile` with customizble error reporter.\n * `reporter` takes the provided `user_data` object, as well as a C-style\n   format string and arg list (see also vprintf).\n * `user_data` is optional. If non-null, it is owned by the client and must\n   remain valid for the duration of the interpreter lifetime."]
    pub unsafe fn TfLiteModelCreateFromFileWithErrorReporter(
        &self,
        model_path: *const ::std::os::raw::c_char,
        reporter: ::std::option::Option<
            unsafe extern "C" fn(
                user_data: *mut ::std::os::raw::c_void,
                format: *const ::std::os::raw::c_char,
                args: *mut __va_list_tag,
            ),
        >,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut TfLiteModel {
        (self
            .TfLiteModelCreateFromFileWithErrorReporter
            .as_ref()
            .expect("Expected function, got error."))(model_path, reporter, user_data)
    }
    #[doc = " Destroys the model instance."]
    pub unsafe fn TfLiteModelDelete(&self, model: *mut TfLiteModel) {
        (self
            .TfLiteModelDelete
            .as_ref()
            .expect("Expected function, got error."))(model)
    }
    #[doc = " Returns a new interpreter options instances."]
    pub unsafe fn TfLiteInterpreterOptionsCreate(&self) -> *mut TfLiteInterpreterOptions {
        (self
            .TfLiteInterpreterOptionsCreate
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Creates and returns a shallow copy of an options object.\n\n The caller is responsible for calling `TfLiteInterpreterOptionsDelete` to\n deallocate the object pointed to by the returned pointer."]
    pub unsafe fn TfLiteInterpreterOptionsCopy(
        &self,
        from: *const TfLiteInterpreterOptions,
    ) -> *mut TfLiteInterpreterOptions {
        (self
            .TfLiteInterpreterOptionsCopy
            .as_ref()
            .expect("Expected function, got error."))(from)
    }
    #[doc = " Destroys the interpreter options instance."]
    pub unsafe fn TfLiteInterpreterOptionsDelete(&self, options: *mut TfLiteInterpreterOptions) {
        (self
            .TfLiteInterpreterOptionsDelete
            .as_ref()
            .expect("Expected function, got error."))(options)
    }
    #[doc = " Sets the number of CPU threads to use for the interpreter."]
    pub unsafe fn TfLiteInterpreterOptionsSetNumThreads(
        &self,
        options: *mut TfLiteInterpreterOptions,
        num_threads: i32,
    ) {
        (self
            .TfLiteInterpreterOptionsSetNumThreads
            .as_ref()
            .expect("Expected function, got error."))(options, num_threads)
    }
    #[doc = " Adds a delegate to be applied during `TfLiteInterpreter` creation.\n\n If delegate application fails, interpreter creation will also fail with an\n associated error logged.\n\n \\note The caller retains ownership of the delegate and should ensure that it\n remains valid for the duration of any created interpreter's lifetime.\n\n If you are NOT using \"TensorFlow Lite in Play Services\", and NOT building\n with `TFLITE_WITH_STABLE_ABI` or `TFLITE_USE_OPAQUE_DELEGATE` macros\n enabled, it is possible to pass a `TfLiteDelegate*` rather than a\n `TfLiteOpaqueDelegate*` to this function, since in those cases,\n `TfLiteOpaqueDelegate` is just a typedef alias for `TfLiteDelegate`.\n This is for compatibility with existing source code\n and existing delegates.  For new delegates, it is recommended to\n use `TfLiteOpaqueDelegate` rather than `TfLiteDelegate`.  (See\n `TfLiteOpaqueDelegate` in tensorflow/lite/core/c/c_api_types.h.)"]
    pub unsafe fn TfLiteInterpreterOptionsAddDelegate(
        &self,
        options: *mut TfLiteInterpreterOptions,
        delegate: *mut TfLiteOpaqueDelegate,
    ) {
        (self
            .TfLiteInterpreterOptionsAddDelegate
            .as_ref()
            .expect("Expected function, got error."))(options, delegate)
    }
    #[doc = " Sets a custom error reporter for interpreter execution.\n\n * `reporter` takes the provided `user_data` object, as well as a C-style\n   format string and arg list (see also vprintf).\n * `user_data` is optional. If non-null, it is owned by the client and must\n   remain valid for the duration of the interpreter lifetime."]
    pub unsafe fn TfLiteInterpreterOptionsSetErrorReporter(
        &self,
        options: *mut TfLiteInterpreterOptions,
        reporter: ::std::option::Option<
            unsafe extern "C" fn(
                user_data: *mut ::std::os::raw::c_void,
                format: *const ::std::os::raw::c_char,
                args: *mut __va_list_tag,
            ),
        >,
        user_data: *mut ::std::os::raw::c_void,
    ) {
        (self
            .TfLiteInterpreterOptionsSetErrorReporter
            .as_ref()
            .expect("Expected function, got error."))(options, reporter, user_data)
    }
    #[doc = " Adds an op registration to be applied during `TfLiteInterpreter` creation.\n\n The `TfLiteOperator` object is needed to implement custom op of\n TFLite Interpreter via C API. Calling this function ensures that any\n `TfLiteInterpreter` created with the specified `options` can execute models\n that use the custom operator specified in `registration`.\n Please refer https://www.tensorflow.org/lite/guide/ops_custom for custom op\n support.\n \\note The caller retains ownership of the TfLiteOperator object\n and should ensure that it remains valid for the duration of any created\n interpreter's lifetime.\n \\warning This is an experimental API and subject to change."]
    pub unsafe fn TfLiteInterpreterOptionsAddOperator(
        &self,
        options: *mut TfLiteInterpreterOptions,
        registration: *mut TfLiteOperator,
    ) {
        (self
            .TfLiteInterpreterOptionsAddOperator
            .as_ref()
            .expect("Expected function, got error."))(options, registration)
    }
    #[doc = " Enables users to cancel in-flight invocations with\n `TfLiteInterpreterCancel`.\n\n By default it is disabled and calling to `TfLiteInterpreterCancel` will\n return kTfLiteError. See `TfLiteInterpreterCancel`."]
    pub unsafe fn TfLiteInterpreterOptionsEnableCancellation(
        &self,
        options: *mut TfLiteInterpreterOptions,
        enable: bool,
    ) -> TfLiteStatus {
        (self
            .TfLiteInterpreterOptionsEnableCancellation
            .as_ref()
            .expect("Expected function, got error."))(options, enable)
    }
    #[doc = " Returns a new interpreter using the provided model and options, or null on\n failure.\n\n * `model` must be a valid model instance. The caller retains ownership of\n   the object, and may destroy it (via TfLiteModelDelete) immediately after\n   creating the interpreter.  However, if the TfLiteModel was allocated with\n   TfLiteModelCreate, then the `model_data` buffer that was passed to\n   TfLiteModelCreate must outlive the lifetime of the TfLiteInterpreter\n   object that this function returns, and must not be modified during that\n   time; and if the TfLiteModel was allocated with TfLiteModelCreateFromFile,\n   then the contents of the model file must not be modified during the\n   lifetime of the TfLiteInterpreter object that this function returns.\n * `optional_options` may be null. The caller retains ownership of the\n   object, and can safely destroy it (via TfLiteInterpreterOptionsDelete)\n   immediately after creating the interpreter.\n\n \\note The client *must* explicitly allocate tensors before attempting to\n access input tensor data or invoke the interpreter."]
    pub unsafe fn TfLiteInterpreterCreate(
        &self,
        model: *const TfLiteModel,
        optional_options: *const TfLiteInterpreterOptions,
    ) -> *mut TfLiteInterpreter {
        (self
            .TfLiteInterpreterCreate
            .as_ref()
            .expect("Expected function, got error."))(model, optional_options)
    }
    #[doc = " Destroys the interpreter."]
    pub unsafe fn TfLiteInterpreterDelete(&self, interpreter: *mut TfLiteInterpreter) {
        (self
            .TfLiteInterpreterDelete
            .as_ref()
            .expect("Expected function, got error."))(interpreter)
    }
    #[doc = " Returns the number of input tensors associated with the model."]
    pub unsafe fn TfLiteInterpreterGetInputTensorCount(
        &self,
        interpreter: *const TfLiteInterpreter,
    ) -> i32 {
        (self
            .TfLiteInterpreterGetInputTensorCount
            .as_ref()
            .expect("Expected function, got error."))(interpreter)
    }
    #[doc = " Returns a pointer to an array of input tensor indices.  The length of the\n array can be obtained via a call to `TfLiteInterpreterGetInputTensorCount`.\n\n Typically the input tensors associated with an `interpreter` would be set\n during the initialization of the `interpreter`, through a mechanism like the\n `InterpreterBuilder`, and remain unchanged throughout the lifetime of the\n interpreter.  However, there are some circumstances in which the pointer may\n not remain valid throughout the lifetime of the interpreter, because calls\n to `SetInputs` on the interpreter invalidate the returned pointer.\n\n The ownership of the array remains with the TFLite runtime."]
    pub unsafe fn TfLiteInterpreterInputTensorIndices(
        &self,
        interpreter: *const TfLiteInterpreter,
    ) -> *const ::std::os::raw::c_int {
        (self
            .TfLiteInterpreterInputTensorIndices
            .as_ref()
            .expect("Expected function, got error."))(interpreter)
    }
    #[doc = " Returns the tensor associated with the input index.\n REQUIRES: 0 <= input_index < TfLiteInterpreterGetInputTensorCount(tensor)"]
    pub unsafe fn TfLiteInterpreterGetInputTensor(
        &self,
        interpreter: *const TfLiteInterpreter,
        input_index: i32,
    ) -> *mut TfLiteTensor {
        (self
            .TfLiteInterpreterGetInputTensor
            .as_ref()
            .expect("Expected function, got error."))(interpreter, input_index)
    }
    #[doc = " Resizes the specified input tensor.\n\n \\note After a resize, the client *must* explicitly allocate tensors before\n attempting to access the resized tensor data or invoke the interpreter.\n\n REQUIRES: 0 <= input_index < TfLiteInterpreterGetInputTensorCount(tensor)\n\n This function makes a copy of the input dimensions, so the client can safely\n deallocate `input_dims` immediately after this function returns."]
    pub unsafe fn TfLiteInterpreterResizeInputTensor(
        &self,
        interpreter: *mut TfLiteInterpreter,
        input_index: i32,
        input_dims: *const ::std::os::raw::c_int,
        input_dims_size: i32,
    ) -> TfLiteStatus {
        (self
            .TfLiteInterpreterResizeInputTensor
            .as_ref()
            .expect("Expected function, got error."))(
            interpreter,
            input_index,
            input_dims,
            input_dims_size,
        )
    }
    #[doc = " Updates allocations for all tensors, resizing dependent tensors using the\n specified input tensor dimensionality.\n\n This is a relatively expensive operation, and need only be called after\n creating the graph and/or resizing any inputs."]
    pub unsafe fn TfLiteInterpreterAllocateTensors(
        &self,
        interpreter: *mut TfLiteInterpreter,
    ) -> TfLiteStatus {
        (self
            .TfLiteInterpreterAllocateTensors
            .as_ref()
            .expect("Expected function, got error."))(interpreter)
    }
    #[doc = " Runs inference for the loaded graph.\n\n Before calling this function, the caller should first invoke\n TfLiteInterpreterAllocateTensors() and should also set the values for the\n input tensors.  After successfully calling this function, the values for the\n output tensors will be set.\n\n \\note It is possible that the interpreter is not in a ready state to\n evaluate (e.g., if AllocateTensors() hasn't been called, or if a\n ResizeInputTensor() has been performed without a subsequent call to\n AllocateTensors()).\n\n   If the (experimental!) delegate fallback option was enabled in the\n   interpreter options, then the interpreter will automatically fall back to\n   not using any delegates if execution with delegates fails. For details,\n   see TfLiteInterpreterOptionsSetEnableDelegateFallback in\n   c_api_experimental.h.\n\n Returns one of the following status codes:\n  - kTfLiteOk: Success. Output is valid.\n  - kTfLiteDelegateError: Execution with delegates failed, due to a problem\n    with the delegate(s). If fallback was not enabled, output is invalid.\n    If fallback was enabled, this return value indicates that fallback\n    succeeded, the output is valid, and all delegates previously applied to\n    the interpreter have been undone.\n  - kTfLiteApplicationError: Same as for kTfLiteDelegateError, except that\n    the problem was not with the delegate itself, but rather was\n    due to an incompatibility between the delegate(s) and the\n    interpreter or model.\n  - kTfLiteError: Unexpected/runtime failure. Output is invalid."]
    pub unsafe fn TfLiteInterpreterInvoke(
        &self,
        interpreter: *mut TfLiteInterpreter,
    ) -> TfLiteStatus {
        (self
            .TfLiteInterpreterInvoke
            .as_ref()
            .expect("Expected function, got error."))(interpreter)
    }
    #[doc = " Returns the number of output tensors associated with the model."]
    pub unsafe fn TfLiteInterpreterGetOutputTensorCount(
        &self,
        interpreter: *const TfLiteInterpreter,
    ) -> i32 {
        (self
            .TfLiteInterpreterGetOutputTensorCount
            .as_ref()
            .expect("Expected function, got error."))(interpreter)
    }
    #[doc = " Returns a pointer to an array of output tensor indices.  The length of the\n array can be obtained via a call to `TfLiteInterpreterGetOutputTensorCount`.\n\n Typically the output tensors associated with an `interpreter` would be set\n during the initialization of the `interpreter`, through a mechanism like the\n `InterpreterBuilder`, and remain unchanged throughout the lifetime of the\n interpreter.  However, there are some circumstances in which the pointer may\n not remain valid throughout the lifetime of the interpreter, because calls\n to `SetOutputs` on the interpreter invalidate the returned pointer.\n\n The ownership of the array remains with the TFLite runtime."]
    pub unsafe fn TfLiteInterpreterOutputTensorIndices(
        &self,
        interpreter: *const TfLiteInterpreter,
    ) -> *const ::std::os::raw::c_int {
        (self
            .TfLiteInterpreterOutputTensorIndices
            .as_ref()
            .expect("Expected function, got error."))(interpreter)
    }
    #[doc = " Returns the tensor associated with the output index.\n REQUIRES: 0 <= output_index < TfLiteInterpreterGetOutputTensorCount(tensor)\n\n \\note The shape and underlying data buffer for output tensors may be not\n be available until after the output tensor has been both sized and\n allocated.\n In general, best practice is to interact with the output tensor *after*\n calling TfLiteInterpreterInvoke()."]
    pub unsafe fn TfLiteInterpreterGetOutputTensor(
        &self,
        interpreter: *const TfLiteInterpreter,
        output_index: i32,
    ) -> *const TfLiteTensor {
        (self
            .TfLiteInterpreterGetOutputTensor
            .as_ref()
            .expect("Expected function, got error."))(interpreter, output_index)
    }
    #[doc = " Returns modifiable access to the tensor that corresponds to the\n specified `index` and is associated with the provided `interpreter`.\n\n This requires the `index` to be between 0 and N - 1, where N is the\n number of tensors in the model.\n\n Typically the tensors associated with the `interpreter` would be set during\n the `interpreter` initialization, through a mechanism like the\n `InterpreterBuilder`, and remain unchanged throughout the lifetime of the\n interpreter.  However, there are some circumstances in which the pointer may\n not remain valid throughout the lifetime of the interpreter, because calls\n to `AddTensors` on the interpreter invalidate the returned pointer.\n\n Note the difference between this function and\n `TfLiteInterpreterGetInputTensor` (or `TfLiteInterpreterGetOutputTensor` for\n that matter): `TfLiteInterpreterGetTensor` takes an index into the array of\n all tensors associated with the `interpreter`'s model, whereas\n `TfLiteInterpreterGetInputTensor` takes an index into the array of input\n tensors.\n\n The ownership of the tensor remains with the TFLite runtime, meaning the\n caller should not deallocate the pointer."]
    pub unsafe fn TfLiteInterpreterGetTensor(
        &self,
        interpreter: *const TfLiteInterpreter,
        index: ::std::os::raw::c_int,
    ) -> *mut TfLiteTensor {
        (self
            .TfLiteInterpreterGetTensor
            .as_ref()
            .expect("Expected function, got error."))(interpreter, index)
    }
    #[doc = " Tries to cancel any in-flight invocation.\n\n \\note This only cancels `TfLiteInterpreterInvoke` calls that happen before\n calling this and it does not cancel subsequent invocations.\n \\note Calling this function will also cancel any in-flight invocations of\n SignatureRunners constructed from this interpreter.\n Non-blocking and thread safe.\n\n Returns kTfLiteError if cancellation is not enabled via\n `TfLiteInterpreterOptionsEnableCancellation`."]
    pub unsafe fn TfLiteInterpreterCancel(
        &self,
        interpreter: *const TfLiteInterpreter,
    ) -> TfLiteStatus {
        (self
            .TfLiteInterpreterCancel
            .as_ref()
            .expect("Expected function, got error."))(interpreter)
    }
    #[doc = " Returns the number of signatures defined in the model."]
    pub unsafe fn TfLiteInterpreterGetSignatureCount(
        &self,
        interpreter: *const TfLiteInterpreter,
    ) -> i32 {
        (self
            .TfLiteInterpreterGetSignatureCount
            .as_ref()
            .expect("Expected function, got error."))(interpreter)
    }
    #[doc = " Returns the key of the Nth signature in the model, where N is specified as\n `signature_index`.\n\n NOTE: The lifetime of the returned key is the same as (and depends on) the\n lifetime of `interpreter`."]
    pub unsafe fn TfLiteInterpreterGetSignatureKey(
        &self,
        interpreter: *const TfLiteInterpreter,
        signature_index: i32,
    ) -> *const ::std::os::raw::c_char {
        (self
            .TfLiteInterpreterGetSignatureKey
            .as_ref()
            .expect("Expected function, got error."))(interpreter, signature_index)
    }
    #[doc = " Returns a new signature runner using the provided interpreter and signature\n key, or nullptr on failure.\n\n NOTE: `signature_key` is a null-terminated C string that must match the\n key of a signature in the interpreter's model.\n\n NOTE: The returned signature runner should be destroyed, by calling\n TfLiteSignatureRunnerDelete(), before the interpreter is destroyed."]
    pub unsafe fn TfLiteInterpreterGetSignatureRunner(
        &self,
        interpreter: *const TfLiteInterpreter,
        signature_key: *const ::std::os::raw::c_char,
    ) -> *mut TfLiteSignatureRunner {
        (self
            .TfLiteInterpreterGetSignatureRunner
            .as_ref()
            .expect("Expected function, got error."))(interpreter, signature_key)
    }
    #[doc = " Returns the number of inputs associated with a signature."]
    pub unsafe fn TfLiteSignatureRunnerGetInputCount(
        &self,
        signature_runner: *const TfLiteSignatureRunner,
    ) -> usize {
        (self
            .TfLiteSignatureRunnerGetInputCount
            .as_ref()
            .expect("Expected function, got error."))(signature_runner)
    }
    #[doc = " Returns the (null-terminated) name of the Nth input in a signature, where N\n is specified as `input_index`.\n\n NOTE: The lifetime of the returned name is the same as (and depends on) the\n lifetime of `signature_runner`."]
    pub unsafe fn TfLiteSignatureRunnerGetInputName(
        &self,
        signature_runner: *const TfLiteSignatureRunner,
        input_index: i32,
    ) -> *const ::std::os::raw::c_char {
        (self
            .TfLiteSignatureRunnerGetInputName
            .as_ref()
            .expect("Expected function, got error."))(signature_runner, input_index)
    }
    #[doc = " Resizes the input tensor identified as `input_name` to be the dimensions\n specified by `input_dims` and `input_dims_size`. Only unknown dimensions can\n be resized with this function. Unknown dimensions are indicated as `-1` in\n the `dims_signature` attribute of a TfLiteTensor.\n\n Returns status of failure or success. Note that this doesn't actually resize\n any existing buffers. A call to TfLiteSignatureRunnerAllocateTensors() is\n required to change the tensor input buffer.\n\n NOTE: This function is similar to TfLiteInterpreterResizeInputTensorStrict()\n and not TfLiteInterpreterResizeInputTensor().\n\n NOTE: `input_name` must match the name of an input in the signature.\n\n NOTE: This function makes a copy of the input dimensions, so the caller can\n safely deallocate `input_dims` immediately after this function returns."]
    pub unsafe fn TfLiteSignatureRunnerResizeInputTensor(
        &self,
        signature_runner: *mut TfLiteSignatureRunner,
        input_name: *const ::std::os::raw::c_char,
        input_dims: *const ::std::os::raw::c_int,
        input_dims_size: i32,
    ) -> TfLiteStatus {
        (self
            .TfLiteSignatureRunnerResizeInputTensor
            .as_ref()
            .expect("Expected function, got error."))(
            signature_runner,
            input_name,
            input_dims,
            input_dims_size,
        )
    }
    #[doc = " Updates allocations for tensors associated with a signature and resizes\n dependent tensors using the specified input tensor dimensionality.\n This is a relatively expensive operation and hence should only be called\n after initializing the signature runner object and/or resizing any inputs."]
    pub unsafe fn TfLiteSignatureRunnerAllocateTensors(
        &self,
        signature_runner: *mut TfLiteSignatureRunner,
    ) -> TfLiteStatus {
        (self
            .TfLiteSignatureRunnerAllocateTensors
            .as_ref()
            .expect("Expected function, got error."))(signature_runner)
    }
    #[doc = " Returns the input tensor identified by `input_name` in the given signature.\n Returns nullptr if the given name is not valid.\n\n NOTE: The lifetime of the returned tensor is the same as (and depends on)\n the lifetime of `signature_runner`."]
    pub unsafe fn TfLiteSignatureRunnerGetInputTensor(
        &self,
        signature_runner: *mut TfLiteSignatureRunner,
        input_name: *const ::std::os::raw::c_char,
    ) -> *mut TfLiteTensor {
        (self
            .TfLiteSignatureRunnerGetInputTensor
            .as_ref()
            .expect("Expected function, got error."))(signature_runner, input_name)
    }
    #[doc = " Runs inference on a given signature.\n\n Before calling this function, the caller should first invoke\n TfLiteSignatureRunnerAllocateTensors() and should also set the values for\n the input tensors. After successfully calling this function, the values for\n the output tensors will be set."]
    pub unsafe fn TfLiteSignatureRunnerInvoke(
        &self,
        signature_runner: *mut TfLiteSignatureRunner,
    ) -> TfLiteStatus {
        (self
            .TfLiteSignatureRunnerInvoke
            .as_ref()
            .expect("Expected function, got error."))(signature_runner)
    }
    #[doc = " Returns the number of output tensors associated with the signature."]
    pub unsafe fn TfLiteSignatureRunnerGetOutputCount(
        &self,
        signature_runner: *const TfLiteSignatureRunner,
    ) -> usize {
        (self
            .TfLiteSignatureRunnerGetOutputCount
            .as_ref()
            .expect("Expected function, got error."))(signature_runner)
    }
    #[doc = " Returns the (null-terminated) name of the Nth output in a signature, where\n N is specified as `output_index`.\n\n NOTE: The lifetime of the returned name is the same as (and depends on) the\n lifetime of `signature_runner`."]
    pub unsafe fn TfLiteSignatureRunnerGetOutputName(
        &self,
        signature_runner: *const TfLiteSignatureRunner,
        output_index: i32,
    ) -> *const ::std::os::raw::c_char {
        (self
            .TfLiteSignatureRunnerGetOutputName
            .as_ref()
            .expect("Expected function, got error."))(signature_runner, output_index)
    }
    #[doc = " Returns the output tensor identified by `output_name` in the given\n signature. Returns nullptr if the given name is not valid.\n\n NOTE: The lifetime of the returned tensor is the same as (and depends on)\n the lifetime of `signature_runner`."]
    pub unsafe fn TfLiteSignatureRunnerGetOutputTensor(
        &self,
        signature_runner: *const TfLiteSignatureRunner,
        output_name: *const ::std::os::raw::c_char,
    ) -> *const TfLiteTensor {
        (self
            .TfLiteSignatureRunnerGetOutputTensor
            .as_ref()
            .expect("Expected function, got error."))(signature_runner, output_name)
    }
    #[doc = " Returns the type of a tensor element."]
    pub unsafe fn TfLiteTensorType(&self, tensor: *const TfLiteTensor) -> TfLiteType {
        (self
            .TfLiteTensorType
            .as_ref()
            .expect("Expected function, got error."))(tensor)
    }
    #[doc = " Returns the number of dimensions that the tensor has.  Returns -1 in case\n the 'opaque_tensor' does not have its dimensions property set."]
    pub unsafe fn TfLiteTensorNumDims(&self, tensor: *const TfLiteTensor) -> i32 {
        (self
            .TfLiteTensorNumDims
            .as_ref()
            .expect("Expected function, got error."))(tensor)
    }
    #[doc = " Returns the length of the tensor in the \"dim_index\" dimension.\n REQUIRES: 0 <= dim_index < TFLiteTensorNumDims(tensor)"]
    pub unsafe fn TfLiteTensorDim(&self, tensor: *const TfLiteTensor, dim_index: i32) -> i32 {
        (self
            .TfLiteTensorDim
            .as_ref()
            .expect("Expected function, got error."))(tensor, dim_index)
    }
    #[doc = " Returns the size of the underlying data in bytes."]
    pub unsafe fn TfLiteTensorByteSize(&self, tensor: *const TfLiteTensor) -> usize {
        (self
            .TfLiteTensorByteSize
            .as_ref()
            .expect("Expected function, got error."))(tensor)
    }
    #[doc = " Returns a pointer to the underlying data buffer.\n\n \\note The result may be null if tensors have not yet been allocated, e.g.,\n if the Tensor has just been created or resized and `TfLiteAllocateTensors()`\n has yet to be called, or if the output tensor is dynamically sized and the\n interpreter hasn't been invoked."]
    pub unsafe fn TfLiteTensorData(
        &self,
        tensor: *const TfLiteTensor,
    ) -> *mut ::std::os::raw::c_void {
        (self
            .TfLiteTensorData
            .as_ref()
            .expect("Expected function, got error."))(tensor)
    }
    #[doc = " Returns the (null-terminated) name of the tensor."]
    pub unsafe fn TfLiteTensorName(
        &self,
        tensor: *const TfLiteTensor,
    ) -> *const ::std::os::raw::c_char {
        (self
            .TfLiteTensorName
            .as_ref()
            .expect("Expected function, got error."))(tensor)
    }
    #[doc = " Returns the parameters for asymmetric quantization. The quantization\n parameters are only valid when the tensor type is `kTfLiteUInt8` and the\n `scale != 0`. Quantized values can be converted back to float using:\n    real_value = scale * (quantized_value - zero_point);"]
    pub unsafe fn TfLiteTensorQuantizationParams(
        &self,
        tensor: *const TfLiteTensor,
    ) -> TfLiteQuantizationParams {
        (self
            .TfLiteTensorQuantizationParams
            .as_ref()
            .expect("Expected function, got error."))(tensor)
    }
    #[doc = " Copies from the provided input buffer into the tensor's buffer.\n REQUIRES: input_data_size == TfLiteTensorByteSize(tensor)"]
    pub unsafe fn TfLiteTensorCopyFromBuffer(
        &self,
        tensor: *mut TfLiteTensor,
        input_data: *const ::std::os::raw::c_void,
        input_data_size: usize,
    ) -> TfLiteStatus {
        (self
            .TfLiteTensorCopyFromBuffer
            .as_ref()
            .expect("Expected function, got error."))(tensor, input_data, input_data_size)
    }
    #[doc = " Copies to the provided output buffer from the tensor's buffer.\n REQUIRES: output_data_size == TfLiteTensorByteSize(tensor)"]
    pub unsafe fn TfLiteTensorCopyToBuffer(
        &self,
        output_tensor: *const TfLiteTensor,
        output_data: *mut ::std::os::raw::c_void,
        output_data_size: usize,
    ) -> TfLiteStatus {
        (self
            .TfLiteTensorCopyToBuffer
            .as_ref()
            .expect("Expected function, got error."))(
            output_tensor, output_data, output_data_size
        )
    }
    #[doc = " Destroys the signature runner."]
    pub unsafe fn TfLiteSignatureRunnerDelete(&self, signature_runner: *mut TfLiteSignatureRunner) {
        (self
            .TfLiteSignatureRunnerDelete
            .as_ref()
            .expect("Expected function, got error."))(signature_runner)
    }
    #[doc = " Given the size (number of elements) in a TfLiteIntArray, calculate its size\n in bytes."]
    pub unsafe fn TfLiteIntArrayGetSizeInBytes(&self, size: ::std::os::raw::c_int) -> usize {
        (self
            .TfLiteIntArrayGetSizeInBytes
            .as_ref()
            .expect("Expected function, got error."))(size)
    }
    #[doc = " Create a array of a given `size` (uninitialized entries).\n This returns a pointer, that you must free using TfLiteIntArrayFree()."]
    pub unsafe fn TfLiteIntArrayCreate(&self, size: ::std::os::raw::c_int) -> *mut TfLiteIntArray {
        (self
            .TfLiteIntArrayCreate
            .as_ref()
            .expect("Expected function, got error."))(size)
    }
    #[doc = " Check if two intarrays are equal. Returns 1 if they are equal, 0 otherwise."]
    pub unsafe fn TfLiteIntArrayEqual(
        &self,
        a: *const TfLiteIntArray,
        b: *const TfLiteIntArray,
    ) -> ::std::os::raw::c_int {
        (self
            .TfLiteIntArrayEqual
            .as_ref()
            .expect("Expected function, got error."))(a, b)
    }
    #[doc = " Check if an intarray equals an array. Returns 1 if equals, 0 otherwise."]
    pub unsafe fn TfLiteIntArrayEqualsArray(
        &self,
        a: *const TfLiteIntArray,
        b_size: ::std::os::raw::c_int,
        b_data: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .TfLiteIntArrayEqualsArray
            .as_ref()
            .expect("Expected function, got error."))(a, b_size, b_data)
    }
    #[doc = " Create a copy of an array passed as `src`.\n You are expected to free memory with TfLiteIntArrayFree"]
    pub unsafe fn TfLiteIntArrayCopy(&self, src: *const TfLiteIntArray) -> *mut TfLiteIntArray {
        (self
            .TfLiteIntArrayCopy
            .as_ref()
            .expect("Expected function, got error."))(src)
    }
    #[doc = " Free memory of array `a`."]
    pub unsafe fn TfLiteIntArrayFree(&self, a: *mut TfLiteIntArray) {
        (self
            .TfLiteIntArrayFree
            .as_ref()
            .expect("Expected function, got error."))(a)
    }
    #[doc = " Given the size (number of elements) in a TfLiteFloatArray, calculate its\n size in bytes."]
    pub unsafe fn TfLiteFloatArrayGetSizeInBytes(
        &self,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .TfLiteFloatArrayGetSizeInBytes
            .as_ref()
            .expect("Expected function, got error."))(size)
    }
    #[doc = " Create a array of a given `size` (uninitialized entries).\n This returns a pointer, that you must free using TfLiteFloatArrayFree()."]
    pub unsafe fn TfLiteFloatArrayCreate(
        &self,
        size: ::std::os::raw::c_int,
    ) -> *mut TfLiteFloatArray {
        (self
            .TfLiteFloatArrayCreate
            .as_ref()
            .expect("Expected function, got error."))(size)
    }
    #[doc = " Create a copy of an array passed as `src`.\n You are expected to free memory with TfLiteFloatArrayFree."]
    pub unsafe fn TfLiteFloatArrayCopy(
        &self,
        src: *const TfLiteFloatArray,
    ) -> *mut TfLiteFloatArray {
        (self
            .TfLiteFloatArrayCopy
            .as_ref()
            .expect("Expected function, got error."))(src)
    }
    #[doc = " Free memory of array `a`."]
    pub unsafe fn TfLiteFloatArrayFree(&self, a: *mut TfLiteFloatArray) {
        (self
            .TfLiteFloatArrayFree
            .as_ref()
            .expect("Expected function, got error."))(a)
    }
    #[doc = " Return the name of a given type, for error reporting purposes."]
    pub unsafe fn TfLiteTypeGetName(&self, type_: TfLiteType) -> *const ::std::os::raw::c_char {
        (self
            .TfLiteTypeGetName
            .as_ref()
            .expect("Expected function, got error."))(type_)
    }
    #[doc = " Free data memory of tensor `t`."]
    pub unsafe fn TfLiteTensorDataFree(&self, t: *mut TfLiteTensor) {
        (self
            .TfLiteTensorDataFree
            .as_ref()
            .expect("Expected function, got error."))(t)
    }
    #[doc = " Free quantization data."]
    pub unsafe fn TfLiteQuantizationFree(&self, quantization: *mut TfLiteQuantization) {
        (self
            .TfLiteQuantizationFree
            .as_ref()
            .expect("Expected function, got error."))(quantization)
    }
    #[doc = " Free sparsity parameters."]
    pub unsafe fn TfLiteSparsityFree(&self, sparsity: *mut TfLiteSparsity) {
        (self
            .TfLiteSparsityFree
            .as_ref()
            .expect("Expected function, got error."))(sparsity)
    }
    #[doc = " Free memory of tensor `t`."]
    pub unsafe fn TfLiteTensorFree(&self, t: *mut TfLiteTensor) {
        (self
            .TfLiteTensorFree
            .as_ref()
            .expect("Expected function, got error."))(t)
    }
    #[doc = " Set all of a tensor's fields (and free any previously allocated data)."]
    pub unsafe fn TfLiteTensorReset(
        &self,
        type_: TfLiteType,
        name: *const ::std::os::raw::c_char,
        dims: *mut TfLiteIntArray,
        quantization: TfLiteQuantizationParams,
        buffer: *mut ::std::os::raw::c_char,
        size: usize,
        allocation_type: TfLiteAllocationType,
        allocation: *const ::std::os::raw::c_void,
        is_variable: bool,
        tensor: *mut TfLiteTensor,
    ) {
        (self
            .TfLiteTensorReset
            .as_ref()
            .expect("Expected function, got error."))(
            type_,
            name,
            dims,
            quantization,
            buffer,
            size,
            allocation_type,
            allocation,
            is_variable,
            tensor,
        )
    }
    #[doc = " Copies the contents of `src` in `dst`.\n Function does nothing if either `src` or `dst` is passed as nullptr and\n return `kTfLiteOk`.\n Returns `kTfLiteError` if `src` and `dst` doesn't have matching data size.\n Note function copies contents, so it won't create new data pointer\n or change allocation type.\n All Tensor related properties will be copied from `src` to `dst` like\n quantization, sparsity, ..."]
    pub unsafe fn TfLiteTensorCopy(
        &self,
        src: *const TfLiteTensor,
        dst: *mut TfLiteTensor,
    ) -> TfLiteStatus {
        (self
            .TfLiteTensorCopy
            .as_ref()
            .expect("Expected function, got error."))(src, dst)
    }
    #[doc = " Change the size of the memory block owned by `tensor` to `num_bytes`.\n Tensors with allocation types other than `kTfLiteDynamic` will be ignored\n and a `kTfLiteOk` will be returned. `tensor`'s internal data buffer will be\n assigned a pointer which can safely be passed to free or realloc if\n `num_bytes` is zero. If `preserve_data` is true, tensor data will be\n unchanged in the range from the start of the region up to the minimum of the\n old and new sizes. In the case of NULL tensor, or an error allocating new\n memory, returns `kTfLiteError`."]
    pub unsafe fn TfLiteTensorResizeMaybeCopy(
        &self,
        num_bytes: usize,
        tensor: *mut TfLiteTensor,
        preserve_data: bool,
    ) -> TfLiteStatus {
        (self
            .TfLiteTensorResizeMaybeCopy
            .as_ref()
            .expect("Expected function, got error."))(num_bytes, tensor, preserve_data)
    }
    #[doc = " Change the size of the memory block owned by `tensor` to `num_bytes`.\n Tensors with allocation types other than `kTfLiteDynamic` will be ignored\n and a `kTfLiteOk` will be returned. `tensor`'s internal data buffer will be\n assigned a pointer which can safely be passed to free or realloc if\n `num_bytes` is zero. Tensor data will be unchanged in the range from the\n start of the region up to the minimum of the old and new sizes. In the case\n of NULL tensor, or an error allocating new memory, returns `kTfLiteError`."]
    pub unsafe fn TfLiteTensorRealloc(
        &self,
        num_bytes: usize,
        tensor: *mut TfLiteTensor,
    ) -> TfLiteStatus {
        (self
            .TfLiteTensorRealloc
            .as_ref()
            .expect("Expected function, got error."))(num_bytes, tensor)
    }
    #[doc = " Build a `null` delegate, with all the fields properly set to their default\n values."]
    pub unsafe fn TfLiteDelegateCreate(&self) -> TfLiteDelegate {
        (self
            .TfLiteDelegateCreate
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Creates an opaque delegate and returns its address.  The opaque delegate\n will behave according to the provided `opaque_delegate_builder`.  The\n lifetime of the objects pointed to by any of the fields within the\n `opaque_delegate_builder` must outlive the returned\n `TfLiteOpaqueDelegate` and any `TfLiteInterpreter`,\n `TfLiteInterpreterOptions`, `tflite::Interpreter`, or\n `tflite::InterpreterBuilder` that the delegate is added to.  The returned\n address should be passed to `TfLiteOpaqueDelegateDelete` for deletion.  If\n `opaque_delegate_builder` is a null pointer, then a null pointer will be\n returned."]
    pub unsafe fn TfLiteOpaqueDelegateCreate(
        &self,
        opaque_delegate_builder: *const TfLiteOpaqueDelegateBuilder,
    ) -> *mut TfLiteOpaqueDelegate {
        (self
            .TfLiteOpaqueDelegateCreate
            .as_ref()
            .expect("Expected function, got error."))(opaque_delegate_builder)
    }
    #[doc = " Deletes the provided opaque `delegate`.  This function has no effect if the\n `delegate` is a null pointer."]
    pub unsafe fn TfLiteOpaqueDelegateDelete(&self, delegate: *mut TfLiteOpaqueDelegate) {
        (self
            .TfLiteOpaqueDelegateDelete
            .as_ref()
            .expect("Expected function, got error."))(delegate)
    }
    #[doc = " Returns a pointer to the data associated with the provided opaque\n `delegate`.\n\n A null pointer will be returned when:\n - The `delegate` is null.\n - The `data` field of the `TfLiteOpaqueDelegateBuilder` used to construct\n   the `delegate` was null.\n - Or in case of any other error.\n - The `delegate` has been constructed via a `TfLiteOpaqueDelegateBuilder`,\n   but the `data` field of the `TfLiteOpaqueDelegateBuilder` is null.\n\n  The data_ field of `delegate` will be returned if the\n  `opaque_delegate_builder` field is null."]
    pub unsafe fn TfLiteOpaqueDelegateGetData(
        &self,
        delegate: *const TfLiteOpaqueDelegate,
    ) -> *mut ::std::os::raw::c_void {
        (self
            .TfLiteOpaqueDelegateGetData
            .as_ref()
            .expect("Expected function, got error."))(delegate)
    }
    #[doc = " Returns a tensor data allocation strategy."]
    pub unsafe fn TfLiteTensorGetAllocationStrategy(
        &self,
        t: *const TfLiteTensor,
    ) -> TfLiteAllocationStrategy {
        (self
            .TfLiteTensorGetAllocationStrategy
            .as_ref()
            .expect("Expected function, got error."))(t)
    }
    #[doc = " Returns how stable a tensor data buffer address is across runs."]
    pub unsafe fn TfLiteTensorGetBufferAddressStability(
        &self,
        t: *const TfLiteTensor,
    ) -> TfLiteRunStability {
        (self
            .TfLiteTensorGetBufferAddressStability
            .as_ref()
            .expect("Expected function, got error."))(t)
    }
    #[doc = " Returns how stable a tensor data values are across runs."]
    pub unsafe fn TfLiteTensorGetDataStability(
        &self,
        t: *const TfLiteTensor,
    ) -> TfLiteRunStability {
        (self
            .TfLiteTensorGetDataStability
            .as_ref()
            .expect("Expected function, got error."))(t)
    }
    #[doc = " Returns the operation step when the data of a tensor is populated.\n\n Some operations can precompute their results before the evaluation step.\n This makes the data available earlier for subsequent operations."]
    pub unsafe fn TfLiteTensorGetDataKnownStep(&self, t: *const TfLiteTensor) -> TfLiteRunStep {
        (self
            .TfLiteTensorGetDataKnownStep
            .as_ref()
            .expect("Expected function, got error."))(t)
    }
    #[doc = " Returns the operation steop when the shape of a tensor is computed.\n\n Some operations can precompute the shape of their results before the\n evaluation step. This makes the shape available earlier for subsequent\n operations."]
    pub unsafe fn TfLiteTensorGetShapeKnownStep(&self, t: *const TfLiteTensor) -> TfLiteRunStep {
        (self
            .TfLiteTensorGetShapeKnownStep
            .as_ref()
            .expect("Expected function, got error."))(t)
    }
    #[doc = " Returns the type of a tensor element."]
    pub unsafe fn TfLiteOpaqueTensorType(
        &self,
        opaque_tensor: *const TfLiteOpaqueTensor,
    ) -> TfLiteType {
        (self
            .TfLiteOpaqueTensorType
            .as_ref()
            .expect("Expected function, got error."))(opaque_tensor)
    }
    #[doc = " Returns the number of dimensions that the tensor has.  Returns -1 in case\n the 'opaque_tensor' does not have its dimensions property set."]
    pub unsafe fn TfLiteOpaqueTensorNumDims(
        &self,
        opaque_tensor: *const TfLiteOpaqueTensor,
    ) -> i32 {
        (self
            .TfLiteOpaqueTensorNumDims
            .as_ref()
            .expect("Expected function, got error."))(opaque_tensor)
    }
    #[doc = " Returns the length of the tensor in the \"dim_index\" dimension."]
    pub unsafe fn TfLiteOpaqueTensorDim(
        &self,
        opaque_tensor: *const TfLiteOpaqueTensor,
        dim_index: i32,
    ) -> i32 {
        (self
            .TfLiteOpaqueTensorDim
            .as_ref()
            .expect("Expected function, got error."))(opaque_tensor, dim_index)
    }
    #[doc = " Loads into the provided 'num_dims' the number of dimensions that the\n tensor's signature has. Returns 'kTfLiteOk' if 'num_dims' was successfully\n loaded. Any other return code indicates an error and 'num_dims' won't be\n loaded.\n\n A tensor's dimension signature encodes shapes with unknown dimensions with\n -1.  E.g. for a tensor with three dimensions, whose first dimension has an\n unknown size, and the second and third dimension have a size of 2, the\n dimension signature is [-1,2,2], and 'TfLiteOpaqueTensorGetNumDimsSignature'\n loads 3 into 'num_dims'. If the tensor does not have its dimension signature\n field set then 'num_dims' is set to -1."]
    pub unsafe fn TfLiteOpaqueTensorGetNumDimsSignature(
        &self,
        opaque_tensor: *const TfLiteOpaqueTensor,
        num_dims: *mut i32,
    ) -> TfLiteStatus {
        (self
            .TfLiteOpaqueTensorGetNumDimsSignature
            .as_ref()
            .expect("Expected function, got error."))(opaque_tensor, num_dims)
    }
    #[doc = " Loads into the provided 'dim_length' the length of the tensor in the\n 'dim_index' signature dimension or -1 if that dimension has unknown length.\n Returns 'kTfLiteOk' if 'dim_length' was successfully loaded. Any\n other return code indicates an error and 'dim_length' won't be loaded."]
    pub unsafe fn TfLiteOpaqueTensorGetDimSignature(
        &self,
        opaque_tensor: *const TfLiteOpaqueTensor,
        dim_index: i32,
        dim_length: *mut i32,
    ) -> TfLiteStatus {
        (self
            .TfLiteOpaqueTensorGetDimSignature
            .as_ref()
            .expect("Expected function, got error."))(opaque_tensor, dim_index, dim_length)
    }
    #[doc = " Returns 'non-zero' if the provided 'opaque_tensor' is a variable, and\n returns zero otherwise."]
    pub unsafe fn TfLiteOpaqueTensorIsVariable(
        &self,
        opaque_tensor: *const TfLiteOpaqueTensor,
    ) -> ::std::os::raw::c_int {
        (self
            .TfLiteOpaqueTensorIsVariable
            .as_ref()
            .expect("Expected function, got error."))(opaque_tensor)
    }
    #[doc = " Returns the size of the underlying data in bytes."]
    pub unsafe fn TfLiteOpaqueTensorByteSize(
        &self,
        opaque_tensor: *const TfLiteOpaqueTensor,
    ) -> usize {
        (self
            .TfLiteOpaqueTensorByteSize
            .as_ref()
            .expect("Expected function, got error."))(opaque_tensor)
    }
    #[doc = " Returns a pointer to the underlying data buffer.\n Returns nullptr if input is also nullptr."]
    pub unsafe fn TfLiteOpaqueTensorData(
        &self,
        opaque_tensor: *const TfLiteOpaqueTensor,
    ) -> *mut ::std::os::raw::c_void {
        (self
            .TfLiteOpaqueTensorData
            .as_ref()
            .expect("Expected function, got error."))(opaque_tensor)
    }
    #[doc = " Returns the 'opaque_tensor's allocation type."]
    pub unsafe fn TfLiteOpaqueTensorGetAllocationType(
        &self,
        opaque_tensor: *const TfLiteOpaqueTensor,
    ) -> TfLiteAllocationType {
        (self
            .TfLiteOpaqueTensorGetAllocationType
            .as_ref()
            .expect("Expected function, got error."))(opaque_tensor)
    }
    #[doc = " Returns a tensor data allocation strategy."]
    pub unsafe fn TfLiteOpaqueTensorGetAllocationStrategy(
        &self,
        t: *const TfLiteOpaqueTensor,
    ) -> TfLiteAllocationStrategy {
        (self
            .TfLiteOpaqueTensorGetAllocationStrategy
            .as_ref()
            .expect("Expected function, got error."))(t)
    }
    #[doc = " Returns how stable a tensor data buffer address is across runs."]
    pub unsafe fn TfLiteOpaqueTensorGetBufferAddressStability(
        &self,
        t: *const TfLiteOpaqueTensor,
    ) -> TfLiteRunStability {
        (self
            .TfLiteOpaqueTensorGetBufferAddressStability
            .as_ref()
            .expect("Expected function, got error."))(t)
    }
    #[doc = " Returns how stable a tensor data values are across runs."]
    pub unsafe fn TfLiteOpaqueTensorGetDataStability(
        &self,
        t: *const TfLiteOpaqueTensor,
    ) -> TfLiteRunStability {
        (self
            .TfLiteOpaqueTensorGetDataStability
            .as_ref()
            .expect("Expected function, got error."))(t)
    }
    #[doc = " Returns the operation step when the data of a tensor is populated."]
    pub unsafe fn TfLiteOpaqueTensorGetDataKnownStep(
        &self,
        t: *const TfLiteOpaqueTensor,
    ) -> TfLiteRunStep {
        (self
            .TfLiteOpaqueTensorGetDataKnownStep
            .as_ref()
            .expect("Expected function, got error."))(t)
    }
    #[doc = " Returns the operation step when the shape of a tensor is computed."]
    pub unsafe fn TfLiteOpaqueTensorGetShapeKnownStep(
        &self,
        t: *const TfLiteOpaqueTensor,
    ) -> TfLiteRunStep {
        (self
            .TfLiteOpaqueTensorGetShapeKnownStep
            .as_ref()
            .expect("Expected function, got error."))(t)
    }
    #[doc = " Returns the (null-terminated) name of the tensor."]
    pub unsafe fn TfLiteOpaqueTensorName(
        &self,
        opaque_tensor: *const TfLiteOpaqueTensor,
    ) -> *const ::std::os::raw::c_char {
        (self
            .TfLiteOpaqueTensorName
            .as_ref()
            .expect("Expected function, got error."))(opaque_tensor)
    }
    #[doc = " Returns the 'opaque_tensor's quantization information."]
    pub unsafe fn TfLiteOpaqueTensorGetQuantization(
        &self,
        opaque_tensor: *const TfLiteOpaqueTensor,
    ) -> TfLiteQuantization {
        (self
            .TfLiteOpaqueTensorGetQuantization
            .as_ref()
            .expect("Expected function, got error."))(opaque_tensor)
    }
    #[doc = " Returns the 'opaque_tensor's quantization parameters."]
    pub unsafe fn TfLiteOpaqueTensorGetQuantizationParams(
        &self,
        opaque_tensor: *const TfLiteOpaqueTensor,
    ) -> TfLiteQuantizationParams {
        (self
            .TfLiteOpaqueTensorGetQuantizationParams
            .as_ref()
            .expect("Expected function, got error."))(opaque_tensor)
    }
    #[doc = " Copies from the provided input buffer into the tensor's buffer."]
    pub unsafe fn TfLiteOpaqueTensorCopyFromBuffer(
        &self,
        opaque_tensor: *mut TfLiteOpaqueTensor,
        input_data: *const ::std::os::raw::c_void,
        input_data_size: usize,
    ) -> TfLiteStatus {
        (self
            .TfLiteOpaqueTensorCopyFromBuffer
            .as_ref()
            .expect("Expected function, got error."))(
            opaque_tensor, input_data, input_data_size
        )
    }
    #[doc = " Copies to the provided output buffer from the tensor's buffer."]
    pub unsafe fn TfLiteOpaqueTensorCopyToBuffer(
        &self,
        opaque_tensor: *const TfLiteOpaqueTensor,
        output_data: *mut ::std::os::raw::c_void,
        output_data_size: usize,
    ) -> TfLiteStatus {
        (self
            .TfLiteOpaqueTensorCopyToBuffer
            .as_ref()
            .expect("Expected function, got error."))(
            opaque_tensor, output_data, output_data_size
        )
    }
    #[doc = " Returns the number of strings stored in the provided 'tensor'.\n Returns -1 in case of failure."]
    pub unsafe fn TfLiteOpaqueTensorGetStringCount(
        &self,
        tensor: *const TfLiteOpaqueTensor,
    ) -> ::std::os::raw::c_int {
        (self
            .TfLiteOpaqueTensorGetStringCount
            .as_ref()
            .expect("Expected function, got error."))(tensor)
    }
    #[doc = " Stores the address of the n-th (denoted by the provided 'index') string\n contained in the provided 'tensor' in the provided '*str' pointer.  Stores\n the length of the string in the provided '*len' argument.\n\n Returns 'kTfLiteOk' if '*str' and '*len' have been set successfully.  Any\n other return value indicates a failure, which leaves '*str' and '*len' in an\n unspecified state.\n\n The range of valid indices is defined by the half open interval [0, N),\n where N == TfLiteOpaqueTensorGetStringCount(tensor).\n\n Note that 'str' is not guaranteed to be null-terminated. Also note that this\n function will not create a copy of the underlying string data.  The data is\n owned by the 'tensor'."]
    pub unsafe fn TfLiteOpaqueTensorGetString(
        &self,
        tensor: *const TfLiteOpaqueTensor,
        index: ::std::os::raw::c_int,
        str_: *mut *const ::std::os::raw::c_char,
        len: *mut ::std::os::raw::c_int,
    ) -> TfLiteStatus {
        (self
            .TfLiteOpaqueTensorGetString
            .as_ref()
            .expect("Expected function, got error."))(tensor, index, str_, len)
    }
    #[doc = " Writes the array of strings specified by 'str_array' into\n the specified 'tensor'.  The strings provided via the 'str_array' are being\n copied into the 'tensor'. Returns 'kTfLiteOk' in case of success.  Any other\n return value indicates a failure.\n\n The provided 'str_array_len' must denote the length of 'str_array'\n and 'str_n_len[i]' must denote the length of the i-th string.\n\n The provided strings don't need to be null terminated and may contain\n embedded null characters.  The amount of bytes copied into the 'tensor' is\n entirely determined by 'str_n_len[i]' and it is the caller's responsibility\n to set this value correctly to avoid undefined behavior.\n\n Also note that calling 'TfLiteOpaqueTensorWriteStrings' deallocates any\n previously stored data in the 'tensor'."]
    pub unsafe fn TfLiteOpaqueTensorWriteStrings(
        &self,
        tensor: *mut TfLiteOpaqueTensor,
        str_array: *const *const ::std::os::raw::c_char,
        str_array_len: ::std::os::raw::c_int,
        str_n_len: *const ::std::os::raw::c_int,
    ) -> TfLiteStatus {
        (self
            .TfLiteOpaqueTensorWriteStrings
            .as_ref()
            .expect("Expected function, got error."))(
            tensor, str_array, str_array_len, str_n_len
        )
    }
    #[doc = " Writes the string pointed to by the provided 'str' pointer of length 'len'\n into the provided 'tensor'.  The string provided via 'str' is\n copied into the 'tensor'.  Returns 'kTfLiteOk' in case of success. Any\n other return value indicates a failure.\n\n Note that calling 'TfLiteOpaqueTensorWriteString' deallocates any\n previously stored data in the 'tensor'.  E.g. suppose 't' denotes a\n 'TfLiteOpaqueTensor*', then calling 'TfLiteOpaqueTensorWriteString(t, \"AB\",\n 2)' followed by a call to 'TfLiteOpaqueTensorWriteString(t, \"CD\", 2)' will\n lead to 't' containing 'CD', not 'ABCD'.\n\n 'TfLiteOpaqueTensorWriteString' is a convenience function for the use case\n of writing a single string to a tensor and its effects are identical to\n calling 'TfLiteOpaqueTensorWriteStrings' with an array of a single string."]
    pub unsafe fn TfLiteOpaqueTensorWriteString(
        &self,
        tensor: *mut TfLiteOpaqueTensor,
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> TfLiteStatus {
        (self
            .TfLiteOpaqueTensorWriteString
            .as_ref()
            .expect("Expected function, got error."))(tensor, str_, len)
    }
    #[doc = " Creates an opaque tensor builder object."]
    pub unsafe fn TfLiteOpaqueTensorBuilderCreate(&self) -> *mut TfLiteOpaqueTensorBuilder {
        (self
            .TfLiteOpaqueTensorBuilderCreate
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Deletes an opaque tensor builder object."]
    pub unsafe fn TfLiteOpaqueTensorBuilderDelete(&self, builder: *mut TfLiteOpaqueTensorBuilder) {
        (self
            .TfLiteOpaqueTensorBuilderDelete
            .as_ref()
            .expect("Expected function, got error."))(builder)
    }
    #[doc = " Sets the 'TfLiteType' of the provided 'builder' to the provided 'type'.\n Returns the address of the provided 'builder', so that builder calls can be\n chained together."]
    pub unsafe fn TfLiteOpaqueTensorBuilderSetType(
        &self,
        builder: *mut TfLiteOpaqueTensorBuilder,
        type_: TfLiteType,
    ) -> *mut TfLiteOpaqueTensorBuilder {
        (self
            .TfLiteOpaqueTensorBuilderSetType
            .as_ref()
            .expect("Expected function, got error."))(builder, type_)
    }
    #[doc = " Sets the raw data of the provided 'builder' to the provided 'data'. Returns\n the address of the provided 'builder', so that builder calls can be chained\n together."]
    pub unsafe fn TfLiteOpaqueTensorBuilderSetData(
        &self,
        builder: *mut TfLiteOpaqueTensorBuilder,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut TfLiteOpaqueTensorBuilder {
        (self
            .TfLiteOpaqueTensorBuilderSetData
            .as_ref()
            .expect("Expected function, got error."))(builder, data)
    }
    #[doc = " Sets the allocation type of the provided 'builder' to the provided\n 'allocation_type'.  The 'allocation_type' must be one of the following:\n 'kTfLiteDynamic', 'kTfLiteArenaRw' or 'kTfLiteArenaRwPersistent'.  If the\n provided 'allocation_type' is not one of those values then\n 'TfLiteOpaqueContextAddTensor' will return an error. Returns the address of\n the provided 'builder', so that builder calls can be chained together."]
    pub unsafe fn TfLiteOpaqueTensorBuilderSetAllocationType(
        &self,
        builder: *mut TfLiteOpaqueTensorBuilder,
        allocation_type: TfLiteAllocationType,
    ) -> *mut TfLiteOpaqueTensorBuilder {
        (self
            .TfLiteOpaqueTensorBuilderSetAllocationType
            .as_ref()
            .expect("Expected function, got error."))(builder, allocation_type)
    }
    #[doc = " Sets the quantization params of the provided 'builder' to the provided\n 'params'. Returns the address of the provided 'builder', so that builder\n calls can be chained together."]
    pub unsafe fn TfLiteOpaqueTensorBuilderSetQuantizationParams(
        &self,
        builder: *mut TfLiteOpaqueTensorBuilder,
        params: TfLiteQuantizationParams,
    ) -> *mut TfLiteOpaqueTensorBuilder {
        (self
            .TfLiteOpaqueTensorBuilderSetQuantizationParams
            .as_ref()
            .expect("Expected function, got error."))(builder, params)
    }
    #[doc = " Sets the quantization of the provided 'builder' to the provided\n 'quantization'. Returns the address of the provided 'builder', so that\n builder calls can be chained together."]
    pub unsafe fn TfLiteOpaqueTensorBuilderSetQuantization(
        &self,
        builder: *mut TfLiteOpaqueTensorBuilder,
        quantization: TfLiteQuantization,
    ) -> *mut TfLiteOpaqueTensorBuilder {
        (self
            .TfLiteOpaqueTensorBuilderSetQuantization
            .as_ref()
            .expect("Expected function, got error."))(builder, quantization)
    }
    #[doc = " Sets the allocation type of the provided 'tensor' to 'kTfLiteDynamic'.\n This function has no effect if the 'tensor's allocation type is already\n 'kTfLiteDynamic'.  The provided 'tensor' must not be null."]
    pub unsafe fn TfLiteOpaqueTensorSetAllocationTypeToDynamic(
        &self,
        tensor: *mut TfLiteOpaqueTensor,
    ) {
        (self
            .TfLiteOpaqueTensorSetAllocationTypeToDynamic
            .as_ref()
            .expect("Expected function, got error."))(tensor)
    }
    #[doc = " Returns the input tensor of the given node."]
    pub unsafe fn TfLiteOpaqueNodeGetInput(
        &self,
        opaque_context: *const TfLiteOpaqueContext,
        opaque_node: *const TfLiteOpaqueNode,
        index: ::std::os::raw::c_int,
    ) -> *const TfLiteOpaqueTensor {
        (self
            .TfLiteOpaqueNodeGetInput
            .as_ref()
            .expect("Expected function, got error."))(opaque_context, opaque_node, index)
    }
    #[doc = " Returns the output tensor of the given node."]
    pub unsafe fn TfLiteOpaqueNodeGetOutput(
        &self,
        opaque_context: *mut TfLiteOpaqueContext,
        opaque_node: *const TfLiteOpaqueNode,
        index: ::std::os::raw::c_int,
    ) -> *mut TfLiteOpaqueTensor {
        (self
            .TfLiteOpaqueNodeGetOutput
            .as_ref()
            .expect("Expected function, got error."))(opaque_context, opaque_node, index)
    }
    #[doc = " Gets the number of input tensors of the provided 'opaque_node'."]
    pub unsafe fn TfLiteOpaqueNodeNumberOfInputs(
        &self,
        opaque_node: *const TfLiteOpaqueNode,
    ) -> ::std::os::raw::c_int {
        (self
            .TfLiteOpaqueNodeNumberOfInputs
            .as_ref()
            .expect("Expected function, got error."))(opaque_node)
    }
    #[doc = " Gets the number of output tensors of the provided 'opaque_node'."]
    pub unsafe fn TfLiteOpaqueNodeNumberOfOutputs(
        &self,
        opaque_node: *const TfLiteOpaqueNode,
    ) -> ::std::os::raw::c_int {
        (self
            .TfLiteOpaqueNodeNumberOfOutputs
            .as_ref()
            .expect("Expected function, got error."))(opaque_node)
    }
    #[doc = " Returns opaque data provided by the node implementer. The value returned\n from this function is the value that was returned from the `init` callback\n that was passed to `TfLiteOperatorSetInit`."]
    pub unsafe fn TfLiteOpaqueNodeGetUserData(
        &self,
        opaque_node: *const TfLiteOpaqueNode,
    ) -> *mut ::std::os::raw::c_void {
        (self
            .TfLiteOpaqueNodeGetUserData
            .as_ref()
            .expect("Expected function, got error."))(opaque_node)
    }
    #[doc = " Returns the builtin data associated with the provided 'opaque_node'.\n\n The builtin init data associated with a node would typically be set during\n the creation of the associated interpreter, through a mechanism like the\n interpreter builder that loads a TFLite model and initialises the\n interpreter's nodes accordingly.  Under these conditions the returned\n address remains valid throughout the lifetime of the 'opaque_node'."]
    pub unsafe fn TfLiteOpaqueNodeGetBuiltinData(
        &self,
        opaque_node: *const TfLiteOpaqueNode,
    ) -> *mut ::std::os::raw::c_void {
        (self
            .TfLiteOpaqueNodeGetBuiltinData
            .as_ref()
            .expect("Expected function, got error."))(opaque_node)
    }
    #[doc = " Loads into the provided '*init_data' pointer the address of the custom init\n data associated with the provided 'opaque_node'.  The length of data is\n loaded into the provided 'size' pointer.  Returns 'kTfLiteOk' in case\n of success.  Any other return value indicates a failure and will leave\n 'init_data' and 'size' in an unspecified state.\n\n The custom init data associated with a node would typically be set during\n the creation of the associated interpreter, through a mechanism like the\n interpreter builder that loads a TFLite model and initialises the\n interpreter's nodes accordingly.  Under these conditions the returned\n address remains valid throughout the lifetime of the 'opaque_node'."]
    pub unsafe fn TfLiteOpaqueNodeGetCustomInitialData(
        &self,
        opaque_node: *const TfLiteOpaqueNode,
        init_data: *mut *const ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_int,
    ) -> TfLiteStatus {
        (self
            .TfLiteOpaqueNodeGetCustomInitialData
            .as_ref()
            .expect("Expected function, got error."))(opaque_node, init_data, size)
    }
    #[doc = " Loads into the provided '*inputs' pointer the starting address of an array\n of indices representing the tensors that are inputs of the provided\n 'opaque_node'. The length of the array is loaded into the provided\n 'num_inputs' pointer. Returns 'kTfLiteOk' in case of success.  Any other\n return value indicates a failure and will leave 'inputs' and\n 'num_inputs' in an unspecified state.\n\n The input tensors associated with a node would typically be set during the\n creation of the associated interpreter, through a mechanism like the\n interpreter builder that loads a TFLite model and initialises the\n interpreter's nodes accordingly.  Under these conditions the loaded address\n remains valid throughout the lifetime of the 'opaque_node'."]
    pub unsafe fn TfLiteOpaqueNodeInputs(
        &self,
        opaque_node: *const TfLiteOpaqueNode,
        inputs: *mut *const ::std::os::raw::c_int,
        num_inputs: *mut ::std::os::raw::c_int,
    ) -> TfLiteStatus {
        (self
            .TfLiteOpaqueNodeInputs
            .as_ref()
            .expect("Expected function, got error."))(opaque_node, inputs, num_inputs)
    }
    #[doc = " Loads into the provided '*outputs' pointer the starting address of an array\n of indices representing the tensors that are outputs of the provided\n 'opaque_node'. The length of the array is loaded into the provided\n 'num_outputs' pointer. Returns 'kTfLiteOk' in case of success.  Any other\n return value indicates a failure and will leave 'outputs' and\n 'num_outputs' in an unspecified state.\n\n The output tensors associated with a node would typically be set during the\n creation of the associated interpreter, through a mechanism like the\n interpreter builder that loads a TFLite model and initialises the\n interpreter's nodes accordingly.  Under these conditions the loaded address\n remains valid throughout the lifetime of the 'opaque_node'."]
    pub unsafe fn TfLiteOpaqueNodeOutputs(
        &self,
        opaque_node: *const TfLiteOpaqueNode,
        outputs: *mut *const ::std::os::raw::c_int,
        num_outputs: *mut ::std::os::raw::c_int,
    ) -> TfLiteStatus {
        (self
            .TfLiteOpaqueNodeOutputs
            .as_ref()
            .expect("Expected function, got error."))(opaque_node, outputs, num_outputs)
    }
    #[doc = " Set tensor indices of temporary tensors used during the computations.\n These temporary tensors should be allocated using AddTensors().\n By default nodes don't have any temporary tensors, tensors, but ops are\n allowed to change that if they need scratch space of any sort.\n This will make a copy of the contents of the array pointed to by\n `temporaries`."]
    pub unsafe fn TfLiteOpaqueNodeSetTemporaries(
        &self,
        opaque_node: *mut TfLiteOpaqueNode,
        temporaries: *const ::std::os::raw::c_int,
        num_temporaries: ::std::os::raw::c_int,
    ) -> TfLiteStatus {
        (self
            .TfLiteOpaqueNodeSetTemporaries
            .as_ref()
            .expect("Expected function, got error."))(
            opaque_node, temporaries, num_temporaries
        )
    }
    #[doc = " Loads into the provided '*temporaries' pointer the starting address of an\n array of indices representing the temporary tensors associated with the\n provided 'opaque_node'. The length of the array is loaded into the provided\n 'num_temporaries' pointer. Returns 'kTfLiteOk' in case of success.  Any\n other return value indicates a failure and will leave 'temporaries' and\n 'num_temporaries' in an unspecified state.\n\n The temporary tensors associated with a node would typically be set during\n the creation of the associated interpreter, through a mechanism like the\n interpreter builder that loads a TFLite model and initialises the\n interpreter's nodes accordingly.  Under these conditions the loaded address\n remains valid throughout the lifetime of the 'opaque_node'."]
    pub unsafe fn TfLiteOpaqueNodeTemporaries(
        &self,
        opaque_node: *const TfLiteOpaqueNode,
        temporaries: *mut *const ::std::os::raw::c_int,
        num_temporaries: *mut ::std::os::raw::c_int,
    ) -> TfLiteStatus {
        (self
            .TfLiteOpaqueNodeTemporaries
            .as_ref()
            .expect("Expected function, got error."))(
            opaque_node, temporaries, num_temporaries
        )
    }
    #[doc = " Given an 'index_of_input', which must be in the range of [0, N), where N is\n the number of input tensors of the provided 'opaque_node', returns the\n (global) index of the tensor that holds the input.  Returns -1 if\n 'index_of_input' is not within the [0, N) range."]
    pub unsafe fn TfLiteOpaqueNodeGetInputTensorIndex(
        &self,
        opaque_node: *const TfLiteOpaqueNode,
        index_of_input: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .TfLiteOpaqueNodeGetInputTensorIndex
            .as_ref()
            .expect("Expected function, got error."))(opaque_node, index_of_input)
    }
    #[doc = " Given an 'index_of_output', which must be in the range of [0, N), where N is\n the number of output tensors of the provided 'opaque_node', returns the\n (global) index of the tensor that holds the output. Returns -1 if\n 'index_of_output' is not within the [0, N) range."]
    pub unsafe fn TfLiteOpaqueNodeGetOutputTensorIndex(
        &self,
        opaque_node: *const TfLiteOpaqueNode,
        index_of_output: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .TfLiteOpaqueNodeGetOutputTensorIndex
            .as_ref()
            .expect("Expected function, got error."))(opaque_node, index_of_output)
    }
    #[doc = " Loads the provided `execution_plan` associated with the provided\n `opaque_context`.  Returns `kTfLiteOk` if the `execution_plan` was\n successfully loaded.  A return value different from `kTfLiteOk` indicates a\n failure and the `execution_plan` will be left in an unspecified state."]
    pub unsafe fn TfLiteOpaqueContextGetExecutionPlan(
        &self,
        opaque_context: *mut TfLiteOpaqueContext,
        execution_plan: *mut *mut TfLiteIntArray,
    ) -> TfLiteStatus {
        (self
            .TfLiteOpaqueContextGetExecutionPlan
            .as_ref()
            .expect("Expected function, got error."))(opaque_context, execution_plan)
    }
    #[doc = " Returns the external context of the specified type associated with the\n provided `opaque_context`. Returns `kTfLiteOk` if the external context was\n successfully loaded. A return value different from `kTfLiteOk` indicates a\n failure and the `external_context` will be left in an unspecified state."]
    pub unsafe fn TfLiteOpaqueContextGetExternalContext(
        &self,
        opaque_context: *mut TfLiteOpaqueContext,
        external_context: *mut *mut ::std::os::raw::c_void,
        type_: TfLiteExternalContextType,
    ) -> TfLiteStatus {
        (self
            .TfLiteOpaqueContextGetExternalContext
            .as_ref()
            .expect("Expected function, got error."))(
            opaque_context, external_context, type_
        )
    }
    #[doc = " Given the specified 'opaque_context' and 'node_index', load the caller's\n opaque '*node' and '*registration_external' pointer.  Return 'kTfLiteOk' if\n both the '*node' as well as the '*registration_external' have been loaded\n correctly.  Any other return code indicates a failure and both '*node' as\n well as '*registration_external' will be in an unspecified state.\n\n A caller can obtain a node's index by calling\n 'TfLiteOpaqueContextGetExecutionPlan', which provides an array of node\n indices, sorted in execution order.  A node index might also come from the\n data structures passed to the delegate kernel's callback parameters, like\n the delegate parameters data structure passed to the 'init' callback that\n contains an array of node indices that are meant to be handled by the\n delegate kernel.\n\n This function is expected to be called from within a delegate callback, like\n 'Prepare', or a delegate kernel callback (i.e., a callback registered with\n a 'TfLiteOperator' object).\n\n The loaded '*node' and '*registration_external' pointers will generally\n remain valid for the lifetime of the associated 'opaque_context', but can be\n invalidated through API calls where delegates get un-applied, like API calls\n that modify the model graph via a delegate, or if input tensors get\n re-sized.\n"]
    pub unsafe fn TfLiteOpaqueContextGetNodeAndRegistration(
        &self,
        opaque_context: *mut TfLiteOpaqueContext,
        node_index: ::std::os::raw::c_int,
        node: *mut *mut TfLiteOpaqueNode,
        registration_external: *mut *mut TfLiteOperator,
    ) -> TfLiteStatus {
        (self
            .TfLiteOpaqueContextGetNodeAndRegistration
            .as_ref()
            .expect("Expected function, got error."))(
            opaque_context,
            node_index,
            node,
            registration_external,
        )
    }
    #[doc = " Entry point for C API ReplaceNodeSubsetsWithDelegateKernels\n\n Replaces the specified `nodes_to_replace` that are associated with the\n provided `opaque_context` with delegate kernels.  The provided\n `registration_external` represents the delegate kernel and will be used for\n each node subset that will be delegate to the provided `opaque_delegate`.\n\n The TF Lite runtime will take ownership of the `registration_external` and\n will delete it when the associated `opaque_context` gets destroyed.\n\n The ownership of the `nodes_to_replace` and the `opaque_delegate` remains\n with the caller."]
    pub unsafe fn TfLiteOpaqueContextReplaceNodeSubsetsWithDelegateKernels(
        &self,
        opaque_context: *mut TfLiteOpaqueContext,
        registration_external: *mut TfLiteOperator,
        nodes_to_replace: *const TfLiteIntArray,
        opaque_delegate: *mut TfLiteOpaqueDelegate,
    ) -> TfLiteStatus {
        (self
            .TfLiteOpaqueContextReplaceNodeSubsetsWithDelegateKernels
            .as_ref()
            .expect("Expected function, got error."))(
            opaque_context,
            registration_external,
            nodes_to_replace,
            opaque_delegate,
        )
    }
    #[doc = " Returns modifiable access to the opaque tensor that corresponds to the\n specified `index` and is associated with the provided `opaque_context`.\n\n This requires the `index` to be between 0 and N - 1, where N is the\n number of tensors in the model.\n\n Typically the tensors associated with the `context` would be set\n during the initialization of the `interpreter` that the `context` belongs\n to, through a mechanism like the `InterpreterBuilder`, and remain unchanged\n throughout the lifetime of the interpreter.  However, there are some\n circumstances in which the pointer may not remain valid throughout the\n lifetime of the interpreter, because calls to `AddTensors` on the\n interpreter invalidate the returned pointer.\n\n The ownership of the tensor remains with the TFLite runtime, meaning the\n caller should not deallocate the pointer."]
    pub unsafe fn TfLiteOpaqueContextGetOpaqueTensor(
        &self,
        opaque_context: *const TfLiteOpaqueContext,
        index: ::std::os::raw::c_int,
    ) -> *mut TfLiteOpaqueTensor {
        (self
            .TfLiteOpaqueContextGetOpaqueTensor
            .as_ref()
            .expect("Expected function, got error."))(opaque_context, index)
    }
    #[doc = " Loads into the provided '*inputs' pointer the starting address of an array\n of indices representing the tensors that are inputs to the subgraph that is\n associated with the provided 'opaque_context'.  The length of the array is\n loaded into the provided 'num_inputs' pointer.  Returns 'kTfLiteOk' in case\n of success.  Any other return value indicates a failure and will leave\n 'inputs' and 'num_inputs' in an unspecified state.  Calls to 'SetInputs' on\n the associated subgraph invalidate the loaded pointers."]
    pub unsafe fn TfLiteOpaqueContextGetInputs(
        &self,
        opaque_context: *const TfLiteOpaqueContext,
        inputs: *mut *const ::std::os::raw::c_int,
        num_inputs: *mut ::std::os::raw::c_int,
    ) -> TfLiteStatus {
        (self
            .TfLiteOpaqueContextGetInputs
            .as_ref()
            .expect("Expected function, got error."))(opaque_context, inputs, num_inputs)
    }
    #[doc = " Loads into the provided '*outputs' pointer the starting address of an array\n of indices representing the tensors that are outputs to the subgraph that is\n associated with the provided 'opaque_context'.  The length of the array is\n loaded into the provided 'num_outputs' pointer.  Returns 'kTfLiteOk' in case\n of success.  Any other return value indicates a failure and will leave\n 'outputs' and 'num_outputs' in an unspecified state.  Calls to 'SetOutputs'\n on the associated subgraph invalidate the loaded pointers."]
    pub unsafe fn TfLiteOpaqueContextGetOutputs(
        &self,
        opaque_context: *const TfLiteOpaqueContext,
        outputs: *mut *const ::std::os::raw::c_int,
        num_outputs: *mut ::std::os::raw::c_int,
    ) -> TfLiteStatus {
        (self
            .TfLiteOpaqueContextGetOutputs
            .as_ref()
            .expect("Expected function, got error."))(opaque_context, outputs, num_outputs)
    }
    #[doc = " Loads into the provided '*variables' pointer the starting address of an\n array of indices representing the tensors that are variables to the subgraph\n that is associated with the provided 'opaque_context'.  The length of the\n array is loaded into the provided 'num_variables' pointer.  Returns\n 'kTfLiteOk' in case of success.  Any other return value indicates a failure\n and will leave 'variables' and 'num_variables' in an unspecified state.\n Calls to 'SetVariables' on the associated subgraph invalidate the loaded\n pointers."]
    pub unsafe fn TfLiteOpaqueContextGetVariables(
        &self,
        opaque_context: *const TfLiteOpaqueContext,
        variables: *mut *const ::std::os::raw::c_int,
        num_variables: *mut ::std::os::raw::c_int,
    ) -> TfLiteStatus {
        (self
            .TfLiteOpaqueContextGetVariables
            .as_ref()
            .expect("Expected function, got error."))(
            opaque_context, variables, num_variables
        )
    }
    #[doc = " Returns the number of nodes associated with the provided 'opaque_context'."]
    pub unsafe fn TfLiteOpaqueContextGetNumNodes(
        &self,
        opaque_context: *const TfLiteOpaqueContext,
    ) -> usize {
        (self
            .TfLiteOpaqueContextGetNumNodes
            .as_ref()
            .expect("Expected function, got error."))(opaque_context)
    }
    #[doc = " Returns the number of tensors associated with the provided 'opaque_context'."]
    pub unsafe fn TfLiteOpaqueContextGetNumTensors(
        &self,
        opaque_context: *const TfLiteOpaqueContext,
    ) -> usize {
        (self
            .TfLiteOpaqueContextGetNumTensors
            .as_ref()
            .expect("Expected function, got error."))(opaque_context)
    }
    #[doc = " Returns the name of the subgraph that is associated with the provided\n 'opaque_context'.  Typically the returned pointer will remain valid\n throughout the lifetime of the subgraph, but may be invalidated by a call to\n 'Subgraph::SetName'."]
    pub unsafe fn TfLiteOpaqueContextGetName(
        &self,
        opaque_context: *const TfLiteOpaqueContext,
    ) -> *const ::std::os::raw::c_char {
        (self
            .TfLiteOpaqueContextGetName
            .as_ref()
            .expect("Expected function, got error."))(opaque_context)
    }
    #[doc = " Resizes the provided 'tensor' that is associated with the provided\n 'context' so that the 'tensor's shape matches the dimensionality specified\n via the provided 'new_size' array.  Returns 'kTfLiteOk' in\n case of success.  Any other return value indicates a failure and will leave\n the 'tensor' in an unspecified state.  The TF Lite runtime takes ownership\n of the 'new_size' array, even in case of failure."]
    pub unsafe fn TfLiteOpaqueContextResizeTensor(
        &self,
        context: *mut TfLiteOpaqueContext,
        tensor: *mut TfLiteOpaqueTensor,
        new_size: *mut TfLiteIntArray,
    ) -> TfLiteStatus {
        (self
            .TfLiteOpaqueContextResizeTensor
            .as_ref()
            .expect("Expected function, got error."))(context, tensor, new_size)
    }
    #[doc = " Entry point for C API AcquireSubgraphContext.\n\n Retrieves the corresponding TfLiteOpaqueContext of a subgraph given a\n subgraph index and switches to the delegate context for this subgraph. If an\n invalid subgraph index is given, then returns kTfLiteError.\n\n NOTE: This function is expected to be paired with\n TfLiteOpaqueContextReleaseSubgraphContext() once the delegate preparation is\n done and/or the delegate context functions are no longer needed."]
    pub unsafe fn TfLiteOpaqueContextAcquireSubgraphContext(
        &self,
        opaque_context: *mut TfLiteOpaqueContext,
        subgraph_index: ::std::os::raw::c_int,
        acquired_opaque_context: *mut *mut TfLiteOpaqueContext,
    ) -> TfLiteStatus {
        (self
            .TfLiteOpaqueContextAcquireSubgraphContext
            .as_ref()
            .expect("Expected function, got error."))(
            opaque_context,
            subgraph_index,
            acquired_opaque_context,
        )
    }
    #[doc = " Entry point for C API ReleaseSubgraphContext.\n\n Releases the corresponding TfLiteOpaqueContext by switching back to the\n TFLite kernel context for this specified subgraph.\n\n NOTE: This function is expected to be used after\n TfLiteOpaqueContextAcquireSubgraphContext() once the delegate preparation is\n done and/or the delegate context functions are no longer needed."]
    pub unsafe fn TfLiteOpaqueContextReleaseSubgraphContext(
        &self,
        opaque_context: *mut TfLiteOpaqueContext,
        subgraph_index: ::std::os::raw::c_int,
    ) -> TfLiteStatus {
        (self
            .TfLiteOpaqueContextReleaseSubgraphContext
            .as_ref()
            .expect("Expected function, got error."))(opaque_context, subgraph_index)
    }
    #[doc = " Entry point for C API MarkSubgraphAsDelegationSkippable\n\n Marks the subgraph with the given index as \"delegation-skippable\". Returns\n kTfLiteOk if the given subgraph index is valid and is successfully marked\n as delegation-skippable, and an error status if the subgraph index is\n invalid.\n If a subgraph is delegation-skippable, then the subgraph will be handled by\n a specific TfLiteOpaqueDelegate that is already supposed to be\n aware of this condition, and therefore, TfLiteInterpreter can skip invoking\n `ModifyGraphWithDelegate` on this subgraph.\n\n NOTE: This function is expected to be called only when the subgraph that\n `subgraph_index` is pointing to should be skipped by\n interpreter::ModifyGraphWithDelegate (e.g. the subgraph is part of the list\n of callee subgraphs of the same control flow node, and all of those callees\n are supported by the same delegate at once).\n\n For  example, this function can be used when the delegate is handling\n control flow ops such as while ops. For instance, a while op has a condition\n subgraph indexed at `i` and a body subgraph indexed at `j`. The op can be\n delegated when the following conditions hold:\n   1. The delegate supports while op\n   2. Both condition subgraph `i` and body subgraph `j` can be fully\n   delegated to the delegate.\n\n Then if the delegate decides to support the while node along with both body\n and condition subgraphs, it should mark subgraphs `i` and `j` skippable so\n that those two subgraphs won't be delegated to another delegate.\n\n WARNING: It is the delegate's responsibility to define when to skip\n `Subgraph::ModifyGraphWithDelegate`, to check for any edge cases (i.e.\n multiple references to the subgraph that `subgraph_index` is pointing to),\n and to mark a subgraph as skippable by using this function."]
    pub unsafe fn TfLiteOpaqueContextMarkSubgraphAsDelegationSkippable(
        &self,
        opaque_context: *mut TfLiteOpaqueContext,
        subgraph_index: ::std::os::raw::c_int,
    ) -> TfLiteStatus {
        (self
            .TfLiteOpaqueContextMarkSubgraphAsDelegationSkippable
            .as_ref()
            .expect("Expected function, got error."))(opaque_context, subgraph_index)
    }
    #[doc = " Loads metadata of a TF Lite node's custom initialization data. Specifically:\n * Loads into the supplied 'fd' the file descriptor of the file that stores\n   the 'node's custom  initialization data.  This output parameter will be\n   loaded if the TF Lite runtime has access to the file descriptor, though\n   this is not always the case, e.g. if a client provides a tflite::Model\n   directly to the TF Lite runtime.  If 'fd' can be loaded then 'kTfLiteOk'\n   will be returned, otherwise 'kTfLiteError' is returned.\n * Loads into the supplied 'custom_initial_data_offset_in_file' pointer the\n   offset of the 'node's custom init data in the file associated with 'fd'.\n   This output parameter will be set to -1 if the 'node' does not have custom\n   init data set.\n * Loads into the supplied 'custom_initial_data_size' the size of the\n   custom initialization data.  This output parameter will be set to -1 if\n   the 'node' does not have custom init data set.\n\n Returns 'kTfLiteOk' when 'fd' has been loaded successfully and\n 'kTfLiteError' otherwise.  Note that this means that 'kTfLiteOk' can be\n returned, even if the 'node' does not have custom init data set."]
    pub unsafe fn TfLiteOpaqueContextGetNodeInitDataMmapInfo(
        &self,
        context: *const TfLiteOpaqueContext,
        node: *const TfLiteOpaqueNode,
        fd: *mut ::std::os::raw::c_int,
        custom_initial_data_offset_in_file: *mut i64,
        custom_initial_data_size: *mut i64,
    ) -> TfLiteStatus {
        (self
            .TfLiteOpaqueContextGetNodeInitDataMmapInfo
            .as_ref()
            .expect("Expected function, got error."))(
            context,
            node,
            fd,
            custom_initial_data_offset_in_file,
            custom_initial_data_size,
        )
    }
    #[doc = " Adds an additional tensor and configures its properties based on the\n provided 'builder', preserving pre-existing Tensor entries. If non-null,\n the value pointed to by 'new_tensor_index' will be set to the index of the\n new tensor.  Returns 'kTfLiteOk' when the tensor has been added\n successfully.  Returns 'kTfLiteError' in case of failure."]
    pub unsafe fn TfLiteOpaqueContextAddTensor(
        &self,
        context: *mut TfLiteOpaqueContext,
        builder: *mut TfLiteOpaqueTensorBuilder,
        new_tensor_index: *mut ::std::os::raw::c_int,
    ) -> TfLiteStatus {
        (self
            .TfLiteOpaqueContextAddTensor
            .as_ref()
            .expect("Expected function, got error."))(context, builder, new_tensor_index)
    }
    #[doc = " Populates the size in bytes of a provide 'type' into 'bytes'.  Returns\n 'kTfLiteOk' for valid types, and 'kTfLiteError' otherwise."]
    pub unsafe fn TfLiteOpaqueContextGetSizeOfType(
        &self,
        context: *mut TfLiteOpaqueContext,
        type_: TfLiteType,
        bytes: *mut usize,
    ) -> TfLiteStatus {
        (self
            .TfLiteOpaqueContextGetSizeOfType
            .as_ref()
            .expect("Expected function, got error."))(context, type_, bytes)
    }
    #[doc = " Retrieves named metadata buffer from the TFLite model.\n Returns kTfLiteOk if metadata is successfully obtained from the flatbuffer\n model. That is, there exists a `metadata` entry with given `name` string.\n (see TFLite's schema.fbs).\n The corresponding `buffer` information is populated in `ptr` & `bytes`.\n The data from `ptr` is valid for the lifetime of the Interpreter."]
    pub unsafe fn TfLiteOpaqueContextGetMetadata(
        &self,
        context: *mut TfLiteOpaqueContext,
        name: *const ::std::os::raw::c_char,
        ptr: *mut *const ::std::os::raw::c_char,
        bytes: *mut usize,
    ) -> TfLiteStatus {
        (self
            .TfLiteOpaqueContextGetMetadata
            .as_ref()
            .expect("Expected function, got error."))(context, name, ptr, bytes)
    }
    #[doc = " Same as `TfLiteOpaqueContextReportError`, but with the variable arguments\n passed via a `va_list` instead of directly.\n\n Callers that receive an ellipsis and want to forward it to\n to the opaque context error reporting API can add the ellipsis content to a\n `va_list` and then call `TfLiteOpaqueContextReportErrorVa`. E.g.:\n\n\n     void MyErrorReporter(struct TfLiteOpaqueContext* opaque_context,\n                                      const char* format, ...) {\n       va_list vlist;\n       va_start(vlist, format);\n       TfLiteOpaqueContextReportErrorVa(opaque_context, format, vlist);\n       va_end(vlist);\n     }"]
    pub unsafe fn TfLiteOpaqueContextReportErrorVa(
        &self,
        opaque_context: *mut TfLiteOpaqueContext,
        format: *const ::std::os::raw::c_char,
        vlist: *mut __va_list_tag,
    ) {
        (self
            .TfLiteOpaqueContextReportErrorVa
            .as_ref()
            .expect("Expected function, got error."))(opaque_context, format, vlist)
    }
}
