/* automatically generated by rust-bindgen 0.69.4 */

pub type va_list = __builtin_va_list;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinAdd: TfLiteBuiltinOperator = 0;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinAveragePool2d: TfLiteBuiltinOperator = 1;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinConcatenation: TfLiteBuiltinOperator = 2;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinConv2d: TfLiteBuiltinOperator = 3;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinDepthwiseConv2d: TfLiteBuiltinOperator = 4;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinDepthToSpace: TfLiteBuiltinOperator = 5;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinDequantize: TfLiteBuiltinOperator = 6;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinEmbeddingLookup: TfLiteBuiltinOperator = 7;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinFloor: TfLiteBuiltinOperator = 8;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinFullyConnected: TfLiteBuiltinOperator = 9;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinHashtableLookup: TfLiteBuiltinOperator = 10;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinL2Normalization: TfLiteBuiltinOperator = 11;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinL2Pool2d: TfLiteBuiltinOperator = 12;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinLocalResponseNormalization: TfLiteBuiltinOperator =
    13;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinLogistic: TfLiteBuiltinOperator = 14;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinLshProjection: TfLiteBuiltinOperator = 15;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinLstm: TfLiteBuiltinOperator = 16;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinMaxPool2d: TfLiteBuiltinOperator = 17;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinMul: TfLiteBuiltinOperator = 18;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinRelu: TfLiteBuiltinOperator = 19;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinReluN1To1: TfLiteBuiltinOperator = 20;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinRelu6: TfLiteBuiltinOperator = 21;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinReshape: TfLiteBuiltinOperator = 22;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinResizeBilinear: TfLiteBuiltinOperator = 23;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinRnn: TfLiteBuiltinOperator = 24;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSoftmax: TfLiteBuiltinOperator = 25;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSpaceToDepth: TfLiteBuiltinOperator = 26;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSvdf: TfLiteBuiltinOperator = 27;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinTanh: TfLiteBuiltinOperator = 28;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinConcatEmbeddings: TfLiteBuiltinOperator = 29;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSkipGram: TfLiteBuiltinOperator = 30;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinCall: TfLiteBuiltinOperator = 31;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinCustom: TfLiteBuiltinOperator = 32;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinEmbeddingLookupSparse: TfLiteBuiltinOperator = 33;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinPad: TfLiteBuiltinOperator = 34;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinUnidirectionalSequenceRnn: TfLiteBuiltinOperator = 35;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinGather: TfLiteBuiltinOperator = 36;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinBatchToSpaceNd: TfLiteBuiltinOperator = 37;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSpaceToBatchNd: TfLiteBuiltinOperator = 38;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinTranspose: TfLiteBuiltinOperator = 39;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinMean: TfLiteBuiltinOperator = 40;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSub: TfLiteBuiltinOperator = 41;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinDiv: TfLiteBuiltinOperator = 42;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSqueeze: TfLiteBuiltinOperator = 43;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinUnidirectionalSequenceLstm: TfLiteBuiltinOperator =
    44;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStridedSlice: TfLiteBuiltinOperator = 45;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinBidirectionalSequenceRnn: TfLiteBuiltinOperator = 46;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinExp: TfLiteBuiltinOperator = 47;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinTopkV2: TfLiteBuiltinOperator = 48;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSplit: TfLiteBuiltinOperator = 49;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinLogSoftmax: TfLiteBuiltinOperator = 50;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinDelegate: TfLiteBuiltinOperator = 51;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinBidirectionalSequenceLstm: TfLiteBuiltinOperator = 52;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinCast: TfLiteBuiltinOperator = 53;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinPrelu: TfLiteBuiltinOperator = 54;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinMaximum: TfLiteBuiltinOperator = 55;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinArgMax: TfLiteBuiltinOperator = 56;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinMinimum: TfLiteBuiltinOperator = 57;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinLess: TfLiteBuiltinOperator = 58;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinNeg: TfLiteBuiltinOperator = 59;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinPadv2: TfLiteBuiltinOperator = 60;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinGreater: TfLiteBuiltinOperator = 61;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinGreaterEqual: TfLiteBuiltinOperator = 62;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinLessEqual: TfLiteBuiltinOperator = 63;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSelect: TfLiteBuiltinOperator = 64;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSlice: TfLiteBuiltinOperator = 65;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSin: TfLiteBuiltinOperator = 66;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinTransposeConv: TfLiteBuiltinOperator = 67;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSparseToDense: TfLiteBuiltinOperator = 68;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinTile: TfLiteBuiltinOperator = 69;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinExpandDims: TfLiteBuiltinOperator = 70;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinEqual: TfLiteBuiltinOperator = 71;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinNotEqual: TfLiteBuiltinOperator = 72;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinLog: TfLiteBuiltinOperator = 73;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSum: TfLiteBuiltinOperator = 74;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSqrt: TfLiteBuiltinOperator = 75;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinRsqrt: TfLiteBuiltinOperator = 76;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinShape: TfLiteBuiltinOperator = 77;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinPow: TfLiteBuiltinOperator = 78;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinArgMin: TfLiteBuiltinOperator = 79;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinFakeQuant: TfLiteBuiltinOperator = 80;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinReduceProd: TfLiteBuiltinOperator = 81;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinReduceMax: TfLiteBuiltinOperator = 82;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinPack: TfLiteBuiltinOperator = 83;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinLogicalOr: TfLiteBuiltinOperator = 84;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinOneHot: TfLiteBuiltinOperator = 85;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinLogicalAnd: TfLiteBuiltinOperator = 86;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinLogicalNot: TfLiteBuiltinOperator = 87;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinUnpack: TfLiteBuiltinOperator = 88;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinReduceMin: TfLiteBuiltinOperator = 89;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinFloorDiv: TfLiteBuiltinOperator = 90;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinReduceAny: TfLiteBuiltinOperator = 91;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSquare: TfLiteBuiltinOperator = 92;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinZerosLike: TfLiteBuiltinOperator = 93;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinFill: TfLiteBuiltinOperator = 94;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinFloorMod: TfLiteBuiltinOperator = 95;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinRange: TfLiteBuiltinOperator = 96;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinResizeNearestNeighbor: TfLiteBuiltinOperator = 97;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinLeakyRelu: TfLiteBuiltinOperator = 98;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSquaredDifference: TfLiteBuiltinOperator = 99;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinMirrorPad: TfLiteBuiltinOperator = 100;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinAbs: TfLiteBuiltinOperator = 101;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSplitV: TfLiteBuiltinOperator = 102;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinUnique: TfLiteBuiltinOperator = 103;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinCeil: TfLiteBuiltinOperator = 104;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinReverseV2: TfLiteBuiltinOperator = 105;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinAddN: TfLiteBuiltinOperator = 106;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinGatherNd: TfLiteBuiltinOperator = 107;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinCos: TfLiteBuiltinOperator = 108;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinWhere: TfLiteBuiltinOperator = 109;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinRank: TfLiteBuiltinOperator = 110;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinElu: TfLiteBuiltinOperator = 111;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinReverseSequence: TfLiteBuiltinOperator = 112;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinMatrixDiag: TfLiteBuiltinOperator = 113;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinQuantize: TfLiteBuiltinOperator = 114;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinMatrixSetDiag: TfLiteBuiltinOperator = 115;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinRound: TfLiteBuiltinOperator = 116;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinHardSwish: TfLiteBuiltinOperator = 117;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinIf: TfLiteBuiltinOperator = 118;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinWhile: TfLiteBuiltinOperator = 119;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinNonMaxSuppressionV4: TfLiteBuiltinOperator = 120;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinNonMaxSuppressionV5: TfLiteBuiltinOperator = 121;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinScatterNd: TfLiteBuiltinOperator = 122;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSelectV2: TfLiteBuiltinOperator = 123;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinDensify: TfLiteBuiltinOperator = 124;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSegmentSum: TfLiteBuiltinOperator = 125;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinBatchMatmul: TfLiteBuiltinOperator = 126;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinPlaceholderForGreaterOpCodes: TfLiteBuiltinOperator =
    127;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinCumsum: TfLiteBuiltinOperator = 128;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinCallOnce: TfLiteBuiltinOperator = 129;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinBroadcastTo: TfLiteBuiltinOperator = 130;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinRfft2d: TfLiteBuiltinOperator = 131;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinConv3d: TfLiteBuiltinOperator = 132;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinImag: TfLiteBuiltinOperator = 133;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinReal: TfLiteBuiltinOperator = 134;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinComplexAbs: TfLiteBuiltinOperator = 135;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinHashtable: TfLiteBuiltinOperator = 136;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinHashtableFind: TfLiteBuiltinOperator = 137;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinHashtableImport: TfLiteBuiltinOperator = 138;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinHashtableSize: TfLiteBuiltinOperator = 139;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinReduceAll: TfLiteBuiltinOperator = 140;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinConv3dTranspose: TfLiteBuiltinOperator = 141;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinVarHandle: TfLiteBuiltinOperator = 142;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinReadVariable: TfLiteBuiltinOperator = 143;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinAssignVariable: TfLiteBuiltinOperator = 144;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinBroadcastArgs: TfLiteBuiltinOperator = 145;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinRandomStandardNormal: TfLiteBuiltinOperator = 146;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinBucketize: TfLiteBuiltinOperator = 147;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinRandomUniform: TfLiteBuiltinOperator = 148;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinMultinomial: TfLiteBuiltinOperator = 149;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinGelu: TfLiteBuiltinOperator = 150;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinDynamicUpdateSlice: TfLiteBuiltinOperator = 151;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinRelu0To1: TfLiteBuiltinOperator = 152;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinUnsortedSegmentProd: TfLiteBuiltinOperator = 153;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinUnsortedSegmentMax: TfLiteBuiltinOperator = 154;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinUnsortedSegmentSum: TfLiteBuiltinOperator = 155;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinAtan2: TfLiteBuiltinOperator = 156;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinUnsortedSegmentMin: TfLiteBuiltinOperator = 157;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinSign: TfLiteBuiltinOperator = 158;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinBitcast: TfLiteBuiltinOperator = 159;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinBitwiseXor: TfLiteBuiltinOperator = 160;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinRightShift: TfLiteBuiltinOperator = 161;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloLogistic: TfLiteBuiltinOperator = 162;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloAdd: TfLiteBuiltinOperator = 163;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloDivide: TfLiteBuiltinOperator = 164;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloMultiply: TfLiteBuiltinOperator = 165;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloMaximum: TfLiteBuiltinOperator = 166;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloReshape: TfLiteBuiltinOperator = 167;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloClamp: TfLiteBuiltinOperator = 168;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloConcatenate: TfLiteBuiltinOperator = 169;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloBroadcastInDim: TfLiteBuiltinOperator = 170;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloConvolution: TfLiteBuiltinOperator = 171;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloSlice: TfLiteBuiltinOperator = 172;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloCustomCall: TfLiteBuiltinOperator = 173;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloReduce: TfLiteBuiltinOperator = 174;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloAbs: TfLiteBuiltinOperator = 175;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloAnd: TfLiteBuiltinOperator = 176;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloCosine: TfLiteBuiltinOperator = 177;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloExponential: TfLiteBuiltinOperator = 178;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloFloor: TfLiteBuiltinOperator = 179;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloLog: TfLiteBuiltinOperator = 180;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloMinimum: TfLiteBuiltinOperator = 181;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloNegate: TfLiteBuiltinOperator = 182;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloOr: TfLiteBuiltinOperator = 183;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloPower: TfLiteBuiltinOperator = 184;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloRemainder: TfLiteBuiltinOperator = 185;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloRsqrt: TfLiteBuiltinOperator = 186;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloSelect: TfLiteBuiltinOperator = 187;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloSubtract: TfLiteBuiltinOperator = 188;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloTanh: TfLiteBuiltinOperator = 189;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloScatter: TfLiteBuiltinOperator = 190;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloCompare: TfLiteBuiltinOperator = 191;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloConvert: TfLiteBuiltinOperator = 192;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloDynamicSlice: TfLiteBuiltinOperator = 193;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloDynamicUpdateSlice: TfLiteBuiltinOperator =
    194;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloPad: TfLiteBuiltinOperator = 195;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloIota: TfLiteBuiltinOperator = 196;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloDotGeneral: TfLiteBuiltinOperator = 197;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloReduceWindow: TfLiteBuiltinOperator = 198;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloSort: TfLiteBuiltinOperator = 199;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloWhile: TfLiteBuiltinOperator = 200;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloGather: TfLiteBuiltinOperator = 201;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloTranspose: TfLiteBuiltinOperator = 202;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinDilate: TfLiteBuiltinOperator = 203;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloRngBitGenerator: TfLiteBuiltinOperator = 204;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinReduceWindow: TfLiteBuiltinOperator = 205;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloComposite: TfLiteBuiltinOperator = 206;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloShiftLeft: TfLiteBuiltinOperator = 207;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloCbrt: TfLiteBuiltinOperator = 208;
pub const TfLiteBuiltinOperator_kTfLiteBuiltinStablehloCase: TfLiteBuiltinOperator = 209;
pub type TfLiteBuiltinOperator = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteAsyncKernel {
    _unused: [u8; 0],
}
pub const TfLiteType_kTfLiteNoType: TfLiteType = 0;
pub const TfLiteType_kTfLiteFloat32: TfLiteType = 1;
pub const TfLiteType_kTfLiteInt32: TfLiteType = 2;
pub const TfLiteType_kTfLiteUInt8: TfLiteType = 3;
pub const TfLiteType_kTfLiteInt64: TfLiteType = 4;
pub const TfLiteType_kTfLiteString: TfLiteType = 5;
pub const TfLiteType_kTfLiteBool: TfLiteType = 6;
pub const TfLiteType_kTfLiteInt16: TfLiteType = 7;
pub const TfLiteType_kTfLiteComplex64: TfLiteType = 8;
pub const TfLiteType_kTfLiteInt8: TfLiteType = 9;
pub const TfLiteType_kTfLiteFloat16: TfLiteType = 10;
pub const TfLiteType_kTfLiteFloat64: TfLiteType = 11;
pub const TfLiteType_kTfLiteComplex128: TfLiteType = 12;
pub const TfLiteType_kTfLiteUInt64: TfLiteType = 13;
pub const TfLiteType_kTfLiteResource: TfLiteType = 14;
pub const TfLiteType_kTfLiteVariant: TfLiteType = 15;
pub const TfLiteType_kTfLiteUInt32: TfLiteType = 16;
pub const TfLiteType_kTfLiteUInt16: TfLiteType = 17;
pub const TfLiteType_kTfLiteInt4: TfLiteType = 18;
pub const TfLiteType_kTfLiteBFloat16: TfLiteType = 19;
#[doc = " Types supported by tensor"]
pub type TfLiteType = ::std::os::raw::c_uint;
#[doc = " Legacy. Will be deprecated in favor of `TfLiteAffineQuantization`.\n If per-layer quantization is specified this field will still be populated in\n addition to `TfLiteAffineQuantization`.\n Parameters for asymmetric quantization. Quantized values can be converted\n back to float using: `real_value = scale * (quantized_value - zero_point)`"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteQuantizationParams {
    pub scale: f32,
    pub zero_point: i32,
}
#[test]
fn bindgen_test_layout_TfLiteQuantizationParams() {
    const UNINIT: ::std::mem::MaybeUninit<TfLiteQuantizationParams> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TfLiteQuantizationParams>(),
        8usize,
        concat!("Size of: ", stringify!(TfLiteQuantizationParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteQuantizationParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteQuantizationParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteQuantizationParams),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zero_point) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteQuantizationParams),
            "::",
            stringify!(zero_point)
        )
    );
}
#[doc = " Success"]
pub const TfLiteStatus_kTfLiteOk: TfLiteStatus = 0;
#[doc = " Generally referring to an error in the runtime (i.e. interpreter)"]
pub const TfLiteStatus_kTfLiteError: TfLiteStatus = 1;
#[doc = " Generally referring to an error from a TfLiteDelegate itself."]
pub const TfLiteStatus_kTfLiteDelegateError: TfLiteStatus = 2;
#[doc = " Generally referring to an error in applying a delegate due to\n incompatibility between runtime and delegate, e.g., this error is returned\n when trying to apply a TF Lite delegate onto a model graph that's already\n immutable."]
pub const TfLiteStatus_kTfLiteApplicationError: TfLiteStatus = 3;
#[doc = " Generally referring to serialized delegate data not being found.\n See tflite::delegates::Serialization."]
pub const TfLiteStatus_kTfLiteDelegateDataNotFound: TfLiteStatus = 4;
#[doc = " Generally referring to data-writing issues in delegate serialization.\n See tflite::delegates::Serialization."]
pub const TfLiteStatus_kTfLiteDelegateDataWriteError: TfLiteStatus = 5;
#[doc = " Generally referring to data-reading issues in delegate serialization.\n See tflite::delegates::Serialization."]
pub const TfLiteStatus_kTfLiteDelegateDataReadError: TfLiteStatus = 6;
#[doc = " Generally referring to issues when the TF Lite model has ops that cannot\n be resolved at runtime. This could happen when the specific op is not\n registered or built with the TF Lite framework."]
pub const TfLiteStatus_kTfLiteUnresolvedOps: TfLiteStatus = 7;
#[doc = " Generally referring to invocation cancelled by the user.\n See `interpreter::Cancel`."]
pub const TfLiteStatus_kTfLiteCancelled: TfLiteStatus = 8;
#[doc = " Generally referring to invocation cancelled by the user.\n See `interpreter::Cancel`."]
pub const TfLiteStatus_kTfLiteOutputShapeNotKnown: TfLiteStatus = 9;
#[doc = " Note that new error status values may be added in future in order to\n indicate more fine-grained internal states, therefore, applications should\n not rely on status values being members of the enum."]
pub type TfLiteStatus = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteOpaqueContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteOpaqueNode {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteDelegate {
    _unused: [u8; 0],
}
pub type TfLiteOpaqueDelegate = TfLiteDelegate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteOperator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteModel {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteInterpreterOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteInterpreter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteTensor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteSignatureRunner {
    _unused: [u8; 0],
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
extern crate libloading;
pub struct tensorflowlite_c {
    __library: ::libloading::Library,
    pub TfLiteOperatorCreate: Result<
        unsafe extern "C" fn(
            builtin_code: TfLiteBuiltinOperator,
            custom_name: *const ::std::os::raw::c_char,
            version: ::std::os::raw::c_int,
            user_data: *mut ::std::os::raw::c_void,
        ) -> *mut TfLiteOperator,
        ::libloading::Error,
    >,
    pub TfLiteOperatorDelete:
        Result<unsafe extern "C" fn(registration: *mut TfLiteOperator), ::libloading::Error>,
    pub TfLiteOperatorGetBuiltInCode: Result<
        unsafe extern "C" fn(registration: *const TfLiteOperator) -> TfLiteBuiltinOperator,
        ::libloading::Error,
    >,
    pub TfLiteOperatorGetCustomName: Result<
        unsafe extern "C" fn(registration: *const TfLiteOperator) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub TfLiteOperatorGetVersion: Result<
        unsafe extern "C" fn(registration: *const TfLiteOperator) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub TfLiteOperatorGetUserData: Result<
        unsafe extern "C" fn(registration: *const TfLiteOperator) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub TfLiteOperatorSetInit: Result<
        unsafe extern "C" fn(
            registration: *mut TfLiteOperator,
            init: ::std::option::Option<
                unsafe extern "C" fn(
                    context: *mut TfLiteOpaqueContext,
                    buffer: *const ::std::os::raw::c_char,
                    length: usize,
                ) -> *mut ::std::os::raw::c_void,
            >,
        ),
        ::libloading::Error,
    >,
    pub TfLiteOperatorSetInitWithData: Result<
        unsafe extern "C" fn(
            registration: *mut TfLiteOperator,
            init: ::std::option::Option<
                unsafe extern "C" fn(
                    user_data: *mut ::std::os::raw::c_void,
                    context: *mut TfLiteOpaqueContext,
                    buffer: *const ::std::os::raw::c_char,
                    length: usize,
                ) -> *mut ::std::os::raw::c_void,
            >,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOperatorSetFree: Result<
        unsafe extern "C" fn(
            registration: *mut TfLiteOperator,
            free: ::std::option::Option<
                unsafe extern "C" fn(
                    context: *mut TfLiteOpaqueContext,
                    data: *mut ::std::os::raw::c_void,
                ),
            >,
        ),
        ::libloading::Error,
    >,
    pub TfLiteOperatorSetFreeWithData: Result<
        unsafe extern "C" fn(
            registration: *mut TfLiteOperator,
            free: ::std::option::Option<
                unsafe extern "C" fn(
                    user_data: *mut ::std::os::raw::c_void,
                    context: *mut TfLiteOpaqueContext,
                    data: *mut ::std::os::raw::c_void,
                ),
            >,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOperatorSetPrepare: Result<
        unsafe extern "C" fn(
            registration: *mut TfLiteOperator,
            prepare: ::std::option::Option<
                unsafe extern "C" fn(
                    context: *mut TfLiteOpaqueContext,
                    node: *mut TfLiteOpaqueNode,
                ) -> TfLiteStatus,
            >,
        ),
        ::libloading::Error,
    >,
    pub TfLiteOperatorSetPrepareWithData: Result<
        unsafe extern "C" fn(
            registration: *mut TfLiteOperator,
            prepare: ::std::option::Option<
                unsafe extern "C" fn(
                    user_data: *mut ::std::os::raw::c_void,
                    context: *mut TfLiteOpaqueContext,
                    node: *mut TfLiteOpaqueNode,
                ) -> TfLiteStatus,
            >,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOperatorSetInvoke: Result<
        unsafe extern "C" fn(
            registration: *mut TfLiteOperator,
            invoke: ::std::option::Option<
                unsafe extern "C" fn(
                    context: *mut TfLiteOpaqueContext,
                    node: *mut TfLiteOpaqueNode,
                ) -> TfLiteStatus,
            >,
        ),
        ::libloading::Error,
    >,
    pub TfLiteOperatorSetInvokeWithData: Result<
        unsafe extern "C" fn(
            registration: *mut TfLiteOperator,
            invoke: ::std::option::Option<
                unsafe extern "C" fn(
                    user_data: *mut ::std::os::raw::c_void,
                    context: *mut TfLiteOpaqueContext,
                    node: *mut TfLiteOpaqueNode,
                ) -> TfLiteStatus,
            >,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOperatorSetAsyncKernel: Result<
        unsafe extern "C" fn(
            registration: *mut TfLiteOperator,
            async_kernel: ::std::option::Option<
                unsafe extern "C" fn(
                    context: *mut TfLiteOpaqueContext,
                    node: *mut TfLiteOpaqueNode,
                ) -> *mut TfLiteAsyncKernel,
            >,
        ),
        ::libloading::Error,
    >,
    pub TfLiteOperatorSetAsyncKernelWithData: Result<
        unsafe extern "C" fn(
            registration: *mut TfLiteOperator,
            async_kernel: ::std::option::Option<
                unsafe extern "C" fn(
                    user_data: *mut ::std::os::raw::c_void,
                    context: *mut TfLiteOpaqueContext,
                    node: *mut TfLiteOpaqueNode,
                ) -> *mut TfLiteAsyncKernel,
            >,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteOperatorSetInplaceOperator: Result<
        unsafe extern "C" fn(registration: *mut TfLiteOperator, inplace_operator: u64),
        ::libloading::Error,
    >,
    pub TfLiteVersion:
        Result<unsafe extern "C" fn() -> *const ::std::os::raw::c_char, ::libloading::Error>,
    pub TfLiteExtensionApisVersion:
        Result<unsafe extern "C" fn() -> *const ::std::os::raw::c_char, ::libloading::Error>,
    pub TfLiteSchemaVersion:
        Result<unsafe extern "C" fn() -> ::std::os::raw::c_int, ::libloading::Error>,
    pub TfLiteModelCreate: Result<
        unsafe extern "C" fn(
            model_data: *const ::std::os::raw::c_void,
            model_size: usize,
        ) -> *mut TfLiteModel,
        ::libloading::Error,
    >,
    pub TfLiteModelCreateWithErrorReporter: Result<
        unsafe extern "C" fn(
            model_data: *const ::std::os::raw::c_void,
            model_size: usize,
            reporter: ::std::option::Option<
                unsafe extern "C" fn(
                    user_data: *mut ::std::os::raw::c_void,
                    format: *const ::std::os::raw::c_char,
                    args: *mut __va_list_tag,
                ),
            >,
            user_data: *mut ::std::os::raw::c_void,
        ) -> *mut TfLiteModel,
        ::libloading::Error,
    >,
    pub TfLiteModelCreateFromFile: Result<
        unsafe extern "C" fn(model_path: *const ::std::os::raw::c_char) -> *mut TfLiteModel,
        ::libloading::Error,
    >,
    pub TfLiteModelCreateFromFileWithErrorReporter: Result<
        unsafe extern "C" fn(
            model_path: *const ::std::os::raw::c_char,
            reporter: ::std::option::Option<
                unsafe extern "C" fn(
                    user_data: *mut ::std::os::raw::c_void,
                    format: *const ::std::os::raw::c_char,
                    args: *mut __va_list_tag,
                ),
            >,
            user_data: *mut ::std::os::raw::c_void,
        ) -> *mut TfLiteModel,
        ::libloading::Error,
    >,
    pub TfLiteModelDelete:
        Result<unsafe extern "C" fn(model: *mut TfLiteModel), ::libloading::Error>,
    pub TfLiteInterpreterOptionsCreate:
        Result<unsafe extern "C" fn() -> *mut TfLiteInterpreterOptions, ::libloading::Error>,
    pub TfLiteInterpreterOptionsCopy: Result<
        unsafe extern "C" fn(
            from: *const TfLiteInterpreterOptions,
        ) -> *mut TfLiteInterpreterOptions,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterOptionsDelete:
        Result<unsafe extern "C" fn(options: *mut TfLiteInterpreterOptions), ::libloading::Error>,
    pub TfLiteInterpreterOptionsSetNumThreads: Result<
        unsafe extern "C" fn(options: *mut TfLiteInterpreterOptions, num_threads: i32),
        ::libloading::Error,
    >,
    pub TfLiteInterpreterOptionsAddDelegate: Result<
        unsafe extern "C" fn(
            options: *mut TfLiteInterpreterOptions,
            delegate: *mut TfLiteOpaqueDelegate,
        ),
        ::libloading::Error,
    >,
    pub TfLiteInterpreterOptionsSetErrorReporter: Result<
        unsafe extern "C" fn(
            options: *mut TfLiteInterpreterOptions,
            reporter: ::std::option::Option<
                unsafe extern "C" fn(
                    user_data: *mut ::std::os::raw::c_void,
                    format: *const ::std::os::raw::c_char,
                    args: *mut __va_list_tag,
                ),
            >,
            user_data: *mut ::std::os::raw::c_void,
        ),
        ::libloading::Error,
    >,
    pub TfLiteInterpreterOptionsAddOperator: Result<
        unsafe extern "C" fn(
            options: *mut TfLiteInterpreterOptions,
            registration: *mut TfLiteOperator,
        ),
        ::libloading::Error,
    >,
    pub TfLiteInterpreterOptionsEnableCancellation: Result<
        unsafe extern "C" fn(options: *mut TfLiteInterpreterOptions, enable: bool) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterCreate: Result<
        unsafe extern "C" fn(
            model: *const TfLiteModel,
            optional_options: *const TfLiteInterpreterOptions,
        ) -> *mut TfLiteInterpreter,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterDelete:
        Result<unsafe extern "C" fn(interpreter: *mut TfLiteInterpreter), ::libloading::Error>,
    pub TfLiteInterpreterGetInputTensorCount: Result<
        unsafe extern "C" fn(interpreter: *const TfLiteInterpreter) -> i32,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterInputTensorIndices: Result<
        unsafe extern "C" fn(interpreter: *const TfLiteInterpreter) -> *const ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterGetInputTensor: Result<
        unsafe extern "C" fn(
            interpreter: *const TfLiteInterpreter,
            input_index: i32,
        ) -> *mut TfLiteTensor,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterResizeInputTensor: Result<
        unsafe extern "C" fn(
            interpreter: *mut TfLiteInterpreter,
            input_index: i32,
            input_dims: *const ::std::os::raw::c_int,
            input_dims_size: i32,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterAllocateTensors: Result<
        unsafe extern "C" fn(interpreter: *mut TfLiteInterpreter) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterInvoke: Result<
        unsafe extern "C" fn(interpreter: *mut TfLiteInterpreter) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterGetOutputTensorCount: Result<
        unsafe extern "C" fn(interpreter: *const TfLiteInterpreter) -> i32,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterOutputTensorIndices: Result<
        unsafe extern "C" fn(interpreter: *const TfLiteInterpreter) -> *const ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterGetOutputTensor: Result<
        unsafe extern "C" fn(
            interpreter: *const TfLiteInterpreter,
            output_index: i32,
        ) -> *const TfLiteTensor,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterGetTensor: Result<
        unsafe extern "C" fn(
            interpreter: *const TfLiteInterpreter,
            index: ::std::os::raw::c_int,
        ) -> *mut TfLiteTensor,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterCancel: Result<
        unsafe extern "C" fn(interpreter: *const TfLiteInterpreter) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterGetSignatureCount: Result<
        unsafe extern "C" fn(interpreter: *const TfLiteInterpreter) -> i32,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterGetSignatureKey: Result<
        unsafe extern "C" fn(
            interpreter: *const TfLiteInterpreter,
            signature_index: i32,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub TfLiteInterpreterGetSignatureRunner: Result<
        unsafe extern "C" fn(
            interpreter: *const TfLiteInterpreter,
            signature_key: *const ::std::os::raw::c_char,
        ) -> *mut TfLiteSignatureRunner,
        ::libloading::Error,
    >,
    pub TfLiteSignatureRunnerGetInputCount: Result<
        unsafe extern "C" fn(signature_runner: *const TfLiteSignatureRunner) -> usize,
        ::libloading::Error,
    >,
    pub TfLiteSignatureRunnerGetInputName: Result<
        unsafe extern "C" fn(
            signature_runner: *const TfLiteSignatureRunner,
            input_index: i32,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub TfLiteSignatureRunnerResizeInputTensor: Result<
        unsafe extern "C" fn(
            signature_runner: *mut TfLiteSignatureRunner,
            input_name: *const ::std::os::raw::c_char,
            input_dims: *const ::std::os::raw::c_int,
            input_dims_size: i32,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteSignatureRunnerAllocateTensors: Result<
        unsafe extern "C" fn(signature_runner: *mut TfLiteSignatureRunner) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteSignatureRunnerGetInputTensor: Result<
        unsafe extern "C" fn(
            signature_runner: *mut TfLiteSignatureRunner,
            input_name: *const ::std::os::raw::c_char,
        ) -> *mut TfLiteTensor,
        ::libloading::Error,
    >,
    pub TfLiteSignatureRunnerInvoke: Result<
        unsafe extern "C" fn(signature_runner: *mut TfLiteSignatureRunner) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteSignatureRunnerGetOutputCount: Result<
        unsafe extern "C" fn(signature_runner: *const TfLiteSignatureRunner) -> usize,
        ::libloading::Error,
    >,
    pub TfLiteSignatureRunnerGetOutputName: Result<
        unsafe extern "C" fn(
            signature_runner: *const TfLiteSignatureRunner,
            output_index: i32,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub TfLiteSignatureRunnerGetOutputTensor: Result<
        unsafe extern "C" fn(
            signature_runner: *const TfLiteSignatureRunner,
            output_name: *const ::std::os::raw::c_char,
        ) -> *const TfLiteTensor,
        ::libloading::Error,
    >,
    pub TfLiteTensorType: Result<
        unsafe extern "C" fn(tensor: *const TfLiteTensor) -> TfLiteType,
        ::libloading::Error,
    >,
    pub TfLiteTensorNumDims:
        Result<unsafe extern "C" fn(tensor: *const TfLiteTensor) -> i32, ::libloading::Error>,
    pub TfLiteTensorDim: Result<
        unsafe extern "C" fn(tensor: *const TfLiteTensor, dim_index: i32) -> i32,
        ::libloading::Error,
    >,
    pub TfLiteTensorByteSize:
        Result<unsafe extern "C" fn(tensor: *const TfLiteTensor) -> usize, ::libloading::Error>,
    pub TfLiteTensorData: Result<
        unsafe extern "C" fn(tensor: *const TfLiteTensor) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub TfLiteTensorName: Result<
        unsafe extern "C" fn(tensor: *const TfLiteTensor) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub TfLiteTensorQuantizationParams: Result<
        unsafe extern "C" fn(tensor: *const TfLiteTensor) -> TfLiteQuantizationParams,
        ::libloading::Error,
    >,
    pub TfLiteTensorCopyFromBuffer: Result<
        unsafe extern "C" fn(
            tensor: *mut TfLiteTensor,
            input_data: *const ::std::os::raw::c_void,
            input_data_size: usize,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteTensorCopyToBuffer: Result<
        unsafe extern "C" fn(
            output_tensor: *const TfLiteTensor,
            output_data: *mut ::std::os::raw::c_void,
            output_data_size: usize,
        ) -> TfLiteStatus,
        ::libloading::Error,
    >,
    pub TfLiteSignatureRunnerDelete: Result<
        unsafe extern "C" fn(signature_runner: *mut TfLiteSignatureRunner),
        ::libloading::Error,
    >,
}
impl tensorflowlite_c {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }

    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let TfLiteOperatorCreate = __library.get(b"TfLiteOperatorCreate\0").map(|sym| *sym);
        let TfLiteOperatorDelete = __library.get(b"TfLiteOperatorDelete\0").map(|sym| *sym);
        let TfLiteOperatorGetBuiltInCode = __library
            .get(b"TfLiteOperatorGetBuiltInCode\0")
            .map(|sym| *sym);
        let TfLiteOperatorGetCustomName = __library
            .get(b"TfLiteOperatorGetCustomName\0")
            .map(|sym| *sym);
        let TfLiteOperatorGetVersion = __library.get(b"TfLiteOperatorGetVersion\0").map(|sym| *sym);
        let TfLiteOperatorGetUserData = __library
            .get(b"TfLiteOperatorGetUserData\0")
            .map(|sym| *sym);
        let TfLiteOperatorSetInit = __library.get(b"TfLiteOperatorSetInit\0").map(|sym| *sym);
        let TfLiteOperatorSetInitWithData = __library
            .get(b"TfLiteOperatorSetInitWithData\0")
            .map(|sym| *sym);
        let TfLiteOperatorSetFree = __library.get(b"TfLiteOperatorSetFree\0").map(|sym| *sym);
        let TfLiteOperatorSetFreeWithData = __library
            .get(b"TfLiteOperatorSetFreeWithData\0")
            .map(|sym| *sym);
        let TfLiteOperatorSetPrepare = __library.get(b"TfLiteOperatorSetPrepare\0").map(|sym| *sym);
        let TfLiteOperatorSetPrepareWithData = __library
            .get(b"TfLiteOperatorSetPrepareWithData\0")
            .map(|sym| *sym);
        let TfLiteOperatorSetInvoke = __library.get(b"TfLiteOperatorSetInvoke\0").map(|sym| *sym);
        let TfLiteOperatorSetInvokeWithData = __library
            .get(b"TfLiteOperatorSetInvokeWithData\0")
            .map(|sym| *sym);
        let TfLiteOperatorSetAsyncKernel = __library
            .get(b"TfLiteOperatorSetAsyncKernel\0")
            .map(|sym| *sym);
        let TfLiteOperatorSetAsyncKernelWithData = __library
            .get(b"TfLiteOperatorSetAsyncKernelWithData\0")
            .map(|sym| *sym);
        let TfLiteOperatorSetInplaceOperator = __library
            .get(b"TfLiteOperatorSetInplaceOperator\0")
            .map(|sym| *sym);
        let TfLiteVersion = __library.get(b"TfLiteVersion\0").map(|sym| *sym);
        let TfLiteExtensionApisVersion = __library
            .get(b"TfLiteExtensionApisVersion\0")
            .map(|sym| *sym);
        let TfLiteSchemaVersion = __library.get(b"TfLiteSchemaVersion\0").map(|sym| *sym);
        let TfLiteModelCreate = __library.get(b"TfLiteModelCreate\0").map(|sym| *sym);
        let TfLiteModelCreateWithErrorReporter = __library
            .get(b"TfLiteModelCreateWithErrorReporter\0")
            .map(|sym| *sym);
        let TfLiteModelCreateFromFile = __library
            .get(b"TfLiteModelCreateFromFile\0")
            .map(|sym| *sym);
        let TfLiteModelCreateFromFileWithErrorReporter = __library
            .get(b"TfLiteModelCreateFromFileWithErrorReporter\0")
            .map(|sym| *sym);
        let TfLiteModelDelete = __library.get(b"TfLiteModelDelete\0").map(|sym| *sym);
        let TfLiteInterpreterOptionsCreate = __library
            .get(b"TfLiteInterpreterOptionsCreate\0")
            .map(|sym| *sym);
        let TfLiteInterpreterOptionsCopy = __library
            .get(b"TfLiteInterpreterOptionsCopy\0")
            .map(|sym| *sym);
        let TfLiteInterpreterOptionsDelete = __library
            .get(b"TfLiteInterpreterOptionsDelete\0")
            .map(|sym| *sym);
        let TfLiteInterpreterOptionsSetNumThreads = __library
            .get(b"TfLiteInterpreterOptionsSetNumThreads\0")
            .map(|sym| *sym);
        let TfLiteInterpreterOptionsAddDelegate = __library
            .get(b"TfLiteInterpreterOptionsAddDelegate\0")
            .map(|sym| *sym);
        let TfLiteInterpreterOptionsSetErrorReporter = __library
            .get(b"TfLiteInterpreterOptionsSetErrorReporter\0")
            .map(|sym| *sym);
        let TfLiteInterpreterOptionsAddOperator = __library
            .get(b"TfLiteInterpreterOptionsAddOperator\0")
            .map(|sym| *sym);
        let TfLiteInterpreterOptionsEnableCancellation = __library
            .get(b"TfLiteInterpreterOptionsEnableCancellation\0")
            .map(|sym| *sym);
        let TfLiteInterpreterCreate = __library.get(b"TfLiteInterpreterCreate\0").map(|sym| *sym);
        let TfLiteInterpreterDelete = __library.get(b"TfLiteInterpreterDelete\0").map(|sym| *sym);
        let TfLiteInterpreterGetInputTensorCount = __library
            .get(b"TfLiteInterpreterGetInputTensorCount\0")
            .map(|sym| *sym);
        let TfLiteInterpreterInputTensorIndices = __library
            .get(b"TfLiteInterpreterInputTensorIndices\0")
            .map(|sym| *sym);
        let TfLiteInterpreterGetInputTensor = __library
            .get(b"TfLiteInterpreterGetInputTensor\0")
            .map(|sym| *sym);
        let TfLiteInterpreterResizeInputTensor = __library
            .get(b"TfLiteInterpreterResizeInputTensor\0")
            .map(|sym| *sym);
        let TfLiteInterpreterAllocateTensors = __library
            .get(b"TfLiteInterpreterAllocateTensors\0")
            .map(|sym| *sym);
        let TfLiteInterpreterInvoke = __library.get(b"TfLiteInterpreterInvoke\0").map(|sym| *sym);
        let TfLiteInterpreterGetOutputTensorCount = __library
            .get(b"TfLiteInterpreterGetOutputTensorCount\0")
            .map(|sym| *sym);
        let TfLiteInterpreterOutputTensorIndices = __library
            .get(b"TfLiteInterpreterOutputTensorIndices\0")
            .map(|sym| *sym);
        let TfLiteInterpreterGetOutputTensor = __library
            .get(b"TfLiteInterpreterGetOutputTensor\0")
            .map(|sym| *sym);
        let TfLiteInterpreterGetTensor = __library
            .get(b"TfLiteInterpreterGetTensor\0")
            .map(|sym| *sym);
        let TfLiteInterpreterCancel = __library.get(b"TfLiteInterpreterCancel\0").map(|sym| *sym);
        let TfLiteInterpreterGetSignatureCount = __library
            .get(b"TfLiteInterpreterGetSignatureCount\0")
            .map(|sym| *sym);
        let TfLiteInterpreterGetSignatureKey = __library
            .get(b"TfLiteInterpreterGetSignatureKey\0")
            .map(|sym| *sym);
        let TfLiteInterpreterGetSignatureRunner = __library
            .get(b"TfLiteInterpreterGetSignatureRunner\0")
            .map(|sym| *sym);
        let TfLiteSignatureRunnerGetInputCount = __library
            .get(b"TfLiteSignatureRunnerGetInputCount\0")
            .map(|sym| *sym);
        let TfLiteSignatureRunnerGetInputName = __library
            .get(b"TfLiteSignatureRunnerGetInputName\0")
            .map(|sym| *sym);
        let TfLiteSignatureRunnerResizeInputTensor = __library
            .get(b"TfLiteSignatureRunnerResizeInputTensor\0")
            .map(|sym| *sym);
        let TfLiteSignatureRunnerAllocateTensors = __library
            .get(b"TfLiteSignatureRunnerAllocateTensors\0")
            .map(|sym| *sym);
        let TfLiteSignatureRunnerGetInputTensor = __library
            .get(b"TfLiteSignatureRunnerGetInputTensor\0")
            .map(|sym| *sym);
        let TfLiteSignatureRunnerInvoke = __library
            .get(b"TfLiteSignatureRunnerInvoke\0")
            .map(|sym| *sym);
        let TfLiteSignatureRunnerGetOutputCount = __library
            .get(b"TfLiteSignatureRunnerGetOutputCount\0")
            .map(|sym| *sym);
        let TfLiteSignatureRunnerGetOutputName = __library
            .get(b"TfLiteSignatureRunnerGetOutputName\0")
            .map(|sym| *sym);
        let TfLiteSignatureRunnerGetOutputTensor = __library
            .get(b"TfLiteSignatureRunnerGetOutputTensor\0")
            .map(|sym| *sym);
        let TfLiteTensorType = __library.get(b"TfLiteTensorType\0").map(|sym| *sym);
        let TfLiteTensorNumDims = __library.get(b"TfLiteTensorNumDims\0").map(|sym| *sym);
        let TfLiteTensorDim = __library.get(b"TfLiteTensorDim\0").map(|sym| *sym);
        let TfLiteTensorByteSize = __library.get(b"TfLiteTensorByteSize\0").map(|sym| *sym);
        let TfLiteTensorData = __library.get(b"TfLiteTensorData\0").map(|sym| *sym);
        let TfLiteTensorName = __library.get(b"TfLiteTensorName\0").map(|sym| *sym);
        let TfLiteTensorQuantizationParams = __library
            .get(b"TfLiteTensorQuantizationParams\0")
            .map(|sym| *sym);
        let TfLiteTensorCopyFromBuffer = __library
            .get(b"TfLiteTensorCopyFromBuffer\0")
            .map(|sym| *sym);
        let TfLiteTensorCopyToBuffer = __library.get(b"TfLiteTensorCopyToBuffer\0").map(|sym| *sym);
        let TfLiteSignatureRunnerDelete = __library
            .get(b"TfLiteSignatureRunnerDelete\0")
            .map(|sym| *sym);
        Ok(tensorflowlite_c {
            __library,
            TfLiteOperatorCreate,
            TfLiteOperatorDelete,
            TfLiteOperatorGetBuiltInCode,
            TfLiteOperatorGetCustomName,
            TfLiteOperatorGetVersion,
            TfLiteOperatorGetUserData,
            TfLiteOperatorSetInit,
            TfLiteOperatorSetInitWithData,
            TfLiteOperatorSetFree,
            TfLiteOperatorSetFreeWithData,
            TfLiteOperatorSetPrepare,
            TfLiteOperatorSetPrepareWithData,
            TfLiteOperatorSetInvoke,
            TfLiteOperatorSetInvokeWithData,
            TfLiteOperatorSetAsyncKernel,
            TfLiteOperatorSetAsyncKernelWithData,
            TfLiteOperatorSetInplaceOperator,
            TfLiteVersion,
            TfLiteExtensionApisVersion,
            TfLiteSchemaVersion,
            TfLiteModelCreate,
            TfLiteModelCreateWithErrorReporter,
            TfLiteModelCreateFromFile,
            TfLiteModelCreateFromFileWithErrorReporter,
            TfLiteModelDelete,
            TfLiteInterpreterOptionsCreate,
            TfLiteInterpreterOptionsCopy,
            TfLiteInterpreterOptionsDelete,
            TfLiteInterpreterOptionsSetNumThreads,
            TfLiteInterpreterOptionsAddDelegate,
            TfLiteInterpreterOptionsSetErrorReporter,
            TfLiteInterpreterOptionsAddOperator,
            TfLiteInterpreterOptionsEnableCancellation,
            TfLiteInterpreterCreate,
            TfLiteInterpreterDelete,
            TfLiteInterpreterGetInputTensorCount,
            TfLiteInterpreterInputTensorIndices,
            TfLiteInterpreterGetInputTensor,
            TfLiteInterpreterResizeInputTensor,
            TfLiteInterpreterAllocateTensors,
            TfLiteInterpreterInvoke,
            TfLiteInterpreterGetOutputTensorCount,
            TfLiteInterpreterOutputTensorIndices,
            TfLiteInterpreterGetOutputTensor,
            TfLiteInterpreterGetTensor,
            TfLiteInterpreterCancel,
            TfLiteInterpreterGetSignatureCount,
            TfLiteInterpreterGetSignatureKey,
            TfLiteInterpreterGetSignatureRunner,
            TfLiteSignatureRunnerGetInputCount,
            TfLiteSignatureRunnerGetInputName,
            TfLiteSignatureRunnerResizeInputTensor,
            TfLiteSignatureRunnerAllocateTensors,
            TfLiteSignatureRunnerGetInputTensor,
            TfLiteSignatureRunnerInvoke,
            TfLiteSignatureRunnerGetOutputCount,
            TfLiteSignatureRunnerGetOutputName,
            TfLiteSignatureRunnerGetOutputTensor,
            TfLiteTensorType,
            TfLiteTensorNumDims,
            TfLiteTensorDim,
            TfLiteTensorByteSize,
            TfLiteTensorData,
            TfLiteTensorName,
            TfLiteTensorQuantizationParams,
            TfLiteTensorCopyFromBuffer,
            TfLiteTensorCopyToBuffer,
            TfLiteSignatureRunnerDelete,
        })
    }

    #[doc = " Returns a new TfLiteOperator instance.\n\n The returned TfLiteOperator instance represents a definition\n of an operator with the identity (builtin_code/custom_name and\n version) specified by the parameters, but with all callbacks initially\n unset.\n\n Evaluation of any operation using this operator will be done using\n the \"prepare\" and \"invoke\" callbacks, which can be set using\n `TfLiteOperatorSetPrepare` and\n `TfLiteOperatorSetInvoke`, or for async execution\n the \"prepare\", \"eval\", and \"wait\" callbacks of the `TfLiteAsyncKernel`,\n which can be set using `TfLiteOperatorSetAsyncKernel`.\n If the relevant callbacks are not set, then such evaluation will result\n in an error status.  So normally any use of this function should be followed\n by appropriate calls to set those callbacks.\n\n \\note The caller retains ownership and should ensure that\n the lifetime of the `TfLiteOperator` must be at least as long as\n the lifetime of any `TfLiteInterpreter` or `tflite::Interpreter` that it is\n used in.\n\n \\param builtin_code Enumeration code specifying which builtin operator this\n                     defines, or `TfLiteBuiltinCustom` to define a custom op.\n \\param custom_name  Name of the custom op, or `nullptr` for a builtin op.\n                     If `custom_name` is non-null, then `builtin_code` should\n                     be `TfLiteBuiltinCustom`.\n \\param version      Version of the op.  See\n                     https://www.tensorflow.org/lite/guide/ops_version\n \\param user_data    Opaque pointer passed to the operator's callbacks set\n                     with functions such as `TfLiteOperatorSetXXXWithData`.\n                     The user is expected to manage the memory pointed by\n                     this field and the lifetime of that memory should extend\n                     at least from the call to `TfLiteOperatorCreate`\n                     to the invocation of the callback set with\n                     `TfLiteOperatorSetFreeWithData`.\n\n \\return a newly created TfLiteOperator on success, or a nullptr on failure"]
    pub unsafe fn TfLiteOperatorCreate(
        &self,
        builtin_code: TfLiteBuiltinOperator,
        custom_name: *const ::std::os::raw::c_char,
        version: ::std::os::raw::c_int,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut TfLiteOperator {
        (self
            .TfLiteOperatorCreate
            .as_ref()
            .expect("Expected function, got error."))(
            builtin_code, custom_name, version, user_data
        )
    }

    #[doc = " Destroys the TfLiteOperator instance.\n"]
    pub unsafe fn TfLiteOperatorDelete(&self, registration: *mut TfLiteOperator) {
        (self
            .TfLiteOperatorDelete
            .as_ref()
            .expect("Expected function, got error."))(registration)
    }

    #[doc = " Return the builtin op code of the provided external 'registration'.\n"]
    pub unsafe fn TfLiteOperatorGetBuiltInCode(
        &self,
        registration: *const TfLiteOperator,
    ) -> TfLiteBuiltinOperator {
        (self
            .TfLiteOperatorGetBuiltInCode
            .as_ref()
            .expect("Expected function, got error."))(registration)
    }

    #[doc = " Returns the custom name of the provided 'registration'. The returned pointer\n will be non-null iff the op is a custom op.\n"]
    pub unsafe fn TfLiteOperatorGetCustomName(
        &self,
        registration: *const TfLiteOperator,
    ) -> *const ::std::os::raw::c_char {
        (self
            .TfLiteOperatorGetCustomName
            .as_ref()
            .expect("Expected function, got error."))(registration)
    }

    #[doc = " Return the OP version of the provided external 'registration'.  Return -1\n in case of error, or if the provided address is null.\n"]
    pub unsafe fn TfLiteOperatorGetVersion(
        &self,
        registration: *const TfLiteOperator,
    ) -> ::std::os::raw::c_int {
        (self
            .TfLiteOperatorGetVersion
            .as_ref()
            .expect("Expected function, got error."))(registration)
    }

    #[doc = " Return the user data field of the provided external 'registration', or\n nullptr if none was set.\n"]
    pub unsafe fn TfLiteOperatorGetUserData(
        &self,
        registration: *const TfLiteOperator,
    ) -> *mut ::std::os::raw::c_void {
        (self
            .TfLiteOperatorGetUserData
            .as_ref()
            .expect("Expected function, got error."))(registration)
    }

    #[doc = " Sets the initialization callback for the registration.\n\n The callback is called to initialize the op from serialized data.\n Please refer `init` of `TfLiteRegistration` for the detail.\n\n Deprecated: Use `TfLiteOperatorSetInitWithData`"]
    pub unsafe fn TfLiteOperatorSetInit(
        &self,
        registration: *mut TfLiteOperator,
        init: ::std::option::Option<
            unsafe extern "C" fn(
                context: *mut TfLiteOpaqueContext,
                buffer: *const ::std::os::raw::c_char,
                length: usize,
            ) -> *mut ::std::os::raw::c_void,
        >,
    ) {
        (self
            .TfLiteOperatorSetInit
            .as_ref()
            .expect("Expected function, got error."))(registration, init)
    }

    #[doc = " Sets the initialization callback for the registration. The function returns\n an error upon failure.\n\n The callback is called to initialize the op from serialized data. The value\n passed in the `user_data` parameter is the value that was passed to\n `TfLiteOperatorCreate`.  Please refer `init` of `TfLiteRegistration`\n for the detail.\n"]
    pub unsafe fn TfLiteOperatorSetInitWithData(
        &self,
        registration: *mut TfLiteOperator,
        init: ::std::option::Option<
            unsafe extern "C" fn(
                user_data: *mut ::std::os::raw::c_void,
                context: *mut TfLiteOpaqueContext,
                buffer: *const ::std::os::raw::c_char,
                length: usize,
            ) -> *mut ::std::os::raw::c_void,
        >,
    ) -> TfLiteStatus {
        (self
            .TfLiteOperatorSetInitWithData
            .as_ref()
            .expect("Expected function, got error."))(registration, init)
    }

    #[doc = " Sets the deallocation callback for the registration.\n\n This callback is called to deallocate the data returned by the init\n callback. The value passed in the `data` parameter is the value that was\n returned by the `init` callback. Please refer `free` of `TfLiteRegistration`\n for the detail.\n\n Deprecated: Use `TfLiteOperatorSetFreeWithData`"]
    pub unsafe fn TfLiteOperatorSetFree(
        &self,
        registration: *mut TfLiteOperator,
        free: ::std::option::Option<
            unsafe extern "C" fn(
                context: *mut TfLiteOpaqueContext,
                data: *mut ::std::os::raw::c_void,
            ),
        >,
    ) {
        (self
            .TfLiteOperatorSetFree
            .as_ref()
            .expect("Expected function, got error."))(registration, free)
    }

    #[doc = " Sets the deallocation callback for the registration, similarly to\n `TfLiteOperatorSetFree`. The function returns an error upon failure.\n\n This callback is called to deallocate the data returned by the init\n callback. The value passed in the `data` parameter is the value that was\n returned by the `init` callback. The value passed in the `user_data`\n parameter is the value that was passed to `TfLiteOperatorCreate`.\n Please refer `free` of `TfLiteRegistration` for the detail.\n"]
    pub unsafe fn TfLiteOperatorSetFreeWithData(
        &self,
        registration: *mut TfLiteOperator,
        free: ::std::option::Option<
            unsafe extern "C" fn(
                user_data: *mut ::std::os::raw::c_void,
                context: *mut TfLiteOpaqueContext,
                data: *mut ::std::os::raw::c_void,
            ),
        >,
    ) -> TfLiteStatus {
        (self
            .TfLiteOperatorSetFreeWithData
            .as_ref()
            .expect("Expected function, got error."))(registration, free)
    }

    #[doc = " Sets the preparation callback for the registration.\n\n The callback is called when the inputs of operator have been resized.\n Please refer `prepare` of `TfLiteRegistration` for the detail.\n\n Deprecated: Use `TfLiteOperatorSetPrepareWithData`"]
    pub unsafe fn TfLiteOperatorSetPrepare(
        &self,
        registration: *mut TfLiteOperator,
        prepare: ::std::option::Option<
            unsafe extern "C" fn(
                context: *mut TfLiteOpaqueContext,
                node: *mut TfLiteOpaqueNode,
            ) -> TfLiteStatus,
        >,
    ) {
        (self
            .TfLiteOperatorSetPrepare
            .as_ref()
            .expect("Expected function, got error."))(registration, prepare)
    }

    #[doc = " Sets the preparation callback for the registration. The function returns an\n error upon failure.\n\n The callback is called when the inputs of operator have been resized.  The\n value passed in the `user_data` parameter is the value that was passed to\n `TfLiteOperatorCreate`.  Please refer `prepare` of\n `TfLiteRegistration` for the detail.\n"]
    pub unsafe fn TfLiteOperatorSetPrepareWithData(
        &self,
        registration: *mut TfLiteOperator,
        prepare: ::std::option::Option<
            unsafe extern "C" fn(
                user_data: *mut ::std::os::raw::c_void,
                context: *mut TfLiteOpaqueContext,
                node: *mut TfLiteOpaqueNode,
            ) -> TfLiteStatus,
        >,
    ) -> TfLiteStatus {
        (self
            .TfLiteOperatorSetPrepareWithData
            .as_ref()
            .expect("Expected function, got error."))(registration, prepare)
    }

    #[doc = " Sets the invocation callback for the registration.\n\n The callback is called when the operator is executed.\n Please refer `invoke` of `TfLiteRegistration` for the detail.\n\n Deprecated: Use `TfLiteOperatorSetInvokeWithData`"]
    pub unsafe fn TfLiteOperatorSetInvoke(
        &self,
        registration: *mut TfLiteOperator,
        invoke: ::std::option::Option<
            unsafe extern "C" fn(
                context: *mut TfLiteOpaqueContext,
                node: *mut TfLiteOpaqueNode,
            ) -> TfLiteStatus,
        >,
    ) {
        (self
            .TfLiteOperatorSetInvoke
            .as_ref()
            .expect("Expected function, got error."))(registration, invoke)
    }

    #[doc = " Sets the invocation callback for the registration. The function returns an\n error upon failure.\n\n The callback is called when the operator is executed.  The value passed in\n the `user_data` parameter is the value that was passed to\n `TfLiteOperatorCreate`.  Please refer `invoke` of `TfLiteRegistration` for\n the detail.\n"]
    pub unsafe fn TfLiteOperatorSetInvokeWithData(
        &self,
        registration: *mut TfLiteOperator,
        invoke: ::std::option::Option<
            unsafe extern "C" fn(
                user_data: *mut ::std::os::raw::c_void,
                context: *mut TfLiteOpaqueContext,
                node: *mut TfLiteOpaqueNode,
            ) -> TfLiteStatus,
        >,
    ) -> TfLiteStatus {
        (self
            .TfLiteOperatorSetInvokeWithData
            .as_ref()
            .expect("Expected function, got error."))(registration, invoke)
    }

    #[doc = " Sets the async kernel accessor callback for the registration.\n\n The callback is called to retrieve the async kernel if the delegate supports\n it. If the delegate does not support async execution, either this function\n should not be called, or `async_kernel` needs to be nullptr.\n `node` is the delegate TfLiteNode created by `ModifyGraphWithDelegate`.\n Please refer `async_kernel` of `TfLiteRegistration` for the detail.\n\n \\warning This is an experimental API and subject to change.\n Deprecated: Use `TfLiteOperatorSetAsyncKernelWithData`"]
    pub unsafe fn TfLiteOperatorSetAsyncKernel(
        &self,
        registration: *mut TfLiteOperator,
        async_kernel: ::std::option::Option<
            unsafe extern "C" fn(
                context: *mut TfLiteOpaqueContext,
                node: *mut TfLiteOpaqueNode,
            ) -> *mut TfLiteAsyncKernel,
        >,
    ) {
        (self
            .TfLiteOperatorSetAsyncKernel
            .as_ref()
            .expect("Expected function, got error."))(registration, async_kernel)
    }

    #[doc = " Sets the async kernel accessor callback for the registration. The function\n returns an error upon failure.\n\n The callback is called to retrieve the async kernel if the delegate supports\n it. If the delegate does not support async execution, either this function\n should not be called, or `async_kernel` needs to be nullptr.  `node` is the\n delegate TfLiteNode created by `ModifyGraphWithDelegate`.  The value passed\n in the `user_data` parameter is the value that was passed to\n `TfLiteOperatorCreate`.  Please refer `async_kernel` of `TfLiteRegistration`\n for the detail.\n\n \\warning This is an experimental API and subject to change."]
    pub unsafe fn TfLiteOperatorSetAsyncKernelWithData(
        &self,
        registration: *mut TfLiteOperator,
        async_kernel: ::std::option::Option<
            unsafe extern "C" fn(
                user_data: *mut ::std::os::raw::c_void,
                context: *mut TfLiteOpaqueContext,
                node: *mut TfLiteOpaqueNode,
            ) -> *mut TfLiteAsyncKernel,
        >,
    ) -> TfLiteStatus {
        (self
            .TfLiteOperatorSetAsyncKernelWithData
            .as_ref()
            .expect("Expected function, got error."))(registration, async_kernel)
    }

    #[doc = " Sets the inplace_operator field of the external registration.\n\n This is a bitmask. Please refer to `inplace_operator` field of\n `TfLiteRegistration` for details.\n"]
    pub unsafe fn TfLiteOperatorSetInplaceOperator(
        &self,
        registration: *mut TfLiteOperator,
        inplace_operator: u64,
    ) {
        (self
            .TfLiteOperatorSetInplaceOperator
            .as_ref()
            .expect("Expected function, got error."))(registration, inplace_operator)
    }

    #[doc = " The TensorFlow Lite Runtime version.\n\n Returns a pointer to a statically allocated string that is the version\n number of the (potentially dynamically loaded) TF Lite Runtime library.\n TensorFlow Lite uses semantic versioning, and the return value should be\n in semver 2 format <http://semver.org>, starting with MAJOR.MINOR.PATCH,\n e.g. \"2.12.0\" or \"2.13.0-rc2\"."]
    pub unsafe fn TfLiteVersion(&self) -> *const ::std::os::raw::c_char {
        (self
            .TfLiteVersion
            .as_ref()
            .expect("Expected function, got error."))()
    }

    #[doc = " The TensorFlow Lite Extension APIs version.\n\n Returns a pointer to a statically allocated string that is the version\n number of the TF Lite Extension APIs supported by the (potentially\n dynamically loaded) TF Lite Runtime library.  The TF Lite \"Extension APIs\"\n are the APIs for extending TF Lite with custom ops and delegates.\n More specifically, this version number covers the (non-experimental)\n functionality documented in the following header files:\n\n   * lite/c/c_api_opaque.h\n   * lite/c/common.h\n   * lite/c/builtin_op_data.h\n   * lite/builtin_ops.h\n\n This version number uses semantic versioning, and the return value should\n be in semver 2 format <http://semver.org>, starting with MAJOR.MINOR.PATCH,\n e.g. \"2.14.0\" or \"2.15.0-rc2\"."]
    pub unsafe fn TfLiteExtensionApisVersion(&self) -> *const ::std::os::raw::c_char {
        (self
            .TfLiteExtensionApisVersion
            .as_ref()
            .expect("Expected function, got error."))()
    }

    #[doc = " The supported TensorFlow Lite model file Schema version.\n\n Returns the (major) version number of the Schema used for model\n files that is supported by the (potentially dynamically loaded)\n TensorFlow Lite Runtime.\n\n Model files using schema versions different to this may not be supported by\n the current version of the TF Lite Runtime."]
    pub unsafe fn TfLiteSchemaVersion(&self) -> ::std::os::raw::c_int {
        (self
            .TfLiteSchemaVersion
            .as_ref()
            .expect("Expected function, got error."))()
    }

    #[doc = " Returns a model from the provided buffer, or null on failure.\n\n \\note The caller retains ownership of the `model_data` buffer and should\n ensure that the lifetime of the `model_data` buffer must be at least as long\n as the lifetime of the `TfLiteModel` and of any `TfLiteInterpreter` objects\n created from that `TfLiteModel`, and furthermore the contents of the\n `model_data` buffer must not be modified during that time.\""]
    pub unsafe fn TfLiteModelCreate(
        &self,
        model_data: *const ::std::os::raw::c_void,
        model_size: usize,
    ) -> *mut TfLiteModel {
        (self
            .TfLiteModelCreate
            .as_ref()
            .expect("Expected function, got error."))(model_data, model_size)
    }

    #[doc = " Same as `TfLiteModelCreate` with customizble error reporter.\n * `reporter` takes the provided `user_data` object, as well as a C-style\n   format string and arg list (see also vprintf).\n * `user_data` is optional. If non-null, it is owned by the client and must\n   remain valid for the duration of the interpreter lifetime."]
    pub unsafe fn TfLiteModelCreateWithErrorReporter(
        &self,
        model_data: *const ::std::os::raw::c_void,
        model_size: usize,
        reporter: ::std::option::Option<
            unsafe extern "C" fn(
                user_data: *mut ::std::os::raw::c_void,
                format: *const ::std::os::raw::c_char,
                args: *mut __va_list_tag,
            ),
        >,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut TfLiteModel {
        (self
            .TfLiteModelCreateWithErrorReporter
            .as_ref()
            .expect("Expected function, got error."))(
            model_data, model_size, reporter, user_data
        )
    }

    #[doc = " Returns a model from the provided file, or null on failure.\n\n \\note The file's contents must not be modified during the lifetime of the\n `TfLiteModel` or of any `TfLiteInterpreter` objects created from that\n `TfLiteModel`."]
    pub unsafe fn TfLiteModelCreateFromFile(
        &self,
        model_path: *const ::std::os::raw::c_char,
    ) -> *mut TfLiteModel {
        (self
            .TfLiteModelCreateFromFile
            .as_ref()
            .expect("Expected function, got error."))(model_path)
    }

    #[doc = " Same as `TfLiteModelCreateFromFile` with customizble error reporter.\n * `reporter` takes the provided `user_data` object, as well as a C-style\n   format string and arg list (see also vprintf).\n * `user_data` is optional. If non-null, it is owned by the client and must\n   remain valid for the duration of the interpreter lifetime."]
    pub unsafe fn TfLiteModelCreateFromFileWithErrorReporter(
        &self,
        model_path: *const ::std::os::raw::c_char,
        reporter: ::std::option::Option<
            unsafe extern "C" fn(
                user_data: *mut ::std::os::raw::c_void,
                format: *const ::std::os::raw::c_char,
                args: *mut __va_list_tag,
            ),
        >,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut TfLiteModel {
        (self
            .TfLiteModelCreateFromFileWithErrorReporter
            .as_ref()
            .expect("Expected function, got error."))(model_path, reporter, user_data)
    }

    #[doc = " Destroys the model instance."]
    pub unsafe fn TfLiteModelDelete(&self, model: *mut TfLiteModel) {
        (self
            .TfLiteModelDelete
            .as_ref()
            .expect("Expected function, got error."))(model)
    }

    #[doc = " Returns a new interpreter options instances."]
    pub unsafe fn TfLiteInterpreterOptionsCreate(&self) -> *mut TfLiteInterpreterOptions {
        (self
            .TfLiteInterpreterOptionsCreate
            .as_ref()
            .expect("Expected function, got error."))()
    }

    #[doc = " Creates and returns a shallow copy of an options object.\n\n The caller is responsible for calling `TfLiteInterpreterOptionsDelete` to\n deallocate the object pointed to by the returned pointer."]
    pub unsafe fn TfLiteInterpreterOptionsCopy(
        &self,
        from: *const TfLiteInterpreterOptions,
    ) -> *mut TfLiteInterpreterOptions {
        (self
            .TfLiteInterpreterOptionsCopy
            .as_ref()
            .expect("Expected function, got error."))(from)
    }

    #[doc = " Destroys the interpreter options instance."]
    pub unsafe fn TfLiteInterpreterOptionsDelete(&self, options: *mut TfLiteInterpreterOptions) {
        (self
            .TfLiteInterpreterOptionsDelete
            .as_ref()
            .expect("Expected function, got error."))(options)
    }

    #[doc = " Sets the number of CPU threads to use for the interpreter."]
    pub unsafe fn TfLiteInterpreterOptionsSetNumThreads(
        &self,
        options: *mut TfLiteInterpreterOptions,
        num_threads: i32,
    ) {
        (self
            .TfLiteInterpreterOptionsSetNumThreads
            .as_ref()
            .expect("Expected function, got error."))(options, num_threads)
    }

    #[doc = " Adds a delegate to be applied during `TfLiteInterpreter` creation.\n\n If delegate application fails, interpreter creation will also fail with an\n associated error logged.\n\n \\note The caller retains ownership of the delegate and should ensure that it\n remains valid for the duration of any created interpreter's lifetime.\n\n If you are NOT using \"TensorFlow Lite in Play Services\", and NOT building\n with `TFLITE_WITH_STABLE_ABI` or `TFLITE_USE_OPAQUE_DELEGATE` macros\n enabled, it is possible to pass a `TfLiteDelegate*` rather than a\n `TfLiteOpaqueDelegate*` to this function, since in those cases,\n `TfLiteOpaqueDelegate` is just a typedef alias for `TfLiteDelegate`.\n This is for compatibility with existing source code\n and existing delegates.  For new delegates, it is recommended to\n use `TfLiteOpaqueDelegate` rather than `TfLiteDelegate`.  (See\n `TfLiteOpaqueDelegate` in tensorflow/lite/core/c/c_api_types.h.)"]
    pub unsafe fn TfLiteInterpreterOptionsAddDelegate(
        &self,
        options: *mut TfLiteInterpreterOptions,
        delegate: *mut TfLiteOpaqueDelegate,
    ) {
        (self
            .TfLiteInterpreterOptionsAddDelegate
            .as_ref()
            .expect("Expected function, got error."))(options, delegate)
    }

    #[doc = " Sets a custom error reporter for interpreter execution.\n\n * `reporter` takes the provided `user_data` object, as well as a C-style\n   format string and arg list (see also vprintf).\n * `user_data` is optional. If non-null, it is owned by the client and must\n   remain valid for the duration of the interpreter lifetime."]
    pub unsafe fn TfLiteInterpreterOptionsSetErrorReporter(
        &self,
        options: *mut TfLiteInterpreterOptions,
        reporter: ::std::option::Option<
            unsafe extern "C" fn(
                user_data: *mut ::std::os::raw::c_void,
                format: *const ::std::os::raw::c_char,
                args: *mut __va_list_tag,
            ),
        >,
        user_data: *mut ::std::os::raw::c_void,
    ) {
        (self
            .TfLiteInterpreterOptionsSetErrorReporter
            .as_ref()
            .expect("Expected function, got error."))(options, reporter, user_data)
    }

    #[doc = " Adds an op registration to be applied during `TfLiteInterpreter` creation.\n\n The `TfLiteOperator` object is needed to implement custom op of\n TFLite Interpreter via C API. Calling this function ensures that any\n `TfLiteInterpreter` created with the specified `options` can execute models\n that use the custom operator specified in `registration`.\n Please refer https://www.tensorflow.org/lite/guide/ops_custom for custom op\n support.\n \\note The caller retains ownership of the TfLiteOperator object\n and should ensure that it remains valid for the duration of any created\n interpreter's lifetime.\n \\warning This is an experimental API and subject to change."]
    pub unsafe fn TfLiteInterpreterOptionsAddOperator(
        &self,
        options: *mut TfLiteInterpreterOptions,
        registration: *mut TfLiteOperator,
    ) {
        (self
            .TfLiteInterpreterOptionsAddOperator
            .as_ref()
            .expect("Expected function, got error."))(options, registration)
    }

    #[doc = " Enables users to cancel in-flight invocations with\n `TfLiteInterpreterCancel`.\n\n By default it is disabled and calling to `TfLiteInterpreterCancel` will\n return kTfLiteError. See `TfLiteInterpreterCancel`."]
    pub unsafe fn TfLiteInterpreterOptionsEnableCancellation(
        &self,
        options: *mut TfLiteInterpreterOptions,
        enable: bool,
    ) -> TfLiteStatus {
        (self
            .TfLiteInterpreterOptionsEnableCancellation
            .as_ref()
            .expect("Expected function, got error."))(options, enable)
    }

    #[doc = " Returns a new interpreter using the provided model and options, or null on\n failure.\n\n * `model` must be a valid model instance. The caller retains ownership of\n   the object, and may destroy it (via TfLiteModelDelete) immediately after\n   creating the interpreter.  However, if the TfLiteModel was allocated with\n   TfLiteModelCreate, then the `model_data` buffer that was passed to\n   TfLiteModelCreate must outlive the lifetime of the TfLiteInterpreter\n   object that this function returns, and must not be modified during that\n   time; and if the TfLiteModel was allocated with TfLiteModelCreateFromFile,\n   then the contents of the model file must not be modified during the\n   lifetime of the TfLiteInterpreter object that this function returns.\n * `optional_options` may be null. The caller retains ownership of the\n   object, and can safely destroy it (via TfLiteInterpreterOptionsDelete)\n   immediately after creating the interpreter.\n\n \\note The client *must* explicitly allocate tensors before attempting to\n access input tensor data or invoke the interpreter."]
    pub unsafe fn TfLiteInterpreterCreate(
        &self,
        model: *const TfLiteModel,
        optional_options: *const TfLiteInterpreterOptions,
    ) -> *mut TfLiteInterpreter {
        (self
            .TfLiteInterpreterCreate
            .as_ref()
            .expect("Expected function, got error."))(model, optional_options)
    }

    #[doc = " Destroys the interpreter."]
    pub unsafe fn TfLiteInterpreterDelete(&self, interpreter: *mut TfLiteInterpreter) {
        (self
            .TfLiteInterpreterDelete
            .as_ref()
            .expect("Expected function, got error."))(interpreter)
    }

    #[doc = " Returns the number of input tensors associated with the model."]
    pub unsafe fn TfLiteInterpreterGetInputTensorCount(
        &self,
        interpreter: *const TfLiteInterpreter,
    ) -> i32 {
        (self
            .TfLiteInterpreterGetInputTensorCount
            .as_ref()
            .expect("Expected function, got error."))(interpreter)
    }

    #[doc = " Returns a pointer to an array of input tensor indices.  The length of the\n array can be obtained via a call to `TfLiteInterpreterGetInputTensorCount`.\n\n Typically the input tensors associated with an `interpreter` would be set\n during the initialization of the `interpreter`, through a mechanism like the\n `InterpreterBuilder`, and remain unchanged throughout the lifetime of the\n interpreter.  However, there are some circumstances in which the pointer may\n not remain valid throughout the lifetime of the interpreter, because calls\n to `SetInputs` on the interpreter invalidate the returned pointer.\n\n The ownership of the array remains with the TFLite runtime."]
    pub unsafe fn TfLiteInterpreterInputTensorIndices(
        &self,
        interpreter: *const TfLiteInterpreter,
    ) -> *const ::std::os::raw::c_int {
        (self
            .TfLiteInterpreterInputTensorIndices
            .as_ref()
            .expect("Expected function, got error."))(interpreter)
    }

    #[doc = " Returns the tensor associated with the input index.\n REQUIRES: 0 <= input_index < TfLiteInterpreterGetInputTensorCount(tensor)"]
    pub unsafe fn TfLiteInterpreterGetInputTensor(
        &self,
        interpreter: *const TfLiteInterpreter,
        input_index: i32,
    ) -> *mut TfLiteTensor {
        (self
            .TfLiteInterpreterGetInputTensor
            .as_ref()
            .expect("Expected function, got error."))(interpreter, input_index)
    }

    #[doc = " Resizes the specified input tensor.\n\n \\note After a resize, the client *must* explicitly allocate tensors before\n attempting to access the resized tensor data or invoke the interpreter.\n\n REQUIRES: 0 <= input_index < TfLiteInterpreterGetInputTensorCount(tensor)\n\n This function makes a copy of the input dimensions, so the client can safely\n deallocate `input_dims` immediately after this function returns."]
    pub unsafe fn TfLiteInterpreterResizeInputTensor(
        &self,
        interpreter: *mut TfLiteInterpreter,
        input_index: i32,
        input_dims: *const ::std::os::raw::c_int,
        input_dims_size: i32,
    ) -> TfLiteStatus {
        (self
            .TfLiteInterpreterResizeInputTensor
            .as_ref()
            .expect("Expected function, got error."))(
            interpreter,
            input_index,
            input_dims,
            input_dims_size,
        )
    }

    #[doc = " Updates allocations for all tensors, resizing dependent tensors using the\n specified input tensor dimensionality.\n\n This is a relatively expensive operation, and need only be called after\n creating the graph and/or resizing any inputs."]
    pub unsafe fn TfLiteInterpreterAllocateTensors(
        &self,
        interpreter: *mut TfLiteInterpreter,
    ) -> TfLiteStatus {
        (self
            .TfLiteInterpreterAllocateTensors
            .as_ref()
            .expect("Expected function, got error."))(interpreter)
    }

    #[doc = " Runs inference for the loaded graph.\n\n Before calling this function, the caller should first invoke\n TfLiteInterpreterAllocateTensors() and should also set the values for the\n input tensors.  After successfully calling this function, the values for the\n output tensors will be set.\n\n \\note It is possible that the interpreter is not in a ready state to\n evaluate (e.g., if AllocateTensors() hasn't been called, or if a\n ResizeInputTensor() has been performed without a subsequent call to\n AllocateTensors()).\n\n   If the (experimental!) delegate fallback option was enabled in the\n   interpreter options, then the interpreter will automatically fall back to\n   not using any delegates if execution with delegates fails. For details,\n   see TfLiteInterpreterOptionsSetEnableDelegateFallback in\n   c_api_experimental.h.\n\n Returns one of the following status codes:\n  - kTfLiteOk: Success. Output is valid.\n  - kTfLiteDelegateError: Execution with delegates failed, due to a problem\n    with the delegate(s). If fallback was not enabled, output is invalid.\n    If fallback was enabled, this return value indicates that fallback\n    succeeded, the output is valid, and all delegates previously applied to\n    the interpreter have been undone.\n  - kTfLiteApplicationError: Same as for kTfLiteDelegateError, except that\n    the problem was not with the delegate itself, but rather was\n    due to an incompatibility between the delegate(s) and the\n    interpreter or model.\n  - kTfLiteError: Unexpected/runtime failure. Output is invalid."]
    pub unsafe fn TfLiteInterpreterInvoke(
        &self,
        interpreter: *mut TfLiteInterpreter,
    ) -> TfLiteStatus {
        (self
            .TfLiteInterpreterInvoke
            .as_ref()
            .expect("Expected function, got error."))(interpreter)
    }

    #[doc = " Returns the number of output tensors associated with the model."]
    pub unsafe fn TfLiteInterpreterGetOutputTensorCount(
        &self,
        interpreter: *const TfLiteInterpreter,
    ) -> i32 {
        (self
            .TfLiteInterpreterGetOutputTensorCount
            .as_ref()
            .expect("Expected function, got error."))(interpreter)
    }

    #[doc = " Returns a pointer to an array of output tensor indices.  The length of the\n array can be obtained via a call to `TfLiteInterpreterGetOutputTensorCount`.\n\n Typically the output tensors associated with an `interpreter` would be set\n during the initialization of the `interpreter`, through a mechanism like the\n `InterpreterBuilder`, and remain unchanged throughout the lifetime of the\n interpreter.  However, there are some circumstances in which the pointer may\n not remain valid throughout the lifetime of the interpreter, because calls\n to `SetOutputs` on the interpreter invalidate the returned pointer.\n\n The ownership of the array remains with the TFLite runtime."]
    pub unsafe fn TfLiteInterpreterOutputTensorIndices(
        &self,
        interpreter: *const TfLiteInterpreter,
    ) -> *const ::std::os::raw::c_int {
        (self
            .TfLiteInterpreterOutputTensorIndices
            .as_ref()
            .expect("Expected function, got error."))(interpreter)
    }

    #[doc = " Returns the tensor associated with the output index.\n REQUIRES: 0 <= output_index < TfLiteInterpreterGetOutputTensorCount(tensor)\n\n \\note The shape and underlying data buffer for output tensors may be not\n be available until after the output tensor has been both sized and\n allocated.\n In general, best practice is to interact with the output tensor *after*\n calling TfLiteInterpreterInvoke()."]
    pub unsafe fn TfLiteInterpreterGetOutputTensor(
        &self,
        interpreter: *const TfLiteInterpreter,
        output_index: i32,
    ) -> *const TfLiteTensor {
        (self
            .TfLiteInterpreterGetOutputTensor
            .as_ref()
            .expect("Expected function, got error."))(interpreter, output_index)
    }

    #[doc = " Returns modifiable access to the tensor that corresponds to the\n specified `index` and is associated with the provided `interpreter`.\n\n This requires the `index` to be between 0 and N - 1, where N is the\n number of tensors in the model.\n\n Typically the tensors associated with the `interpreter` would be set during\n the `interpreter` initialization, through a mechanism like the\n `InterpreterBuilder`, and remain unchanged throughout the lifetime of the\n interpreter.  However, there are some circumstances in which the pointer may\n not remain valid throughout the lifetime of the interpreter, because calls\n to `AddTensors` on the interpreter invalidate the returned pointer.\n\n Note the difference between this function and\n `TfLiteInterpreterGetInputTensor` (or `TfLiteInterpreterGetOutputTensor` for\n that matter): `TfLiteInterpreterGetTensor` takes an index into the array of\n all tensors associated with the `interpreter`'s model, whereas\n `TfLiteInterpreterGetInputTensor` takes an index into the array of input\n tensors.\n\n The ownership of the tensor remains with the TFLite runtime, meaning the\n caller should not deallocate the pointer."]
    pub unsafe fn TfLiteInterpreterGetTensor(
        &self,
        interpreter: *const TfLiteInterpreter,
        index: ::std::os::raw::c_int,
    ) -> *mut TfLiteTensor {
        (self
            .TfLiteInterpreterGetTensor
            .as_ref()
            .expect("Expected function, got error."))(interpreter, index)
    }

    #[doc = " Tries to cancel any in-flight invocation.\n\n \\note This only cancels `TfLiteInterpreterInvoke` calls that happen before\n calling this and it does not cancel subsequent invocations.\n \\note Calling this function will also cancel any in-flight invocations of\n SignatureRunners constructed from this interpreter.\n Non-blocking and thread safe.\n\n Returns kTfLiteError if cancellation is not enabled via\n `TfLiteInterpreterOptionsEnableCancellation`."]
    pub unsafe fn TfLiteInterpreterCancel(
        &self,
        interpreter: *const TfLiteInterpreter,
    ) -> TfLiteStatus {
        (self
            .TfLiteInterpreterCancel
            .as_ref()
            .expect("Expected function, got error."))(interpreter)
    }

    #[doc = " Returns the number of signatures defined in the model."]
    pub unsafe fn TfLiteInterpreterGetSignatureCount(
        &self,
        interpreter: *const TfLiteInterpreter,
    ) -> i32 {
        (self
            .TfLiteInterpreterGetSignatureCount
            .as_ref()
            .expect("Expected function, got error."))(interpreter)
    }

    #[doc = " Returns the key of the Nth signature in the model, where N is specified as\n `signature_index`.\n\n NOTE: The lifetime of the returned key is the same as (and depends on) the\n lifetime of `interpreter`."]
    pub unsafe fn TfLiteInterpreterGetSignatureKey(
        &self,
        interpreter: *const TfLiteInterpreter,
        signature_index: i32,
    ) -> *const ::std::os::raw::c_char {
        (self
            .TfLiteInterpreterGetSignatureKey
            .as_ref()
            .expect("Expected function, got error."))(interpreter, signature_index)
    }

    #[doc = " Returns a new signature runner using the provided interpreter and signature\n key, or nullptr on failure.\n\n NOTE: `signature_key` is a null-terminated C string that must match the\n key of a signature in the interpreter's model.\n\n NOTE: The returned signature runner should be destroyed, by calling\n TfLiteSignatureRunnerDelete(), before the interpreter is destroyed."]
    pub unsafe fn TfLiteInterpreterGetSignatureRunner(
        &self,
        interpreter: *const TfLiteInterpreter,
        signature_key: *const ::std::os::raw::c_char,
    ) -> *mut TfLiteSignatureRunner {
        (self
            .TfLiteInterpreterGetSignatureRunner
            .as_ref()
            .expect("Expected function, got error."))(interpreter, signature_key)
    }

    #[doc = " Returns the number of inputs associated with a signature."]
    pub unsafe fn TfLiteSignatureRunnerGetInputCount(
        &self,
        signature_runner: *const TfLiteSignatureRunner,
    ) -> usize {
        (self
            .TfLiteSignatureRunnerGetInputCount
            .as_ref()
            .expect("Expected function, got error."))(signature_runner)
    }

    #[doc = " Returns the (null-terminated) name of the Nth input in a signature, where N\n is specified as `input_index`.\n\n NOTE: The lifetime of the returned name is the same as (and depends on) the\n lifetime of `signature_runner`."]
    pub unsafe fn TfLiteSignatureRunnerGetInputName(
        &self,
        signature_runner: *const TfLiteSignatureRunner,
        input_index: i32,
    ) -> *const ::std::os::raw::c_char {
        (self
            .TfLiteSignatureRunnerGetInputName
            .as_ref()
            .expect("Expected function, got error."))(signature_runner, input_index)
    }

    #[doc = " Resizes the input tensor identified as `input_name` to be the dimensions\n specified by `input_dims` and `input_dims_size`. Only unknown dimensions can\n be resized with this function. Unknown dimensions are indicated as `-1` in\n the `dims_signature` attribute of a TfLiteTensor.\n\n Returns status of failure or success. Note that this doesn't actually resize\n any existing buffers. A call to TfLiteSignatureRunnerAllocateTensors() is\n required to change the tensor input buffer.\n\n NOTE: This function is similar to TfLiteInterpreterResizeInputTensorStrict()\n and not TfLiteInterpreterResizeInputTensor().\n\n NOTE: `input_name` must match the name of an input in the signature.\n\n NOTE: This function makes a copy of the input dimensions, so the caller can\n safely deallocate `input_dims` immediately after this function returns."]
    pub unsafe fn TfLiteSignatureRunnerResizeInputTensor(
        &self,
        signature_runner: *mut TfLiteSignatureRunner,
        input_name: *const ::std::os::raw::c_char,
        input_dims: *const ::std::os::raw::c_int,
        input_dims_size: i32,
    ) -> TfLiteStatus {
        (self
            .TfLiteSignatureRunnerResizeInputTensor
            .as_ref()
            .expect("Expected function, got error."))(
            signature_runner,
            input_name,
            input_dims,
            input_dims_size,
        )
    }

    #[doc = " Updates allocations for tensors associated with a signature and resizes\n dependent tensors using the specified input tensor dimensionality.\n This is a relatively expensive operation and hence should only be called\n after initializing the signature runner object and/or resizing any inputs."]
    pub unsafe fn TfLiteSignatureRunnerAllocateTensors(
        &self,
        signature_runner: *mut TfLiteSignatureRunner,
    ) -> TfLiteStatus {
        (self
            .TfLiteSignatureRunnerAllocateTensors
            .as_ref()
            .expect("Expected function, got error."))(signature_runner)
    }

    #[doc = " Returns the input tensor identified by `input_name` in the given signature.\n Returns nullptr if the given name is not valid.\n\n NOTE: The lifetime of the returned tensor is the same as (and depends on)\n the lifetime of `signature_runner`."]
    pub unsafe fn TfLiteSignatureRunnerGetInputTensor(
        &self,
        signature_runner: *mut TfLiteSignatureRunner,
        input_name: *const ::std::os::raw::c_char,
    ) -> *mut TfLiteTensor {
        (self
            .TfLiteSignatureRunnerGetInputTensor
            .as_ref()
            .expect("Expected function, got error."))(signature_runner, input_name)
    }

    #[doc = " Runs inference on a given signature.\n\n Before calling this function, the caller should first invoke\n TfLiteSignatureRunnerAllocateTensors() and should also set the values for\n the input tensors. After successfully calling this function, the values for\n the output tensors will be set."]
    pub unsafe fn TfLiteSignatureRunnerInvoke(
        &self,
        signature_runner: *mut TfLiteSignatureRunner,
    ) -> TfLiteStatus {
        (self
            .TfLiteSignatureRunnerInvoke
            .as_ref()
            .expect("Expected function, got error."))(signature_runner)
    }

    #[doc = " Returns the number of output tensors associated with the signature."]
    pub unsafe fn TfLiteSignatureRunnerGetOutputCount(
        &self,
        signature_runner: *const TfLiteSignatureRunner,
    ) -> usize {
        (self
            .TfLiteSignatureRunnerGetOutputCount
            .as_ref()
            .expect("Expected function, got error."))(signature_runner)
    }

    #[doc = " Returns the (null-terminated) name of the Nth output in a signature, where\n N is specified as `output_index`.\n\n NOTE: The lifetime of the returned name is the same as (and depends on) the\n lifetime of `signature_runner`."]
    pub unsafe fn TfLiteSignatureRunnerGetOutputName(
        &self,
        signature_runner: *const TfLiteSignatureRunner,
        output_index: i32,
    ) -> *const ::std::os::raw::c_char {
        (self
            .TfLiteSignatureRunnerGetOutputName
            .as_ref()
            .expect("Expected function, got error."))(signature_runner, output_index)
    }

    #[doc = " Returns the output tensor identified by `output_name` in the given\n signature. Returns nullptr if the given name is not valid.\n\n NOTE: The lifetime of the returned tensor is the same as (and depends on)\n the lifetime of `signature_runner`."]
    pub unsafe fn TfLiteSignatureRunnerGetOutputTensor(
        &self,
        signature_runner: *const TfLiteSignatureRunner,
        output_name: *const ::std::os::raw::c_char,
    ) -> *const TfLiteTensor {
        (self
            .TfLiteSignatureRunnerGetOutputTensor
            .as_ref()
            .expect("Expected function, got error."))(signature_runner, output_name)
    }

    #[doc = " Returns the type of a tensor element."]
    pub unsafe fn TfLiteTensorType(&self, tensor: *const TfLiteTensor) -> TfLiteType {
        (self
            .TfLiteTensorType
            .as_ref()
            .expect("Expected function, got error."))(tensor)
    }

    #[doc = " Returns the number of dimensions that the tensor has.  Returns -1 in case\n the 'opaque_tensor' does not have its dimensions property set."]
    pub unsafe fn TfLiteTensorNumDims(&self, tensor: *const TfLiteTensor) -> i32 {
        (self
            .TfLiteTensorNumDims
            .as_ref()
            .expect("Expected function, got error."))(tensor)
    }

    #[doc = " Returns the length of the tensor in the \"dim_index\" dimension.\n REQUIRES: 0 <= dim_index < TFLiteTensorNumDims(tensor)"]
    pub unsafe fn TfLiteTensorDim(&self, tensor: *const TfLiteTensor, dim_index: i32) -> i32 {
        (self
            .TfLiteTensorDim
            .as_ref()
            .expect("Expected function, got error."))(tensor, dim_index)
    }

    #[doc = " Returns the size of the underlying data in bytes."]
    pub unsafe fn TfLiteTensorByteSize(&self, tensor: *const TfLiteTensor) -> usize {
        (self
            .TfLiteTensorByteSize
            .as_ref()
            .expect("Expected function, got error."))(tensor)
    }

    #[doc = " Returns a pointer to the underlying data buffer.\n\n \\note The result may be null if tensors have not yet been allocated, e.g.,\n if the Tensor has just been created or resized and `TfLiteAllocateTensors()`\n has yet to be called, or if the output tensor is dynamically sized and the\n interpreter hasn't been invoked."]
    pub unsafe fn TfLiteTensorData(
        &self,
        tensor: *const TfLiteTensor,
    ) -> *mut ::std::os::raw::c_void {
        (self
            .TfLiteTensorData
            .as_ref()
            .expect("Expected function, got error."))(tensor)
    }

    #[doc = " Returns the (null-terminated) name of the tensor."]
    pub unsafe fn TfLiteTensorName(
        &self,
        tensor: *const TfLiteTensor,
    ) -> *const ::std::os::raw::c_char {
        (self
            .TfLiteTensorName
            .as_ref()
            .expect("Expected function, got error."))(tensor)
    }

    #[doc = " Returns the parameters for asymmetric quantization. The quantization\n parameters are only valid when the tensor type is `kTfLiteUInt8` and the\n `scale != 0`. Quantized values can be converted back to float using:\n    real_value = scale * (quantized_value - zero_point);"]
    pub unsafe fn TfLiteTensorQuantizationParams(
        &self,
        tensor: *const TfLiteTensor,
    ) -> TfLiteQuantizationParams {
        (self
            .TfLiteTensorQuantizationParams
            .as_ref()
            .expect("Expected function, got error."))(tensor)
    }

    #[doc = " Copies from the provided input buffer into the tensor's buffer.\n REQUIRES: input_data_size == TfLiteTensorByteSize(tensor)"]
    pub unsafe fn TfLiteTensorCopyFromBuffer(
        &self,
        tensor: *mut TfLiteTensor,
        input_data: *const ::std::os::raw::c_void,
        input_data_size: usize,
    ) -> TfLiteStatus {
        (self
            .TfLiteTensorCopyFromBuffer
            .as_ref()
            .expect("Expected function, got error."))(tensor, input_data, input_data_size)
    }

    #[doc = " Copies to the provided output buffer from the tensor's buffer.\n REQUIRES: output_data_size == TfLiteTensorByteSize(tensor)"]
    pub unsafe fn TfLiteTensorCopyToBuffer(
        &self,
        output_tensor: *const TfLiteTensor,
        output_data: *mut ::std::os::raw::c_void,
        output_data_size: usize,
    ) -> TfLiteStatus {
        (self
            .TfLiteTensorCopyToBuffer
            .as_ref()
            .expect("Expected function, got error."))(
            output_tensor, output_data, output_data_size
        )
    }

    #[doc = " Destroys the signature runner."]
    pub unsafe fn TfLiteSignatureRunnerDelete(&self, signature_runner: *mut TfLiteSignatureRunner) {
        (self
            .TfLiteSignatureRunnerDelete
            .as_ref()
            .expect("Expected function, got error."))(signature_runner)
    }
}
